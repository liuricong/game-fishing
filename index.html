<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ’˜ çˆ±çš„å®ˆæŠ¤è€… - Love Guardian</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'PingFang SC', sans-serif;
            background: linear-gradient(180deg, #001a33 0%, #003366 50%, #004080 100%);
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        .game-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .game-hud {
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px;
            display: flex;
            justify-content: flex-start;
            pointer-events: none;
            z-index: 5;
        }

        .hud-score {
            color: #ff69b4;
            font-size: 24px;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(255, 105, 180, 0.8), 0 2px 4px rgba(0,0,0,0.5);
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10;
        }

        .overlay.hidden {
            display: none;
        }
        
        .hidden {
            display: none !important;
        }

        /* é¦–é¡µç¾åŒ– - æµ·æ´‹ä¸»é¢˜ */
        #startScreen {
            background: transparent;
        }
        #startScreen::before {
            content: '';
            position: absolute;
            inset: 0;
            background:
                radial-gradient(1200px 600px at 80% -10%, rgba(0,180,216,0.25), transparent 60%),
                radial-gradient(900px 500px at -10% 110%, rgba(0,119,182,0.20), transparent 60%),
                radial-gradient(800px 500px at 50% 50%, rgba(72,202,228,0.08), transparent 60%),
                linear-gradient(180deg, rgba(0,26,51,0.95), rgba(0,51,102,0.95));
            z-index: -1;
        }
        /* é¦–é¡µ Canvas èƒŒæ™¯å±‚ */
        #homepageCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 14px;
            width: min(85vw, 380px);
            z-index: 1;
        }
        .menu-btn {
            padding: 14px 26px;
            font-size: 18px;
            font-weight: 700;
            color: #fff;
            border-radius: 14px;
            border: 1px solid rgba(255,255,255,0.25);
            background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02));
            box-shadow: 0 10px 30px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.25);
            backdrop-filter: blur(6px);
            cursor: pointer;
            transition: transform .15s ease, box-shadow .2s ease;
        }
        .menu-btn:hover { transform: translateY(-2px); box-shadow: 0 14px 34px rgba(0,0,0,0.45); }
        .menu-btn:active { transform: translateY(0); }
        .menu-btn.secondary {
            border-color: rgba(0,180,216,0.5);
            background: linear-gradient(180deg, rgba(0,180,216,0.25), rgba(0,119,182,0.15));
        }
        
        /* é¦–é¡µæè¿°ï¼šå±…ä¸­ + é™å®½ + ä¸¤ä¾§å†…è¾¹è· */
        .start-desc {
            color: rgba(255,255,255,0.65);
            font-size: 13px;
            text-align: center;
            width: min(90vw, 420px);
            margin: 6px auto 0;
            line-height: 1.6;
            padding: 0 12px;
            z-index: 1;
        }
        
        /* é¦–é¡µéšæœºæè¿°æ–‡æ¡ˆ */
        .start-quote {
            color: #fff;
            font-size: 15px;
            font-weight: 600;
            text-align: center;
            width: min(85vw, 380px);
            margin: 0 auto 20px;
            line-height: 1.8;
            padding: 12px 18px;
            background: rgba(0, 0, 0, 0.35);
            border-radius: 14px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            /* ç«‹ä½“æè¾¹æ•ˆæœ */
            text-shadow:
                -1px -1px 0 rgba(0, 80, 150, 0.8),
                1px -1px 0 rgba(0, 80, 150, 0.8),
                -1px 1px 0 rgba(0, 80, 150, 0.8),
                1px 1px 0 rgba(0, 80, 150, 0.8),
                0 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 1;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
        }

        .game-title {
            font-size: 48px;
            font-weight: 800;
            background: linear-gradient(135deg, #ff69b4, #ff1493, #ff6b9d, #da70d6);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradient-shift 3s ease infinite;
            margin-bottom: 10px;
            text-shadow: 0 0 30px rgba(255, 105, 180, 0.5);
        }

        @keyframes gradient-shift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .game-subtitle {
            color: rgba(255, 255, 255, 0.7);
            font-size: 16px;
            margin-bottom: 40px;
            letter-spacing: 3px;
        }

        .btn {
            padding: 15px 50px;
            font-size: 20px;
            font-weight: 600;
            color: #fff;
            background: linear-gradient(135deg, #ff69b4 0%, #ff1493 100%);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 10px 30px rgba(255, 20, 147, 0.4);
            margin: 10px;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 40px rgba(255, 20, 147, 0.6);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-restart {
            background: linear-gradient(135deg, #da70d6 0%, #ff69b4 100%);
            box-shadow: 0 10px 30px rgba(218, 112, 214, 0.4);
        }

        .btn-restart:hover {
            box-shadow: 0 15px 40px rgba(218, 112, 214, 0.6);
        }

        .final-score {
            font-size: 28px;
            color: #fff;
            margin: 20px 0;
        }

        .final-score span {
            color: #ff69b4;
            font-size: 42px;
            font-weight: 700;
        }

        .game-over-title {
            font-size: 48px;
            color: #ff69b4;
            font-weight: 800;
            text-shadow: 0 0 30px rgba(255, 105, 180, 0.8);
            margin-bottom: 20px;
        }

        .instructions {
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            margin-top: 30px;
            text-align: center;
            line-height: 1.8;
        }

        .instructions kbd {
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 12px;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin: 0 3px;
        }

        .power-up-indicator {
            position: absolute;
            top: 80px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 5;
        }

        .power-up-badge {
            padding: 5px 10px;
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
            border-radius: 5px;
            color: #00ff88;
            font-size: 12px;
            font-weight: 600;
        }

        .powerup-status {
            position: absolute;
            top: 45px;
            left: 15px;
            display: flex;
            gap: 8px;
            z-index: 5;
        }
        .powerup-icon {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            background: rgba(0,0,0,0.4);
            border: 2px solid rgba(255,255,255,0.3);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            position: relative;
        }
        .powerup-icon .timer-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background: #ffd700;
            border-radius: 0 0 6px 6px;
            transition: width 0.1s linear;
        }

        .wave-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            font-weight: 800;
            color: #fff;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.8);
            opacity: 0;
            z-index: 5;
            pointer-events: none;
            white-space: nowrap;
        }

        .wave-display.show {
            animation: wave-announce 2s ease-out forwards;
        }

        @keyframes wave-announce {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }
        
        /* Bossè¡€æ¡UI */
        .boss-hp-container {
            position: absolute;
            top: 55px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            z-index: 6;
            pointer-events: none;
            width: 50%;
            min-width: 180px;
            max-width: 280px;
        }
        .boss-hp-container.show {
            display: flex;
            animation: boss-hp-appear 0.5s ease-out;
        }
        @keyframes boss-hp-appear {
            0% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
            100% { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
        .boss-name {
            color: #fff;
            font-size: 14px;
            font-weight: 700;
            text-shadow: 0 2px 8px rgba(0,0,0,0.6);
            text-align: center;
            white-space: nowrap;
        }
        .boss-name .phase-badge {
            display: inline-block;
            background: linear-gradient(135deg, #ff6b6b, #d63031);
            color: #fff;
            font-size: 10px;
            padding: 2px 8px;
            border-radius: 10px;
            margin-left: 6px;
            vertical-align: middle;
            box-shadow: 0 2px 6px rgba(214, 48, 49, 0.5);
        }
        .boss-hp-bar-outer {
            width: 100%;
            height: 12px;
            background: rgba(0,0,0,0.5);
            border-radius: 6px;
            border: 2px solid rgba(255,255,255,0.3);
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.4), inset 0 1px 3px rgba(0,0,0,0.5);
        }
        .boss-hp-bar-inner {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00cc66);
            border-radius: 4px;
            transition: width 0.15s ease-out;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5), inset 0 1px 0 rgba(255,255,255,0.3);
        }
        .boss-hp-bar-inner.low {
            background: linear-gradient(90deg, #ff6b6b, #d63031);
            box-shadow: 0 0 10px rgba(255, 107, 107, 0.5), inset 0 1px 0 rgba(255,255,255,0.3);
            animation: hp-low-pulse 0.5s ease-in-out infinite;
        }
        .boss-hp-bar-inner.medium {
            background: linear-gradient(90deg, #ffd93d, #ff9f1a);
            box-shadow: 0 0 10px rgba(255, 217, 61, 0.5), inset 0 1px 0 rgba(255,255,255,0.3);
        }
        @keyframes hp-low-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        .boss-phase-dots {
            display: flex;
            gap: 6px;
            margin-top: 2px;
        }
        .boss-phase-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255,255,255,0.3);
            border: 1px solid rgba(255,255,255,0.4);
            transition: all 0.3s ease;
        }
        .boss-phase-dot.active {
            background: #ffd700;
            border-color: #ffd700;
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.8);
        }
        .boss-phase-dot.completed {
            background: #00ff88;
            border-color: #00ff88;
            box-shadow: 0 0 6px rgba(0, 255, 136, 0.6);
        }

        /* ç§»åŠ¨ç«¯é€‚é… */
        @media (max-width: 520px) {
            .game-title {
                font-size: 36px;
            }
            
            .btn {
                padding: 12px 40px;
                font-size: 18px;
            }
        }

        /* ç§»åŠ¨ç«¯æç¤º */
        .mobile-controls-hint {
            display: none;
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            margin-top: 20px;
            text-align: center;
        }

        @media (pointer: coarse) {
            .instructions {
                display: none;
            }
            
            .mobile-controls-hint {
                display: block;
            }
        }
        
        /* æˆå°±ç³»ç»Ÿæ ·å¼ */
        #achievementScreen {
            background: linear-gradient(180deg, rgba(0,26,51,0.98), rgba(0,51,102,0.98));
        }
        .achievement-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            max-width: 400px;
            max-height: 60vh;
            overflow-y: auto;
            padding: 15px;
            margin: 10px 0;
        }
        .achievement-card {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 12px;
            padding: 12px;
            text-align: center;
            transition: all 0.3s ease;
        }
        .achievement-card.unlocked {
            background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,165,0,0.1));
            border-color: rgba(255,215,0,0.5);
            box-shadow: 0 0 15px rgba(255,215,0,0.2);
        }
        .achievement-card.locked {
            opacity: 0.5;
            filter: grayscale(0.5);
        }
        .achievement-icon {
            font-size: 32px;
            margin-bottom: 6px;
        }
        .achievement-name {
            color: #fff;
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 4px;
        }
        .achievement-desc {
            color: rgba(255,255,255,0.6);
            font-size: 11px;
            line-height: 1.3;
        }
        .achievement-card.unlocked .achievement-name {
            color: #ffd700;
        }
        /* æˆå°±è§£é”å¼¹çª— */
        .achievement-popup {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%) translateY(-20px);
            background: linear-gradient(135deg, rgba(255,215,0,0.9), rgba(255,165,0,0.9));
            border-radius: 12px;
            padding: 12px 20px;
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 8px 30px rgba(255,215,0,0.4);
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: all 0.4s ease;
        }
        .achievement-popup.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
        .achievement-popup .popup-icon {
            font-size: 36px;
        }
        .achievement-popup .popup-text {
            text-align: left;
        }
        .achievement-popup .popup-title {
            color: #333;
            font-size: 12px;
            font-weight: 600;
        }
        .achievement-popup .popup-name {
            color: #1a1a1a;
            font-size: 16px;
            font-weight: 700;
        }
        .achievement-progress {
            color: rgba(255,255,255,0.5);
            font-size: 14px;
            margin-top: 10px;
        }
        
        /* ç”Ÿå‘½æ˜¾ç¤º */
        .lives-display {
            position: absolute;
            top: 22px;
            right: 65px;
            font-size: 22px;
            z-index: 5;
            pointer-events: none;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        /* é¦–é¡µå³ä¸Šè§’å›¾æ ‡æŒ‰é’® */
        .top-right-buttons {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 12px;
            z-index: 2;
        }
        .icon-btn {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.3);
            background: rgba(0,0,0,0.3);
            backdrop-filter: blur(6px);
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .icon-btn:hover {
            transform: scale(1.1);
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.5);
        }
        .icon-btn:active {
            transform: scale(0.95);
        }
        .close-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.3);
            background: rgba(0,0,0,0.3);
            color: #fff;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 11;
        }
        .close-btn:hover {
            background: rgba(255,100,100,0.3);
            border-color: rgba(255,100,100,0.6);
        }
        
        /* æš‚åœæŒ‰é’® */
        .pause-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.3);
            background: rgba(0,0,0,0.3);
            color: #fff;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 10;
        }
        .pause-btn:hover {
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.5);
        }
        
        /* æš‚åœç•Œé¢ */
        #pauseScreen {
            background: rgba(0,20,40,0.95);
        }
        .pause-title {
            font-size: 28px;
            color: #fff;
            font-weight: 700;
            margin-bottom: 30px;
        }
        .pause-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .pause-btn-action {
            padding: 16px 50px;
            border-radius: 30px;
            border: none;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .pause-btn-action.continue {
            background: linear-gradient(135deg, #ff69b4 0%, #ff1493 100%);
            color: #fff;
            box-shadow: 0 8px 25px rgba(255,105,180,0.4);
        }
        .pause-btn-action.continue:hover {
            transform: scale(1.05);
            box-shadow: 0 12px 35px rgba(255,105,180,0.5);
        }
        .pause-btn-action.quit {
            background: linear-gradient(135deg, #666 0%, #444 100%);
            color: #fff;
            box-shadow: 0 8px 20px rgba(0,0,0,0.3);
        }
        .pause-btn-action.quit:hover {
            transform: scale(1.05);
        }
        
        /* æ’è¡Œæ¦œæ ·å¼ */
        #leaderboardScreen {
            background: linear-gradient(180deg, rgba(0,26,51,0.98), rgba(0,51,102,0.98));
        }
        .leaderboard-list {
            width: min(90vw, 350px);
            max-height: 50vh;
            overflow-y: auto;
            margin: 15px 0;
        }
        .leaderboard-item {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            margin: 8px 0;
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .leaderboard-item.top1 {
            background: linear-gradient(135deg, rgba(255,215,0,0.2), rgba(255,165,0,0.1));
            border-color: rgba(255,215,0,0.5);
        }
        .leaderboard-item.top2 {
            background: linear-gradient(135deg, rgba(192,192,192,0.15), rgba(169,169,169,0.1));
            border-color: rgba(192,192,192,0.4);
        }
        .leaderboard-item.top3 {
            background: linear-gradient(135deg, rgba(205,127,50,0.15), rgba(184,115,51,0.1));
            border-color: rgba(205,127,50,0.4);
        }
        .leaderboard-rank {
            font-size: 20px;
            font-weight: 700;
            width: 40px;
            text-align: center;
        }
        .leaderboard-rank.gold { color: #ffd700; }
        .leaderboard-rank.silver { color: #c0c0c0; }
        .leaderboard-rank.bronze { color: #cd7f32; }
        .leaderboard-score {
            flex: 1;
            text-align: right;
            font-size: 22px;
            font-weight: 600;
            color: #fff;
        }
        .leaderboard-date {
            font-size: 11px;
            color: rgba(255,255,255,0.5);
            margin-left: 12px;
            min-width: 70px;
            text-align: right;
        }
        .leaderboard-empty {
            color: rgba(255,255,255,0.5);
            font-size: 14px;
            padding: 30px;
            text-align: center;
        }
        
        /* æ¨ªå±æ—‹è½¬æç¤º - å¹³æ¿é€‚é… */
        #rotateWarning {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #001a33 0%, #003366 50%, #004080 100%);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        .rotate-icon {
            font-size: 80px;
            margin-bottom: 20px;
            animation: rotate-phone 2s ease-in-out infinite;
        }
        @keyframes rotate-phone {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-30deg); }
            75% { transform: rotate(30deg); }
        }
        .rotate-text {
            color: #fff;
            font-size: 24px;
            font-weight: 600;
            text-align: center;
            margin-bottom: 10px;
        }
        .rotate-hint {
            color: rgba(255,255,255,0.6);
            font-size: 16px;
            text-align: center;
        }
        /* åªåœ¨è§¦å±è®¾å¤‡æ¨ªå±æ—¶æ˜¾ç¤ºæ—‹è½¬æç¤º */
        @media (pointer: coarse) and (orientation: landscape) and (min-width: 600px) {
            #rotateWarning {
                display: flex;
            }
            .game-container {
                display: none;
            }
        }
        
        /* å…³å¡ç»“ç®—ç•Œé¢æ ·å¼ */
        #stageClearScreen {
            background: linear-gradient(180deg, rgba(0,26,51,0.98), rgba(0,51,102,0.98));
        }
        .stage-clear-title {
            font-size: 36px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 4px 20px rgba(255,215,0,0.5);
            margin-bottom: 10px;
        }
        .stage-rank {
            font-size: 80px;
            margin: 15px 0;
            animation: rank-bounce 0.6s ease-out;
        }
        @keyframes rank-bounce {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); opacity: 1; }
        }
        .stage-rank.rank-s { color: #ffd700; text-shadow: 0 0 30px rgba(255,215,0,0.8); }
        .stage-rank.rank-a { color: #ff69b4; text-shadow: 0 0 25px rgba(255,105,180,0.7); }
        .stage-rank.rank-b { color: #74b9ff; text-shadow: 0 0 20px rgba(116,185,255,0.6); }
        .stage-rank.rank-c { color: #a29bfe; text-shadow: 0 0 15px rgba(162,155,254,0.5); }
        .stage-stats {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin: 15px 0;
            padding: 15px 25px;
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .stage-stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 16px;
        }
        .stage-stat-label {
            color: rgba(255,255,255,0.7);
        }
        .stage-stat-value {
            color: #fff;
            font-weight: bold;
        }
        .stage-stat-value.highlight {
            color: #ffd700;
        }
        .stage-new-record {
            color: #ff69b4;
            font-size: 14px;
            animation: pulse 1s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .rank-badge {
            display: inline-block;
            width: 24px;
            height: 24px;
            line-height: 24px;
            text-align: center;
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
        }
        .rank-badge.rank-s { background: linear-gradient(135deg, #ffd700, #ffaa00); color: #000; }
        .rank-badge.rank-a { background: linear-gradient(135deg, #ff69b4, #ff1493); color: #fff; }
        .rank-badge.rank-b { background: linear-gradient(135deg, #74b9ff, #0984e3); color: #fff; }
        .rank-badge.rank-c { background: linear-gradient(135deg, #a29bfe, #6c5ce7); color: #fff; }
    </style>
    <script src="static/bg-base64.js"></script>
</head>
<body>
    <!-- æ¨ªå±æ—‹è½¬æç¤º -->
    <div id="rotateWarning">
        <div class="rotate-icon">ğŸ“±</div>
        <div class="rotate-text">è¯·æ—‹è½¬è®¾å¤‡</div>
        <div class="rotate-hint">ç«–å±æ¸¸æˆä½“éªŒæ›´ä½³</div>
    </div>
    
    <div class="game-container">
        <canvas id="gameCanvas" width="480" height="640"></canvas>
        
        <div class="game-hud">
            <div class="hud-score" id="scoreDisplay">0</div>
        </div>
        
        <div class="powerup-status" id="powerupStatus"></div>
        <div class="lives-display" id="livesDisplay"></div>
        <div class="wave-display" id="waveDisplay"></div>
        
        <!-- Bossè¡€æ¡ -->
        <div class="boss-hp-container" id="bossHpContainer">
            <div class="boss-name" id="bossName">Bossåç§°</div>
            <div class="boss-hp-bar-outer">
                <div class="boss-hp-bar-inner" id="bossHpBar" style="width: 100%;"></div>
            </div>
            <div class="boss-phase-dots" id="bossPhaseDots"></div>
        </div>
        
        <!-- å¼€å§‹ç•Œé¢ -->
        <div class="overlay" id="startScreen">
            <canvas id="homepageCanvas"></canvas>
            <div style="font-size: 60px; margin-bottom: 6px; text-shadow:0 10px 30px rgba(255,105,180,.5); z-index: 1;">ğŸ’–</div>
            <div class="game-title" style="z-index: 1;">çˆ±çš„å®ˆæŠ¤è€…</div>
            <div class="game-subtitle" style="z-index: 1;">LOVE GUARDIAN</div>
            <div class="start-quote" id="startQuote" style="z-index: 1;">æ­£åœ¨åŠ è½½çˆ±çš„èª“è¨€...</div>
            <div class="top-right-buttons">
                <button class="icon-btn" onclick="showAchievements()" title="æˆå°±">ğŸ†</button>
                <button class="icon-btn" onclick="showLeaderboard()" title="æ’è¡Œæ¦œ">ğŸ“Š</button>
            </div>
            <div class="menu-buttons" style="margin: 24px 0;">
                <button class="menu-btn" onclick="showStageSelect()">ğŸ¯ é—¯å…³æ¨¡å¼</button>
                <button class="menu-btn secondary" onclick="startGame('endless')">â™¾ï¸ æ— å°½æ¨¡å¼</button>
            </div>
            <div class="start-desc">
                ğŸŸ è§¦æ‘¸å±å¹•æ§åˆ¶å°é±¼ Â· ğŸ’§ è‡ªåŠ¨å‘å°„æ°”æ³¡ Â· âœ¨ æ”¶é›†é“å…·å¢å¼ºç«åŠ›
            </div>
        </div>
        
        <!-- å…³å¡é€‰æ‹©ç•Œé¢ -->
        <div class="overlay hidden" id="stageSelectScreen">
            <div style="font-size: 40px; margin-bottom: 10px;">ğŸ®</div>
            <div class="game-title" style="font-size: 32px; margin-bottom: 5px;">é€‰æ‹©å…³å¡</div>
            <div style="color: rgba(255,255,255,0.5); font-size: 13px; margin-bottom: 15px;">é€šå…³å‰ä¸€å…³è§£é”ä¸‹ä¸€å…³</div>
            <div id="stageGrid" style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 12px; margin: 15px; max-width: 320px;"></div>
            <button class="btn" onclick="hideStageSelect()" style="background: linear-gradient(135deg, #666 0%, #444 100%); padding: 12px 40px; font-size: 16px; margin-top: 10px;">ğŸ”™ è¿”å›</button>
        </div>
        
        <!-- æ¸¸æˆç»“æŸç•Œé¢ -->
        <div class="overlay hidden" id="gameOverScreen">
            <div class="game-over-title" id="gameOverTitle">ğŸ’” çˆ±æƒ…ç ´ç¢äº†</div>
            <div class="final-score">å¾—åˆ†: <span id="finalScore">0</span></div>
            <div id="stageInfo" style="color: #ff69b4; font-size: 18px; margin: 10px 0;"></div>
            <button class="btn btn-restart" onclick="restartGame()">ğŸ’• å†æ¬¡å®ˆæŠ¤</button>
            <button class="btn" onclick="backToMenu()" style="background: linear-gradient(135deg, #666 0%, #444 100%); box-shadow: 0 10px 30px rgba(0,0,0,0.3);">ğŸ  è¿”å›èœå•</button>
        </div>
        
        <!-- æˆå°±ç•Œé¢ -->
        <div class="overlay hidden" id="achievementScreen">
            <button class="close-btn" onclick="hideAchievements()">Ã—</button>
            <div style="font-size: 50px; margin-bottom: 10px;">ğŸ†</div>
            <div class="game-title" style="font-size: 32px; margin-bottom: 5px;">æˆå°±</div>
            <div class="achievement-progress" id="achievementProgress">0 / 0</div>
            <div class="achievement-grid" id="achievementGrid"></div>
        </div>
        
        <!-- æˆå°±è§£é”å¼¹çª— -->
        <div class="achievement-popup" id="achievementPopup">
            <div class="popup-icon" id="popupIcon">ğŸ†</div>
            <div class="popup-text">
                <div class="popup-title">æˆå°±è§£é”!</div>
                <div class="popup-name" id="popupName">æˆå°±åç§°</div>
            </div>
        </div>
        
        <!-- æ’è¡Œæ¦œç•Œé¢ -->
        <div class="overlay hidden" id="leaderboardScreen">
            <button class="close-btn" onclick="hideLeaderboard()">Ã—</button>
            <div style="font-size: 50px; margin-bottom: 10px;">ğŸ“Š</div>
            <div class="game-title" style="font-size: 32px; margin-bottom: 5px;">æ— å°½æ¨¡å¼æ’è¡Œæ¦œ</div>
            <div style="color: rgba(255,255,255,0.5); font-size: 13px;">TOP 10 æœ€é«˜åˆ†</div>
            <div class="leaderboard-list" id="leaderboardList"></div>
        </div>
        
        <!-- é€šå…³ç•Œé¢ -->
        <div class="overlay hidden" id="winScreen">
            <div class="game-over-title" style="color: #ffd700;">ğŸ‰ æ­å–œé€šå…³! ğŸ‰</div>
            <div class="final-score">æœ€ç»ˆå¾—åˆ†: <span id="winScore">0</span></div>
            <div style="color: #ff69b4; font-size: 20px; margin: 15px 0;">ä½ æˆåŠŸå®ˆæŠ¤äº†çˆ±æƒ…!</div>
            <button class="btn btn-restart" onclick="restartGame()">ğŸ’• å†ç©ä¸€æ¬¡</button>
            <button class="btn" onclick="backToMenu()" style="background: linear-gradient(135deg, #666 0%, #444 100%);">ğŸ  è¿”å›èœå•</button>
        </div>
        
        <!-- å…³å¡ç»“ç®—ç•Œé¢ -->
        <div class="overlay hidden" id="stageClearScreen">
            <div class="stage-clear-title">âœ¨ ç¬¬ <span id="clearStageNum">1</span> å…³ é€šå…³! âœ¨</div>
            <div class="stage-rank rank-s" id="stageRank">S</div>
            <div class="stage-stats">
                <div class="stage-stat-row">
                    <span class="stage-stat-label">ğŸ¯ å¾—åˆ†</span>
                    <span class="stage-stat-value" id="clearScore">0</span>
                </div>
                <div class="stage-stat-row">
                    <span class="stage-stat-label">â±ï¸ ç”¨æ—¶</span>
                    <span class="stage-stat-value" id="clearTime">0:00</span>
                </div>
                <div class="stage-stat-row">
                    <span class="stage-stat-label">ğŸ”¥ æœ€é«˜è¿å‡»</span>
                    <span class="stage-stat-value" id="clearCombo">0</span>
                </div>
                <div class="stage-stat-row" id="newRecordRow" style="display: none;">
                    <span class="stage-new-record">ğŸŒŸ æ–°çºªå½•!</span>
                    <span class="stage-stat-value highlight" id="oldRecord">0</span>
                </div>
            </div>
            <button class="btn btn-restart" onclick="continueToNextStage()">â¡ï¸ ä¸‹ä¸€å…³</button>
            <button class="btn" onclick="backToMenu()" style="background: linear-gradient(135deg, #666 0%, #444 100%);">ğŸ  è¿”å›èœå•</button>
        </div>
        
        <!-- æš‚åœç•Œé¢ -->
        <div class="overlay hidden" id="pauseScreen">
            <div style="font-size: 60px; margin-bottom: 15px;">â¸ï¸</div>
            <div class="pause-title">æ¸¸æˆæš‚åœ</div>
            <div class="pause-buttons">
                <button class="pause-btn-action continue" onclick="resumeGame()">ğŸ’– ç»§ç»­çˆ±</button>
                <button class="pause-btn-action quit" onclick="quitGame()">ğŸ’¤ ä¼‘æ¯ä¸€ä¸‹</button>
            </div>
        </div>
        
        <!-- æš‚åœæŒ‰é’® -->
        <button class="pause-btn hidden" id="pauseBtn" onclick="pauseGame()">âšâš</button>
        
    </div>

    <script>
        // Canvas
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // ä¸ä½¿ç”¨å¤–éƒ¨å›¾ç‰‡ï¼Œå…¨éƒ¨ä½¿ç”¨çŸ¢é‡ç»˜åˆ¶é±¼ç±»
        
        // åŠ è½½èƒŒæ™¯å›¾
        let bgImage = new Image();
        let bgImageReady = false;
        if (typeof BG_IMAGE_BASE64 !== 'undefined') {
            bgImage.onload = function() {
                bgImageReady = true;
            };
            bgImage.src = BG_IMAGE_BASE64;
        }
        
        // æ¸¸æˆé…ç½®
        const CONFIG = {
            CANVAS_WIDTH: window.innerWidth,
            CANVAS_HEIGHT: window.innerHeight,
            PLAYER_SPEED: 8,
            BULLET_SPEED: 12,
            ENEMY_BASE_SPEED: 3,
            STAR_COUNT: 150,
            // === æ–¹æ¡ˆAï¼šé“å…·æŒç»­æ—¶é•¿ï¼ˆå¸§ @60fpsï¼‰===
            POWERUP_DURATION: 600,      // æ­¦å™¨é“å…·æŒç»­10ç§’
            SHIELD_DURATION: 360,       // æŠ¤ç›¾æŒç»­6ç§’
            DRONE_DURATION: 720,        // èªä»”é±¼æŒç»­12ç§’
            // === é“å…·æ‰è½ç‡ ===
            POWERUP_DROP_RATE: 0.20,    // 20%æ‰è½å‡ ç‡
            // === å°é±¼å°„é€Ÿ ===
            DRONE_FIRE_COOLDOWN: 14,    // å°é±¼å¼€ç«é—´éš”ï¼ˆå¸§ï¼‰
            
            // === Bosså‡ºç°èŠ‚å¥é…ç½® ===
            // å…³å¡æ¨¡å¼ï¼šè‡³å°‘å‡»è´¥å¤šå°‘æ•Œäººåæ‰å¯å‡ºç°Bossï¼ˆåŸºç¡€+æŒ‰å…³å¡é€’å¢ï¼‰
            STAGE_BOSS_BASE: 24,
            STAGE_BOSS_PER_STAGE: 6,
            // å…³å¡æ¨¡å¼ï¼šæ¯å…³Bossæœ€æ—©å‡ºç°æ—¶é—´ï¼ˆå¸§ï¼Œ60fpsï¼‰
            BOSS_MIN_TIME_STAGE: 30 * 60,   // 30ç§’
            
            // æ— å°½æ¨¡å¼ï¼šé¦–æ¬¡Bossåˆ†æ•°é˜ˆå€¼ä¸åç»­å¢é‡
            ENDLESS_FIRST_BOSS_SCORE: 800,
            ENDLESS_NEXT_BOSS_ADD: 1000,
            // æ— å°½æ¨¡å¼ï¼šç›¸é‚»ä¸¤æ¬¡Bossä¹‹é—´è‡³å°‘é—´éš”çš„æ—¶é—´ï¼ˆå¸§ï¼‰
            BOSS_MIN_TIME_ENDLESS: 35 * 60,   // 35ç§’
            
            // æ— å°½æ¨¡å¼ç”Ÿå‘½æ•°
            ENDLESS_LIVES: 3,
            // å—å‡»åæ— æ•Œæ—¶é—´ï¼ˆå¸§ï¼‰
            RESPAWN_INVINCIBLE: 120,   // 2ç§’
            // å½©è›‹ Bosså¼ºåŒ–æŒç»­æ—¶é—´ï¼ˆå¸§ï¼‰
            SECRET_BUFF_DURATION: 1800,  // 30ç§’
            // é»‘æ´é…ç½®
            BLACKHOLE_DURATION: 420,     // é»‘æ´æŒç»­7ç§’
            BLACKHOLE_RADIUS: 350,       // é»‘æ´å¸å¼•åŠå¾„ï¼ˆè¦†ç›–é¡¶éƒ¨å¤§èŒƒå›´ï¼‰
            BLACKHOLE_PULL_FORCE: 5      // å¸å¼•åŠ›åº¦
        };
        
        // === æ­¦å™¨å†·å´/å‘æ•°/é—´è·é…ç½® ===
        const WEAPON_CONFIG = {
            rapid:  { cd: [18, 14, 10],  desc: 'å¿«é€Ÿå•å‘' },
            double: { cd: [28, 24, 20],  offset: [12, 12, 18], extraBullet: [false, true, true], desc: 'åŒ/ä¸‰å‘' },
            triple: { cd: [32, 28, 24],  lines: [3, 5, 7], gap: 12, desc: 'å¤šçº¿' },
            spread: { cd: [35, 30, 25],  angles: [[-3,0,3], [-3,-1.5,0,1.5,3], [-4,-2.5,-1,0,1,2.5,4]], desc: 'æ‰‡å½¢' },
            laser:  { cd: [20, 16, 12],  width: [6, 10, 14], desc: 'æ¿€å…‰' },
            none:   { cd: [35], desc: 'æ™®é€š' }
        };
        
        // === æ•ŒæœºåŸºç¡€å°„å‡»ç‡ï¼ˆæ¯å¸§æ¦‚ç‡ï¼‰===
        const ENEMY_SHOOT_BASE = {
            fast: 0.004,      // å¿«é€Ÿé±¼ - åŒå‘å¿«é€Ÿ
            tank: 0.006,      // å¦å…‹é±¼ - å•å‘å¤§å¼¹
            sniper: 0.008,    // ç‹™å‡»é±¼ - ç²¾å‡†è¿½è¸ª
            splitter: 0.005,  // åˆ†è£‚é±¼ - ä¸‰å‘æ‰©æ•£
            mini: 0.003,      // è¿·ä½ é±¼ - å¾®å°å­å¼¹
            normal: 0.005,    // æ™®é€šé±¼ - æ ‡å‡†å­å¼¹
            bomber: 0.004,    // è½°ç‚¸é±¼ - æŠ•å¼¹
            shield: 0.005,    // æŠ¤ç›¾é±¼ - æœ‰æŠ¤ç›¾ä¿æŠ¤
            healer: 0.003,    // æ²»æ„ˆé±¼ - æ²»æ„ˆå‘¨å›´æ•Œäºº
            swarm: 0.004      // èœ‚ç¾¤é±¼ - æˆç¾¤å‡ºç°
        };
        // æ•Œæœºå°„é€Ÿéšå…³å¡é€’å¢çš„æœ€å¤§å€ç‡
        const ENEMY_SHOOT_MAX_MULT = 0.5;
        
        // === å¯¹è±¡æ± ç³»ç»Ÿï¼ˆå‡å°‘GCå‹åŠ›ï¼‰===
        const ObjectPool = {
            bullets: [],
            particles: [],
            enemies: [],
            powerUps: [],
            maxBullets: 300,
            maxParticles: 600,
            maxEnemies: 50,
            maxPowerUps: 30,
            
            getBullet() {
                if (this.bullets.length > 0) {
                    const b = this.bullets.pop();
                    b.active = true;
                    return b;
                }
                return { x: 0, y: 0, vx: 0, vy: 0, type: 'player', bulletStyle: null, bossColor: null, wave: false, waveOffset: 0, isBomb: false, bombTimer: 0, isLaser: false, laserWidth: 0, active: true };
            },
            
            releaseBullet(bullet) {
                if (this.bullets.length < this.maxBullets) {
                    bullet.active = false;
                    // é‡ç½®å…³é”®å­—æ®µ
                    bullet.wave = false;
                    bullet.isBomb = false;
                    bullet.isLaser = false;
                    this.bullets.push(bullet);
                }
            },
            
            getParticle() {
                if (this.particles.length > 0) {
                    const p = this.particles.pop();
                    p.active = true;
                    return p;
                }
                return { x: 0, y: 0, vx: 0, vy: 0, alpha: 1, size: 2, color: '255,200,50', active: true };
            },
            
            releaseParticle(particle) {
                if (this.particles.length < this.maxParticles) {
                    particle.active = false;
                    this.particles.push(particle);
                }
            },
            
            getEnemy() {
                if (this.enemies.length > 0) {
                    const e = this.enemies.pop();
                    e.active = true;
                    return e;
                }
                return { active: true };
            },
            
            releaseEnemy(enemy) {
                if (this.enemies.length < this.maxEnemies) {
                    enemy.active = false;
                    this.enemies.push(enemy);
                }
            },
            
            getPowerUp() {
                if (this.powerUps.length > 0) {
                    const p = this.powerUps.pop();
                    p.active = true;
                    return p;
                }
                return { active: true };
            },
            
            releasePowerUp(powerUp) {
                if (this.powerUps.length < this.maxPowerUps) {
                    powerUp.active = false;
                    this.powerUps.push(powerUp);
                }
            }
        };
        
        // === æ¸å˜ç¼“å­˜ç³»ç»Ÿï¼ˆé¿å…æ¯å¸§é‡å»ºï¼‰===
        const GradientCache = {
            cache: {},
            
            // è·å–æˆ–åˆ›å»ºæ¸å˜
            get(key, createFn) {
                if (!this.cache[key]) {
                    this.cache[key] = createFn();
                }
                return this.cache[key];
            },
            
            // æ¸…é™¤ç¼“å­˜ï¼ˆçª—å£å°ºå¯¸å˜åŒ–æ—¶è°ƒç”¨ï¼‰
            clear() {
                this.cache = {};
            },
            
            // é¢„åˆ›å»ºå¸¸ç”¨æ¸å˜
            init(ctx) {
                // ç©å®¶å­å¼¹æ¸å˜
                this.cache['playerBullet'] = (() => {
                    const g = ctx.createRadialGradient(0, 0, 0, 0, 0, 8);
                    g.addColorStop(0, 'rgba(200, 240, 255, 0.9)');
                    g.addColorStop(0.5, 'rgba(100, 200, 255, 0.6)');
                    g.addColorStop(1, 'rgba(100, 200, 255, 0)');
                    return g;
                })();
                
                // ç©å®¶æ°´æŸ±æ”»å‡»æ¸å˜
                this.cache['playerLaser'] = (() => {
                    const g = ctx.createLinearGradient(0, -30, 0, 10);
                    g.addColorStop(0, 'rgba(100,200,255,0.9)');
                    g.addColorStop(1, 'rgba(50,150,255,0.7)');
                    return g;
                })();
                
                // å¦å…‹é±¼å­å¼¹æ¸å˜
                this.cache['tankBullet'] = (() => {
                    const g = ctx.createRadialGradient(0, 0, 0, 0, 0, 12);
                    g.addColorStop(0, '#ffeaa7');
                    g.addColorStop(0.5, '#fdcb6e');
                    g.addColorStop(1, '#e17055');
                    return g;
                })();
                
                // ç‹™å‡»é±¼å­å¼¹æ¸å˜
                this.cache['sniperBullet'] = (() => {
                    const g = ctx.createLinearGradient(0, -10, 0, 10);
                    g.addColorStop(0, '#00ff88');
                    g.addColorStop(0.5, '#00cc66');
                    g.addColorStop(1, '#009944');
                    return g;
                })();
                
                // åˆ†è£‚é±¼å­å¼¹æ¸å˜
                this.cache['splitterBullet'] = (() => {
                    const g = ctx.createRadialGradient(0, -2, 0, 0, 2, 8);
                    g.addColorStop(0, 'rgba(162, 155, 254, 0.9)');
                    g.addColorStop(0.5, 'rgba(108, 92, 231, 0.6)');
                    g.addColorStop(1, 'rgba(72, 52, 212, 0.3)');
                    return g;
                })();
                
                // è½°ç‚¸é±¼ç‚¸å¼¹æ¸å˜
                this.cache['bomberBullet'] = (() => {
                    const g = ctx.createRadialGradient(0, 0, 0, 0, 0, 10);
                    g.addColorStop(0, '#636e72');
                    g.addColorStop(0.7, '#2d3436');
                    g.addColorStop(1, '#1a1a1a');
                    return g;
                })();
                
                // æŠ¤ç›¾é±¼å­å¼¹æ¸å˜
                this.cache['shieldBullet'] = (() => {
                    const g = ctx.createRadialGradient(0, 0, 0, 0, 0, 7);
                    g.addColorStop(0, '#ffffff');
                    g.addColorStop(0.4, '#00d2ff');
                    g.addColorStop(1, '#0088ff');
                    return g;
                })();
                
                // æ²»æ„ˆè¿æ¥çº¿é¢œè‰²
                this.cache['healLineColor'] = 'rgba(46, 204, 113, 0.6)';
                this.cache['healLineColorDim'] = 'rgba(46, 204, 113, 0.25)';
            }
        };
        
        // è®¾ç½®canvaså®é™…å°ºå¯¸
        canvas.width = CONFIG.CANVAS_WIDTH;
        canvas.height = CONFIG.CANVAS_HEIGHT;
        
        // åˆå§‹åŒ–æ¸å˜ç¼“å­˜
        GradientCache.init(ctx);
        
        // === å­å¼¹åˆ›å»ºè¾…åŠ©å‡½æ•°ï¼ˆä½¿ç”¨å¯¹è±¡æ± ï¼‰===
        function createBullet(props) {
            const bullet = ObjectPool.getBullet();
            bullet.x = props.x || 0;
            bullet.y = props.y || 0;
            bullet.vx = props.vx || 0;
            bullet.vy = props.vy || 0;
            bullet.type = props.type || 'player';
            bullet.bulletStyle = props.bulletStyle || null;
            bullet.bossColor = props.bossColor || null;
            bullet.wave = props.wave || false;
            bullet.waveOffset = props.waveOffset || 0;
            bullet.isBomb = props.isBomb || false;
            bullet.bombTimer = props.bombTimer || 0;
            bullet.isLaser = props.isLaser || false;
            bullet.laserWidth = props.laserWidth || 0;
            bullet.active = true;
            bullets.push(bullet);
            return bullet;
        }
        
        // === ç¢°æ’æ£€æµ‹ä¼˜åŒ–ï¼šYè½´åˆ†åŒºè¿‡æ»¤ï¼ˆä½¿ç”¨å¤ç”¨æ•°ç»„ï¼‰===
        const tmpEnemiesInRange = [];
        function getEnemiesInRange(yMin, yMax) {
            if (enemies.length <= 8) return enemies;
            tmpEnemiesInRange.length = 0;
            for (let i = 0; i < enemies.length; i++) {
                const e = enemies[i];
                if (e.y >= yMin - 60 && e.y <= yMax + 60) {
                    tmpEnemiesInRange.push(e);
                }
            }
            return tmpEnemiesInRange;
        }

        // æ¸¸æˆçŠ¶æ€å·¥å‚å‡½æ•°
        function createGameState(mode = 'endless') {
            return {
                score: 0,
                wave: 1,
                combo: 0,
                maxCombo: 0,
                isRunning: false,
                isPaused: false,
                powerUpType: 'none',
                powerUpTime: 0,
                isInvincible: false,
                invincibleTime: 0,
                powerUpLevel: 0,
                droneActive: false,
                droneTime: 0,
                nextBossScore: CONFIG.ENDLESS_FIRST_BOSS_SCORE,
                bossActive: false,
                gameMode: mode,
                currentStage: 1,
                maxStage: 20,
                endlessBossCount: 0,
                stageEnemyCount: 0,
                stageBossSpawned: false,
                elapsedFrames: 0,
                lastBossEndFrame: -99999,
                lives: CONFIG.ENDLESS_LIVES, // æ‰€æœ‰æ¨¡å¼éƒ½æœ‰3æ¡å‘½
                secretBuff: false,
                secretBuffTime: 0
            };
        }
        
        let gameState = createGameState();

        // æ¸¸æˆå¯¹è±¡
        let player, bullets, enemies, powerUps, explosions, stars, drones, blackholes;

        // æŒ‰é”®çŠ¶æ€
        const keys = {};

        // åˆå§‹åŒ–æ°”æ³¡èƒŒæ™¯ï¼ˆæµ·åº•é£æ ¼ï¼‰
        function initStars() {
            stars = [];
            for (let i = 0; i < CONFIG.STAR_COUNT; i++) {
                stars.push({
                    x: Math.random() * CONFIG.CANVAS_WIDTH,
                    y: Math.random() * CONFIG.CANVAS_HEIGHT,
                    size: Math.random() * 4 + 2,
                    speed: Math.random() * 1.5 + 0.5,
                    brightness: Math.random(),
                    wobble: Math.random() * Math.PI * 2
                });
            }
        }

        // åˆå§‹åŒ–ç©å®¶
        function initPlayer() {
            player = {
                x: CONFIG.CANVAS_WIDTH / 2,
                y: CONFIG.CANVAS_HEIGHT - 80,
                width: 50,
                height: 50,
                speed: CONFIG.PLAYER_SPEED,
                shootCooldown: 0,
                invincible: 0,
                trail: []
            };
        }

        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame(mode = 'endless') {
            gameState = createGameState(mode);
            initStars();
            initPlayer();
            bullets = [];
            enemies = [];
            powerUps = [];
            explosions = [];
            drones = [];
            blackholes = [];
            
            // ç«‹å³ç”Ÿæˆåˆå§‹æ•Œäººï¼Œé¿å…å¼€å±€ç©ºç™½
            const initialEnemyCount = mode === 'stage' ? 4 : 3;
            for (let i = 0; i < initialEnemyCount; i++) {
                spawnEnemy();
            }
            
            updateUI();
        }

        // å¼€å§‹æ¸¸æˆ
        function startGame(mode = 'endless') {
            document.getElementById('startScreen').classList.add('hidden');
            stopHomepageAnimation(); // åœæ­¢é¦–é¡µåŠ¨ç”»
            initGame(mode);
            gameState.isRunning = true;
            
            // æ˜¾ç¤ºæš‚åœæŒ‰é’®
            document.getElementById('pauseBtn').classList.remove('hidden');
            
            if (mode === 'stage') {
                showStage();
            } else {
                showWave();
            }
            gameLoop();
        }

        // é‡æ–°å¼€å§‹
        function restartGame() {
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('winScreen').classList.add('hidden');
            document.getElementById('stageClearScreen').classList.add('hidden');
            
            if (gameState.gameMode === 'stage') {
                // ä»å¤±è´¥çš„å…³å¡ç»§ç»­ï¼šå¤ç”¨ startGame('stage') ä»¥ç»Ÿä¸€å¤„ç†æ‰€æœ‰UIï¼ˆå«æš‚åœæŒ‰é’®æ˜¾ç¤ºï¼‰
                const resume = parseInt(localStorage.getItem('resumeStage') || `${gameState.currentStage || 1}`);
                startGame('stage');
                gameState.currentStage = Math.max(1, Math.min(resume, gameState.maxStage));
                showStage();
            } else {
                startGame('endless');
            }
        }
        
        // è¿”å›èœå•
        function backToMenu() {
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('winScreen').classList.add('hidden');
            document.getElementById('pauseScreen').classList.add('hidden');
            document.getElementById('stageClearScreen').classList.add('hidden');
            document.getElementById('pauseBtn').classList.add('hidden');
            document.getElementById('startScreen').classList.remove('hidden');
            hideBossHpBar(); // éšè—Bossè¡€æ¡
            initHomepageAnimation(); // é‡æ–°å¯åŠ¨é¦–é¡µåŠ¨ç”»
            showRandomQuote(); // æ˜¾ç¤ºéšæœºæ–‡æ¡ˆ
        }
        
        // === é¦–é¡µéšæœºæ–‡æ¡ˆ ===
        const START_QUOTES = [
            // === â¤ï¸ æ·±æƒ…å‘Šç™½ç¯‡ ===
            "æ·±æµ·ä¹‹ä¸­ï¼Œä½ æ˜¯æˆ‘å”¯ä¸€çš„å…‰ã€‚<br>ä¸ºä½ ï¼Œæˆ‘æ„¿åœ¨æ³¢æ¶›ä¸­é€†æµè€Œä¸Šã€‚",
            "åœ¨è¿™ç‰‡æµ·åŸŸï¼Œæˆ‘ä¸æ˜¯æœ€å¼ºå¤§çš„ã€‚<br>ä½†å®ˆæŠ¤ä½ çš„å†³å¿ƒï¼Œæ¯”æµ·æ´‹è¿˜è¦æ·±ã€‚",
            "æ¯ä¸€ä¸ªæ°”æ³¡ï¼Œéƒ½æ˜¯æˆ‘å¯¹ä½ çš„å‘Šç™½ã€‚<br>çœ‹å®ƒä»¬å‡åˆ°æµ·é¢ï¼ŒåŒ–ä½œæ»¡å¤©ç¹æ˜Ÿã€‚",
            "ä½ è¯´æµ·å¾ˆå¯æ€•ï¼Œå……æ»¡æœªçŸ¥çš„å±é™©ã€‚<br>æ²¡å…³ç³»ï¼Œæœ‰æˆ‘åœ¨å‰é¢ä¸ºä½ å¼€è·¯ã€‚",
            "å“ªæ€•æ•´ç‰‡æµ·æ´‹éƒ½æˆä¸ºæ•Œäººï¼Œ<br>æˆ‘ä¹Ÿä¼šä¸ºä½ å‡»ç©¿æ¯ä¸€é“æ³¢æµªã€‚",
            "å°é±¼è™½å°ï¼Œå´æœ‰å¤§å¤§çš„å‹‡æ°”ã€‚<br>å› ä¸ºè¦å®ˆæŠ¤çš„äººï¼Œå°±åœ¨èº«åã€‚",
            "æˆ‘ä»¬å¯èƒ½åªæ˜¯æµ·é‡Œçš„å°é±¼ï¼Œ<br>ä½†æˆ‘ä»¬çš„çˆ±ï¼Œè¶³ä»¥å¡«æ»¡æ•´ç‰‡æµ·æ´‹ã€‚",
            "æ¯æ¬¡[å†æ¥ä¸€æ¬¡]ï¼Œ<br>éƒ½æ˜¯ä¸ºäº†å†ä¸€æ¬¡ä¸ä½ ç›¸é‡ã€‚",
            
            // === ğŸŒŠ ç”Ÿå­˜å“²å­¦ç¯‡ ===
            "ç”Ÿæ´»å°±åƒæµ·åº•çš„æ´‹æµï¼Œ<br>æœ‰æ—¶é¡ºé£ï¼Œæœ‰æ—¶é€†æµã€‚åšæŒä¸‹å»ï¼Œå°±èƒ½çœ‹åˆ°æ›™å…‰ã€‚",
            "æ¯ä¸€ä¸ªæ•Œäººéƒ½æ˜¯æˆé•¿çš„è¸è„šçŸ³ï¼Œ<br>æ‰“è´¥å®ƒä»¬ï¼Œä½ ä¼šå˜å¾—æ›´å¼ºå¤§ã€‚",
            "ä¸è¦å®³æ€•é‚£äº›Bossï¼Œ<br>å†å¼ºå¤§çš„æ•Œäººï¼Œä¹Ÿæœ‰è½¯è‚‹ã€‚æ‰¾åˆ°å®ƒï¼Œå‡»è´¥å®ƒï¼",
            "å¤±è´¥ä¸å¯æ€•ï¼Œå¯æ€•çš„æ˜¯ä¸æ•¢å†è¯•ã€‚<br>æ¯ä¸€æ¬¡è·Œå€’ï¼Œéƒ½æ˜¯ä¸ºäº†æ›´å¥½çš„èµ·é£ã€‚",
            "çœŸæ­£çš„å®ˆæŠ¤ï¼Œä¸æ˜¯è®©ä½ èº²åœ¨æ¸©å®¤ï¼Œ<br>è€Œæ˜¯é™ªä½ ä»æµ…æµ·æ¸¸å‘æ·±æ¸Šã€‚",
            "æµ·åº•çš„é»‘æš—ä¸å¯æ€•ï¼Œ<br>å› ä¸ºå¿ƒä¸­æœ‰å…‰ï¼Œè·¯å°±ä¸ä¼šè¿·ã€‚",
            "æœ‰äº›è·¯åªèƒ½ä¸€ä¸ªäººæ¸¸ï¼Œ<br>ä½†åœ¨å¿ƒé‡Œï¼Œæˆ‘ä»¬ä»æœªåˆ†å¼€ã€‚",
            "å“ªæ€•åœ¨[å›°éš¾æ¨¡å¼]é‡ŒæŒ£æ‰ï¼Œ<br>ä¹Ÿè¦ç›¸ä¿¡å…‰å°±åœ¨å‰æ–¹ã€‚",
            
            // === ğŸ® æ¸¸æˆæ”»ç•¥ç¯‡ ===
            "æ”¶é›†å„ç§æ­¦å™¨é“å…·ï¼Œæå‡ä½ çš„ç«åŠ›ï¼<br>âœ¨åŒå‘ ğŸ”±ä¸‰å‘ ğŸŒŸæ•£å°„ å…¨ç­‰ä½ æ¥è§£é”ï¼",
            "â€œğŸ›¡ï¸æ— æ•ŒæŠ¤ç›¾â€æ˜¯å…³é”®æ—¶åˆ»çš„æ•‘å‘½ç¨»è‰ï¼<br>å½“å®ƒå‡ºç°æ—¶ï¼Œä¸€å®šè¦æŠ“ä½ï¼",
            "æƒ³è¦é¢å¤–çš„ç«åŠ›æ”¯æ´å—ï¼Ÿ<br>ğŸ›°ï¸ èªä»”æœºä¼šæˆä¸ºä½ çš„å¾—åŠ›åŠ©æ‰‹ï¼",
            "ç­–ç•¥æç¤ºï¼šèµ°ä½è¦çµæ´»ï¼Œ<br>è¾¹è¾“å‡ºè¾¹èº²é¿ï¼Œæ‰èƒ½æ´»å¾—æ›´ä¹…ï¼",
            "åŒç±»æ­¦å™¨å åŠ å¯ä»¥å‡çº§ï¼<br>æœ€é«˜ä¸‰çº§ï¼Œç«åŠ›ç¿»å€ï¼è¯•è¯•çœ‹å§ï¼",
            "æ— å°½æ¨¡å¼æœ‰ä¸‰æ¡å‘½ï¼Œ<br>åƒåˆ°â¤ï¸çˆ±å¿ƒå¯ä»¥æ¢å¤ç”Ÿå‘½å“¦ï¼",
            "ğŸŒ€é»‘æ´é“å…·æ˜¯æç¨€æœ‰çš„ç¥å™¨ï¼<br>å®ƒèƒ½æŠŠæ•Œäººå…¨éƒ¨å¸è¿›å»ï¼",
            "è®°ä½ï¼šBosså¾ˆå¼ºï¼Œä½†ä¸æ˜¯æ— æ•Œçš„ã€‚<br>è§‚å¯Ÿå®ƒçš„å¼¹é“ï¼Œæ‰¾å‡ºç©ºéš™ï¼",
            
            // === ğŸ’ çˆ±æƒ…ç¯‡ ===
            "çˆ±æƒ…å°±åƒæµ·åº•çš„çç ï¼Œ<br>è¦ç”¨å¿ƒå¯»æ‰¾ï¼Œç”¨å¿ƒå®ˆæŠ¤ã€‚",
            "çœŸæ­£çš„çˆ±ï¼Œä¸æ˜¯æ²¡æœ‰é£æµªï¼Œ<br>è€Œæ˜¯åœ¨é£æµªä¸­ç´§ç´§ç›¸ä¾ã€‚",
            "ä¸ºäº†ä½ ï¼Œæˆ‘æ„¿æ„å˜æˆè¿™ç‰‡æµ·åŸŸæœ€å‹‡æ•¢çš„é±¼ã€‚<br>å†²ç ´ä¸€åˆ‡ï¼Œåªä¸ºè§ä½ ä¸€é¢ã€‚",
            "æˆ‘ä¸éœ€è¦æ•´ç‰‡æµ·æ´‹ï¼Œ<br>æœ‰ä½ åœ¨çš„åœ°æ–¹ï¼Œå°±æ˜¯æˆ‘çš„å…¨ä¸–ç•Œã€‚",
            "å…¶å®æœ€éš¾æ‰“è´¥çš„ä¸æ˜¯Bossï¼Œ<br>è€Œæ˜¯æ²¡æœ‰ä½ åœ¨èº«è¾¹çš„æ—¥å­ã€‚",
            "ä½ é—®æˆ‘ä¸ºä»€ä¹ˆä¸æ€•æ·±æµ·ï¼Ÿ<br>å› ä¸ºæœ‰ä½ ï¼Œå†æ·±çš„æµ·ä¹Ÿå……æ»¡æ¸©æš–ã€‚",
            "æˆ‘çš„ä½¿å‘½å¾ˆç®€å•ï¼š<br>åœ¨ä½ èº«è¾¹ï¼Œå®ˆæŠ¤ä½ ã€‚",
            "çˆ±ä¸æ˜¯è¯´è¯´è€Œå·²ï¼Œ<br>è€Œæ˜¯æ¯ä¸€æ¬¡ä¸ºä½ æŒ¡åœ¨å‰é¢çš„å‹‡æ°”ã€‚"
        ];
        
        // æ˜¾ç¤ºéšæœºæ–‡æ¡ˆ
        function showRandomQuote() {
            const quoteEl = document.getElementById('startQuote');
            if (quoteEl) {
                quoteEl.innerHTML = START_QUOTES[Math.floor(Math.random() * START_QUOTES.length)];
            }
        }
        
        // åˆå§‹åŒ–æ—¶æ˜¾ç¤ºéšæœºæ–‡æ¡ˆ
        showRandomQuote();
        
        // æš‚åœæ¸¸æˆ
        function pauseGame() {
            if (!gameState.isRunning || gameState.isPaused) return;
            gameState.isPaused = true;
            document.getElementById('pauseScreen').classList.remove('hidden');
            document.getElementById('pauseBtn').classList.add('hidden');
        }
        
        // ç»§ç»­æ¸¸æˆ
        function resumeGame() {
            if (!gameState.isPaused) return;
            gameState.isPaused = false;
            document.getElementById('pauseScreen').classList.add('hidden');
            document.getElementById('pauseBtn').classList.remove('hidden');
        }
        
        // é€€å‡ºæ¸¸æˆ
        function quitGame() {
            gameState.isRunning = false;
            gameState.isPaused = false;
            document.getElementById('pauseScreen').classList.add('hidden');
            backToMenu();
        }
        
        // æ˜¾ç¤ºå…³å¡
        function showStage() {
            const waveDisplay = document.getElementById('waveDisplay');
            waveDisplay.textContent = `ç¬¬ ${gameState.currentStage} å…³`;
            waveDisplay.classList.remove('show');
            void waveDisplay.offsetWidth;
            waveDisplay.classList.add('show');
        }
        
        // === Bossè¡€æ¡æ§åˆ¶ ===
        function showBossHpBar(boss) {
            const container = document.getElementById('bossHpContainer');
            const nameEl = document.getElementById('bossName');
            const barEl = document.getElementById('bossHpBar');
            const dotsEl = document.getElementById('bossPhaseDots');
            
            // è®¾ç½®Bossåç§°
            let nameHtml = boss.bossConfig.name;
            if (boss.isMultiPhase) {
                nameHtml += `<span class="phase-badge">é˜¶æ®µ ${boss.currentPhase}/3</span>`;
            }
            nameEl.innerHTML = nameHtml;
            
            // è®¾ç½®è¡€æ¡
            barEl.style.width = '100%';
            barEl.classList.remove('low', 'medium');
            
            // è®¾ç½®é˜¶æ®µæŒ‡ç¤ºç‚¹ï¼ˆä¸‰é˜¶æ®µBossï¼‰
            if (boss.isMultiPhase) {
                dotsEl.innerHTML = `
                    <div class="boss-phase-dot active"></div>
                    <div class="boss-phase-dot"></div>
                    <div class="boss-phase-dot"></div>
                `;
                dotsEl.style.display = 'flex';
            } else {
                dotsEl.style.display = 'none';
            }
            
            // æ˜¾ç¤ºå®¹å™¨
            container.classList.add('show');
        }
        
        function updateBossHpBar(boss) {
            const container = document.getElementById('bossHpContainer');
            if (!container.classList.contains('show')) return;
            
            const nameEl = document.getElementById('bossName');
            const barEl = document.getElementById('bossHpBar');
            const dotsEl = document.getElementById('bossPhaseDots');
            
            const hpPercent = Math.max(0, boss.hp / boss.maxHp);
            barEl.style.width = (hpPercent * 100) + '%';
            
            // æ ¹æ®è¡€é‡è®¾ç½®é¢œè‰²
            barEl.classList.remove('low', 'medium');
            if (hpPercent <= 0.25) {
                barEl.classList.add('low');
            } else if (hpPercent <= 0.5) {
                barEl.classList.add('medium');
            }
            
            // æ›´æ–°ä¸‰é˜¶æ®µBossä¿¡æ¯
            if (boss.isMultiPhase) {
                // æ›´æ–°åç§°å’Œé˜¶æ®µæ ‡è®°
                let nameHtml = boss.multiPhaseConfig.name;
                const phaseNames = ['â… ', 'â…¡', 'â…¢'];
                nameHtml += ` ${phaseNames[boss.currentPhase - 1]}`;
                nameHtml += `<span class="phase-badge">é˜¶æ®µ ${boss.currentPhase}/3</span>`;
                nameEl.innerHTML = nameHtml;
                
                // æ›´æ–°é˜¶æ®µç‚¹
                const dots = dotsEl.querySelectorAll('.boss-phase-dot');
                dots.forEach((dot, i) => {
                    dot.classList.remove('active', 'completed');
                    if (i < boss.currentPhase - 1) {
                        dot.classList.add('completed');
                    } else if (i === boss.currentPhase - 1) {
                        dot.classList.add('active');
                    }
                });
            }
        }
        
        function hideBossHpBar() {
            const container = document.getElementById('bossHpContainer');
            container.classList.remove('show');
        }
        
        // è·å–å·²è§£é”å…³å¡
        function getUnlockedStage() {
            return parseInt(localStorage.getItem('unlockedStage') || '1');
        }
        
        // ä¿å­˜è§£é”å…³å¡
        function saveUnlockedStage(stage) {
            const current = getUnlockedStage();
            if (stage > current) {
                localStorage.setItem('unlockedStage', stage.toString());
            }
        }
        
        // è·å–å…³å¡æœ€é«˜åˆ†
        function getStageHighScore(stage) {
            const scores = JSON.parse(localStorage.getItem('stageHighScores') || '{}');
            return scores[stage] || 0;
        }
        
        // ä¿å­˜å…³å¡åˆ†æ•°ï¼ˆåªä¿å­˜æ›´é«˜åˆ†ï¼‰
        function saveStageScore(stage, score) {
            const scores = JSON.parse(localStorage.getItem('stageHighScores') || '{}');
            const oldScore = scores[stage] || 0;
            if (score > oldScore) {
                scores[stage] = score;
                localStorage.setItem('stageHighScores', JSON.stringify(scores));
                return { isNewRecord: true, oldScore: oldScore };
            }
            return { isNewRecord: false, oldScore: oldScore };
        }
        
        // === å…³å¡è¯„åˆ†ç³»ç»Ÿ ===
        // æ¯å…³çš„è¯„åˆ†æ ‡å‡†ï¼ˆåŸºç¡€åˆ† + æ¯å…³é€’å¢ï¼‰
        const STAGE_RANK_CONFIG = {
            baseScore: { S: 400, A: 280, B: 180 }, // ç¬¬1å…³çš„åŸºå‡†
            perStage: { S: 30, A: 20, B: 10 },      // æ¯å…³å¢åŠ çš„è¦æ±‚
            timeBonus: 60,    // æ¯å¿«10ç§’åŠ åˆ†
            comboBonus: 5     // æ¯ä¸ªè¿å‡»åŠ åˆ†
        };
        
        // è®¡ç®—å…³å¡è¯„åˆ†
        function calculateStageRank(stage, score, timeFrames, maxCombo) {
            const cfg = STAGE_RANK_CONFIG;
            
            // è®¡ç®—å½“å‰å…³å¡çš„è¯„åˆ†é˜ˆå€¼
            const thresholds = {
                S: cfg.baseScore.S + (stage - 1) * cfg.perStage.S,
                A: cfg.baseScore.A + (stage - 1) * cfg.perStage.A,
                B: cfg.baseScore.B + (stage - 1) * cfg.perStage.B
            };
            
            // æ—¶é—´åŠ æˆï¼ˆæ¯å¿«10ç§’åŠ åˆ†ï¼‰
            const baseTime = 45 + stage * 5; // åŸºå‡†æ—¶é—´ï¼ˆç§’ï¼‰
            const actualTime = timeFrames / 60;
            const timeSaved = Math.max(0, baseTime - actualTime);
            const timeBonus = Math.floor(timeSaved / 10) * cfg.timeBonus;
            
            // è¿å‡»åŠ æˆ
            const comboBonus = maxCombo * cfg.comboBonus;
            
            // æ€»åˆ†
            const totalScore = score + timeBonus + comboBonus;
            
            // è¯„çº§
            let rank, rankLetter;
            if (totalScore >= thresholds.S) {
                rank = 'S'; rankLetter = 'S';
            } else if (totalScore >= thresholds.A) {
                rank = 'A'; rankLetter = 'A';
            } else if (totalScore >= thresholds.B) {
                rank = 'B'; rankLetter = 'B';
            } else {
                rank = 'C'; rankLetter = 'C';
            }
            
            return {
                rank,
                rankLetter,
                totalScore,
                timeBonus,
                comboBonus,
                thresholds
            };
        }
        
        // è·å–å…³å¡æœ€é«˜è¯„åˆ†
        function getStageRank(stage) {
            const ranks = JSON.parse(localStorage.getItem('stageRanks') || '{}');
            return ranks[stage] || null;
        }
        
        // ä¿å­˜å…³å¡è¯„åˆ†ï¼ˆåªä¿å­˜æ›´é«˜è¯„åˆ†ï¼‰
        function saveStageRank(stage, rank) {
            const ranks = JSON.parse(localStorage.getItem('stageRanks') || '{}');
            const rankOrder = { 'S': 4, 'A': 3, 'B': 2, 'C': 1 };
            const oldRank = ranks[stage];
            
            if (!oldRank || rankOrder[rank] > rankOrder[oldRank]) {
                ranks[stage] = rank;
                localStorage.setItem('stageRanks', JSON.stringify(ranks));
                return true;
            }
            return false;
        }
        
        // æ˜¾ç¤ºå…³å¡ç»“ç®—ç•Œé¢
        function showStageClear(stage, score, timeFrames, maxCombo, recordInfo) {
            gameState.isRunning = false;
            document.getElementById('pauseBtn').classList.add('hidden');
            
            // è®¡ç®—è¯„åˆ†
            const rankResult = calculateStageRank(stage, score, timeFrames, maxCombo);
            saveStageRank(stage, rankResult.rank);
            
            // æ›´æ–°UI
            document.getElementById('clearStageNum').textContent = stage;
            document.getElementById('clearScore').textContent = score.toLocaleString();
            
            // æ ¼å¼åŒ–æ—¶é—´
            const seconds = Math.floor(timeFrames / 60);
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            document.getElementById('clearTime').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
            
            document.getElementById('clearCombo').textContent = maxCombo;
            
            // è¯„åˆ†æ˜¾ç¤º
            const rankEl = document.getElementById('stageRank');
            rankEl.textContent = rankResult.rankLetter;
            rankEl.className = 'stage-rank rank-' + rankResult.rank.toLowerCase();
            
            // æ–°çºªå½•æ˜¾ç¤º
            const newRecordRow = document.getElementById('newRecordRow');
            if (recordInfo.isNewRecord && recordInfo.oldScore > 0) {
                newRecordRow.style.display = 'flex';
                document.getElementById('oldRecord').textContent = `åŸ: ${recordInfo.oldScore}`;
            } else {
                newRecordRow.style.display = 'none';
            }
            
            // æ˜¾ç¤ºç•Œé¢
            document.getElementById('stageClearScreen').classList.remove('hidden');
        }
        
        // ç»§ç»­ä¸‹ä¸€å…³
        function continueToNextStage() {
            document.getElementById('stageClearScreen').classList.add('hidden');
            
            if (gameState.currentStage >= gameState.maxStage) {
                // å·²æ˜¯æœ€åä¸€å…³ï¼Œæ˜¾ç¤ºé€šå…³ç•Œé¢
                gameWin();
            } else {
            // è¿›å…¥ä¸‹ä¸€å…³
                gameState.currentStage++;
                gameState.stageEnemyCount = 0;
                gameState.stageBossSpawned = false;
                gameState.elapsedFrames = 0;
                gameState.lastBossEndFrame = -99999;
                gameState.score = 0;
                gameState.combo = 0;
                gameState.maxCombo = 0;
                gameState.lives = CONFIG.ENDLESS_LIVES; // æ¯å…³é‡ç½®ä¸º3æ¡å‘½
                gameState.isRunning = true;
                
                // æ¸…ç†æˆ˜åœº
                bullets.length = 0;
                enemies.length = 0;
                powerUps.length = 0;
                
                document.getElementById('pauseBtn').classList.remove('hidden');
                updateUI();
                showStage();
                gameLoop();
            }
        }
        
        // è·å–æ— å°½æ¨¡å¼æœ€é«˜åˆ†
        function getEndlessHighScore() {
            return parseInt(localStorage.getItem('endlessHighScore') || '0');
        }
        
        // ä¿å­˜æ— å°½æ¨¡å¼åˆ†æ•°
        function saveEndlessScore(score) {
            const current = getEndlessHighScore();
            if (score > current) {
                localStorage.setItem('endlessHighScore', score.toString());
            }
            // åŒæ—¶ä¿å­˜åˆ°æ’è¡Œæ¦œ
            return addToLeaderboard(score);
        }
        
        // === æ’è¡Œæ¦œç³»ç»Ÿ ===
        const LEADERBOARD_MAX = 10; // æœ€å¤šä¿å­˜10æ¡è®°å½•
        
        // è·å–æ’è¡Œæ¦œ
        function getLeaderboard() {
            return JSON.parse(localStorage.getItem('endlessLeaderboard') || '[]');
        }
        
        // ä¿å­˜æ’è¡Œæ¦œ
        function saveLeaderboard(leaderboard) {
            localStorage.setItem('endlessLeaderboard', JSON.stringify(leaderboard));
        }
        
        // æ·»åŠ åˆ†æ•°åˆ°æ’è¡Œæ¦œ
        function addToLeaderboard(score) {
            if (score <= 0) return false;
            
            const leaderboard = getLeaderboard();
            const now = new Date();
            const dateStr = `${now.getMonth() + 1}/${now.getDate()}`;
            
            // æ·»åŠ æ–°è®°å½•
            leaderboard.push({ score, date: dateStr });
            
            // æŒ‰åˆ†æ•°æ’åº
            leaderboard.sort((a, b) => b.score - a.score);
            
            // åªä¿ç•™å‰Nå
            const trimmed = leaderboard.slice(0, LEADERBOARD_MAX);
            saveLeaderboard(trimmed);
            
            // æ£€æŸ¥æ˜¯å¦è¿›å…¥æ’è¡Œæ¦œ
            return trimmed.some(item => item.score === score && item.date === dateStr);
        }
        
        // æ˜¾ç¤ºæ’è¡Œæ¦œç•Œé¢
        function showLeaderboard() {
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('leaderboardScreen').classList.remove('hidden');
            renderLeaderboard();
        }
        
        // éšè—æ’è¡Œæ¦œç•Œé¢
        function hideLeaderboard() {
            document.getElementById('leaderboardScreen').classList.add('hidden');
            document.getElementById('startScreen').classList.remove('hidden');
        }
        
        // æ¸²æŸ“æ’è¡Œæ¦œ
        function renderLeaderboard() {
            const list = document.getElementById('leaderboardList');
            const leaderboard = getLeaderboard();
            
            if (leaderboard.length === 0) {
                list.innerHTML = '<div class="leaderboard-empty">è¿˜æ²¡æœ‰è®°å½•ï¼Œå»æ— å°½æ¨¡å¼åˆ›é€ ä¼ å¥‡å§ï¼</div>';
                return;
            }
            
            list.innerHTML = leaderboard.map((item, index) => {
                const rankClass = index === 0 ? 'top1' : (index === 1 ? 'top2' : (index === 2 ? 'top3' : ''));
                const rankColorClass = index === 0 ? 'gold' : (index === 1 ? 'silver' : (index === 2 ? 'bronze' : ''));
                const rankIcon = index === 0 ? 'ğŸ¥‡' : (index === 1 ? 'ğŸ¥ˆ' : (index === 2 ? 'ğŸ¥‰' : `${index + 1}`));
                
                return `
                    <div class="leaderboard-item ${rankClass}">
                        <div class="leaderboard-rank ${rankColorClass}">${rankIcon}</div>
                        <div class="leaderboard-score">${item.score.toLocaleString()}</div>
                        <div class="leaderboard-date">${item.date}</div>
                    </div>
                `;
            }).join('');
        }
        
        // === æˆå°±ç³»ç»Ÿ ===
        const ACHIEVEMENTS = [
            // åŸºç¡€æˆå°±
            { id: 'first_blood', icon: 'ğŸ‰', name: 'åˆæ¬¡å‡ºå‡»', desc: 'å‡»è´¥ç¬¬ä¸€ä¸ªæ•Œäºº', check: (stats) => stats.totalKills >= 1 },
            { id: 'killer_10', icon: 'ğŸ—¡ï¸', name: 'å°è¯•ç‰›åˆ€', desc: 'ç´¯è®¡å‡»è´¥10ä¸ªæ•Œäºº', check: (stats) => stats.totalKills >= 10 },
            { id: 'killer_100', icon: 'âš”ï¸', name: 'æ€æ‰‹', desc: 'ç´¯è®¡å‡»è´¥100ä¸ªæ•Œäºº', check: (stats) => stats.totalKills >= 100 },
            { id: 'killer_500', icon: 'ğŸ’€', name: 'æ­»ç¥', desc: 'ç´¯è®¡å‡»è´¥500ä¸ªæ•Œäºº', check: (stats) => stats.totalKills >= 500 },
            
            // Bossæˆå°±
            { id: 'boss_slayer', icon: 'ğŸ‰', name: 'å± é¾™è€…', desc: 'å‡»è´¥ç¬¬ä¸€ä¸ªBoss', check: (stats) => stats.bossKills >= 1 },
            { id: 'boss_hunter', icon: 'ğŸ¤º', name: 'BossçŒäºº', desc: 'ç´¯è®¡å‡»è´¥5ä¸ªBoss', check: (stats) => stats.bossKills >= 5 },
            { id: 'boss_master', icon: 'ğŸ‘‘', name: 'Bosså¤§å¸ˆ', desc: 'ç´¯è®¡å‡»è´¥20ä¸ªBoss', check: (stats) => stats.bossKills >= 20 },
            
            // åˆ†æ•°æˆå°±
            { id: 'score_1000', icon: 'ğŸ’°', name: 'åƒåˆ†è¾¾äºº', desc: 'å•å±€è¾¾åˆ°1000åˆ†', check: (stats) => stats.highScore >= 1000 },
            { id: 'score_5000', icon: 'ğŸ’', name: 'åˆ†æ•°å¤§å¸ˆ', desc: 'å•å±€è¾¾åˆ°5000åˆ†', check: (stats) => stats.highScore >= 5000 },
            { id: 'score_10000', icon: 'ğŸ†', name: 'ä¸‡åˆ†ä¼ è¯´', desc: 'å•å±€è¾¾åˆ°10000åˆ†', check: (stats) => stats.highScore >= 10000 },
            
            // è¿å‡»æˆå°±
            { id: 'combo_10', icon: 'ğŸ”¥', name: 'è¿å‡»æ–°æ‰‹', desc: 'è¾¾æˆ10è¿å‡»', check: (stats) => stats.maxCombo >= 10 },
            { id: 'combo_30', icon: 'ğŸ’¥', name: 'è¿å‡»é«˜æ‰‹', desc: 'è¾¾æˆ30è¿å‡»', check: (stats) => stats.maxCombo >= 30 },
            { id: 'combo_50', icon: 'â˜„ï¸', name: 'è¿å‡»å¤§å¸ˆ', desc: 'è¾¾æˆ50è¿å‡»', check: (stats) => stats.maxCombo >= 50 },
            
            // é€šå…³æˆå°±
            { id: 'stage_5', icon: 'â­', name: 'æ–°æ‰‹æ¯•ä¸š', desc: 'é€šå…³ç¬¬5å…³', check: (stats) => stats.maxStage >= 5 },
            { id: 'stage_10', icon: 'ğŸŒŸ', name: 'ä¸­çº§å®ˆæŠ¤è€…', desc: 'é€šå…³ç¬¬10å…³', check: (stats) => stats.maxStage >= 10 },
            { id: 'stage_15', icon: 'ğŸ’«', name: 'é«˜çº§å®ˆæŠ¤è€…', desc: 'é€šå…³ç¬¬15å…³', check: (stats) => stats.maxStage >= 15 },
            { id: 'stage_20', icon: 'ğŸ’–', name: 'çˆ±çš„å®ˆæŠ¤è€…', desc: 'é€šå…³å…¨20å…³', check: (stats) => stats.maxStage >= 20 },
            
            // ç‰¹æ®Šæˆå°±
            { id: 'powerup_collector', icon: 'âœ¨', name: 'é“å…·æ”¶é›†è€…', desc: 'ç´¯è®¡æ‹¾å–50ä¸ªé“å…·', check: (stats) => stats.powerupsCollected >= 50 },
            { id: 'survivor', icon: 'ğŸ›¡ï¸', name: 'ç”Ÿå­˜ä¸“å®¶', desc: 'ç´¯è®¡æ¸¸æˆ10æ¬¡', check: (stats) => stats.gamesPlayed >= 10 },
            { id: 'veteran', icon: 'ğŸ–ï¸', name: 'è€å…µ', desc: 'ç´¯è®¡æ¸¸æˆ50æ¬¡', check: (stats) => stats.gamesPlayed >= 50 }
        ];
        
        // è·å–ç»Ÿè®¡æ•°æ®
        function getGameStats() {
            return JSON.parse(localStorage.getItem('gameStats') || JSON.stringify({
                totalKills: 0,
                bossKills: 0,
                highScore: 0,
                maxCombo: 0,
                maxStage: 0,
                powerupsCollected: 0,
                gamesPlayed: 0
            }));
        }
        
        // ä¿å­˜ç»Ÿè®¡æ•°æ®
        function saveGameStats(stats) {
            localStorage.setItem('gameStats', JSON.stringify(stats));
        }
        
        // è·å–å·²è§£é”æˆå°±
        function getUnlockedAchievements() {
            return JSON.parse(localStorage.getItem('unlockedAchievements') || '[]');
        }
        
        // ä¿å­˜è§£é”æˆå°±
        function saveUnlockedAchievements(achievements) {
            localStorage.setItem('unlockedAchievements', JSON.stringify(achievements));
        }
        
        // æ£€æŸ¥å¹¶è§£é”æˆå°±
        function checkAchievements() {
            const stats = getGameStats();
            const unlocked = getUnlockedAchievements();
            let newUnlocks = [];
            
            ACHIEVEMENTS.forEach(ach => {
                if (!unlocked.includes(ach.id) && ach.check(stats)) {
                    unlocked.push(ach.id);
                    newUnlocks.push(ach);
                }
            });
            
            if (newUnlocks.length > 0) {
                saveUnlockedAchievements(unlocked);
                // ä¸å†æ˜¾ç¤ºå¼¹çª—ï¼Œé¿å…é®æŒ¡æ¸¸æˆç”»é¢
            }
        }
        
        // æ˜¾ç¤ºæˆå°±è§£é”å¼¹çª—
        function showAchievementPopup(achievement) {
            const popup = document.getElementById('achievementPopup');
            document.getElementById('popupIcon').textContent = achievement.icon;
            document.getElementById('popupName').textContent = achievement.name;
            popup.classList.add('show');
            
            setTimeout(() => {
                popup.classList.remove('show');
            }, 2000);
        }
        
        // æ˜¾ç¤ºæˆå°±ç•Œé¢
        function showAchievements() {
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('achievementScreen').classList.remove('hidden');
            renderAchievementGrid();
        }
        
        // éšè—æˆå°±ç•Œé¢
        function hideAchievements() {
            document.getElementById('achievementScreen').classList.add('hidden');
            document.getElementById('startScreen').classList.remove('hidden');
        }
        
        // æ¸²æŸ“æˆå°±åˆ—è¡¨
        function renderAchievementGrid() {
            const grid = document.getElementById('achievementGrid');
            const unlocked = getUnlockedAchievements();
            
            document.getElementById('achievementProgress').textContent = `${unlocked.length} / ${ACHIEVEMENTS.length}`;
            
            grid.innerHTML = ACHIEVEMENTS.map(ach => {
                const isUnlocked = unlocked.includes(ach.id);
                return `
                    <div class="achievement-card ${isUnlocked ? 'unlocked' : 'locked'}">
                        <div class="achievement-icon">${ach.icon}</div>
                        <div class="achievement-name">${ach.name}</div>
                        <div class="achievement-desc">${ach.desc}</div>
                    </div>
                `;
            }).join('');
        }
        
        // æ›´æ–°ç»Ÿè®¡æ•°æ®
        function updateStats(type, value) {
            const stats = getGameStats();
            switch(type) {
                case 'kill':
                    stats.totalKills += value;
                    break;
                case 'bossKill':
                    stats.bossKills += value;
                    break;
                case 'score':
                    if (value > stats.highScore) stats.highScore = value;
                    break;
                case 'combo':
                    if (value > stats.maxCombo) stats.maxCombo = value;
                    break;
                case 'stage':
                    if (value > stats.maxStage) stats.maxStage = value;
                    break;
                case 'powerup':
                    stats.powerupsCollected += value;
                    break;
                case 'game':
                    stats.gamesPlayed += value;
                    break;
            }
            saveGameStats(stats);
            checkAchievements();
        }
        
        // æ˜¾ç¤ºå…³å¡é€‰æ‹©ç•Œé¢
        function showStageSelect() {
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('stageSelectScreen').classList.remove('hidden');
            
            const unlockedStage = getUnlockedStage();
            const grid = document.getElementById('stageGrid');
            grid.innerHTML = '';
            
            for (let i = 1; i <= 20; i++) {
                const btn = document.createElement('button');
                const isUnlocked = i <= unlockedStage;
                const highScore = getStageHighScore(i);
                const stageRank = getStageRank(i);
                
                // æ˜¾ç¤ºå…³å¡å·ã€è¯„åˆ†å’Œæœ€é«˜åˆ†
                if (isUnlocked) {
                    if (stageRank) {
                        // æœ‰è¯„åˆ†ï¼šæ˜¾ç¤ºå…³å¡å· + è¯„åˆ†å¾½ç« 
                        const rankColors = { S: '#ffd700', A: '#ff69b4', B: '#74b9ff', C: '#a29bfe' };
                        btn.innerHTML = `
                            <div style="font-size:18px;line-height:1">${i}</div>
                            <div style="font-size:12px;font-weight:bold;color:${rankColors[stageRank]};text-shadow:0 1px 3px rgba(0,0,0,0.5)">${stageRank}</div>
                        `;
                    } else if (highScore > 0) {
                        // æœ‰åˆ†æ•°ä½†æ— è¯„åˆ†ï¼ˆæ—§æ•°æ®å…¼å®¹ï¼‰
                        btn.innerHTML = `<div style="font-size:16px;line-height:1.1">${i}</div><div style="font-size:9px;color:#ffd700">${highScore}</div>`;
                    } else {
                        // æœªé€šå…³
                        btn.innerHTML = `<div style="font-size:20px">${i}</div>`;
                    }
                } else {
                    btn.innerHTML = 'ğŸ”’';
                }
                
                // æ ¹æ®è¯„åˆ†è®¾ç½®è¾¹æ¡†é¢œè‰²
                let borderColor = '#555';
                if (isUnlocked) {
                    if (stageRank === 'S') borderColor = '#ffd700';
                    else if (stageRank === 'A') borderColor = '#ff69b4';
                    else if (stageRank === 'B') borderColor = '#74b9ff';
                    else if (stageRank === 'C') borderColor = '#a29bfe';
                    else borderColor = '#ffd700';
                }
                
                btn.style.cssText = `
                    width: 56px; height: 56px; border-radius: 12px; border: 2px solid ${borderColor};
                    background: ${isUnlocked ? 'linear-gradient(135deg, #ff69b4 0%, #ff1493 100%)' : 'linear-gradient(135deg, #444 0%, #333 100%)'};
                    color: ${isUnlocked ? 'white' : '#666'}; font-weight: bold;
                    cursor: ${isUnlocked ? 'pointer' : 'not-allowed'}; transition: all 0.2s;
                    box-shadow: ${isUnlocked ? '0 4px 15px rgba(255,105,180,0.4)' : 'none'};
                    display: flex; flex-direction: column; justify-content: center; align-items: center;
                    padding: 2px; position: relative;
                `;
                
                if (isUnlocked) {
                    btn.onclick = () => startStage(i);
                    btn.onmouseenter = () => btn.style.transform = 'scale(1.1)';
                    btn.onmouseleave = () => btn.style.transform = 'scale(1)';
                }
                
                grid.appendChild(btn);
            }
        }
        
        // éšè—å…³å¡é€‰æ‹©
        function hideStageSelect() {
            document.getElementById('stageSelectScreen').classList.add('hidden');
            document.getElementById('startScreen').classList.remove('hidden');
        }
        
        // å¼€å§‹æŒ‡å®šå…³å¡
        function startStage(stageNum) {
            document.getElementById('stageSelectScreen').classList.add('hidden');
            stopHomepageAnimation(); // åœæ­¢é¦–é¡µåŠ¨ç”»
            initGame('stage');
            gameState.currentStage = stageNum;
            gameState.isRunning = true;
            gameState.elapsedFrames = 0; // æ–°å…³å¡è®¡æ—¶å½’é›¶
            gameState.lastBossEndFrame = -99999;
            // æ˜¾ç¤ºæš‚åœæŒ‰é’®
            document.getElementById('pauseBtn').classList.remove('hidden');
            showStage();
            gameLoop();
        }

        // æ˜¾ç¤ºæ³¢æ¬¡
        function showWave() {
            const waveDisplay = document.getElementById('waveDisplay');
            waveDisplay.textContent = `WAVE ${gameState.wave}`;
            waveDisplay.classList.remove('show');
            void waveDisplay.offsetWidth;
            waveDisplay.classList.add('show');
        }

        // æ›´æ–°UI
        function updateUI() {
            document.getElementById('scoreDisplay').textContent = gameState.score;
            
            // æ›´æ–°é“å…·çŠ¶æ€æ˜¾ç¤º
            updatePowerupStatus();
            
            // æ›´æ–°ç”Ÿå‘½æ˜¾ç¤ºï¼ˆæ‰€æœ‰æ¨¡å¼ï¼‰
            const livesDisplay = document.getElementById('livesDisplay');
            livesDisplay.textContent = 'â¤ï¸'.repeat(gameState.lives);
        }
        
        // æ›´æ–°é“å…·çŠ¶æ€å›¾æ ‡
        function updatePowerupStatus() {
            const container = document.getElementById('powerupStatus');
            let html = '';
            
            // æ­¦å™¨é“å…·
            if (gameState.powerUpType !== 'none' && gameState.powerUpTime > 0) {
                const icons = { rapid: 'âš¡', double: 'â‡ï¸', triple: 'ğŸ”±', spread: 'ğŸŒŸ', laser: 'ğŸ’' };
                const icon = icons[gameState.powerUpType] || 'âœ¨';
                const percent = (gameState.powerUpTime / CONFIG.POWERUP_DURATION) * 100;
                html += `<div class="powerup-icon" style="border-color: #ffd700;">
                    ${icon}
                    <div class="timer-bar" style="width: ${percent}%;"></div>
                </div>`;
            }
            
            // æŠ¤ç›¾
            if (gameState.isInvincible && gameState.invincibleTime > 0) {
                const percent = (gameState.invincibleTime / CONFIG.SHIELD_DURATION) * 100;
                html += `<div class="powerup-icon" style="border-color: #64c8ff;">
                    ğŸ›¡ï¸
                    <div class="timer-bar" style="width: ${percent}%; background: #64c8ff;"></div>
                </div>`;
            }
            
            // èªä»”æœº
            if (gameState.droneActive && gameState.droneTime > 0) {
                const percent = (gameState.droneTime / CONFIG.DRONE_DURATION) * 100;
                html += `<div class="powerup-icon" style="border-color: #00e5ff;">
                    ğŸ›°ï¸
                    <div class="timer-bar" style="width: ${percent}%; background: #00e5ff;"></div>
                </div>`;
            }
            
            // å½©è›‹Bosså¼ºåŒ–
            if (gameState.secretBuff && gameState.secretBuffTime > 0) {
                const percent = (gameState.secretBuffTime / CONFIG.SECRET_BUFF_DURATION) * 100;
                html += `<div class="powerup-icon" style="border-color: #ff4500;">
                    ğŸ”¥
                    <div class="timer-bar" style="width: ${percent}%; background: #ff4500;"></div>
                </div>`;
            }
            
            container.innerHTML = html;
        }

        // ç»˜åˆ¶æ°”æ³¡èƒŒæ™¯ï¼ˆæµ·åº•é£æ ¼ï¼‰
        function drawStars() {
            stars.forEach(star => {
                // æ°”æ³¡å‘ä¸Šæ¼‚æµ®
                star.y -= star.speed;
                star.wobble += 0.02;
                star.x += Math.sin(star.wobble) * 0.3;
                
                if (star.y < -10) {
                    star.y = CONFIG.CANVAS_HEIGHT + 10;
                    star.x = Math.random() * CONFIG.CANVAS_WIDTH;
                }
                
                const alpha = 0.2 + star.brightness * 0.3;
                // æ°”æ³¡æ•ˆæœ
                ctx.save();
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(200, 230, 255, ${alpha * 0.3})`;
                ctx.fill();
                ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.lineWidth = 1;
                ctx.stroke();
                // æ°”æ³¡é«˜å…‰
                ctx.beginPath();
                ctx.arc(star.x - star.size * 0.3, star.y - star.size * 0.3, star.size * 0.25, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;
                ctx.fill();
                ctx.restore();
            });
        }

        // ç»˜åˆ¶ç©å®¶é±¼ï¼ˆçŸ¢é‡ç»˜åˆ¶ - ç¾åŒ–ç‰ˆï¼‰
        let playerAnimTime = 0;
        function drawPlayer() {
            // æ— æ•Œé—ªçƒæ•ˆæœï¼šç”¨é€æ˜åº¦å®ç°
            const isBlinking = player.invincible > 0 && Math.floor(player.invincible / 5) % 2 === 0;
            if (isBlinking) {
                ctx.globalAlpha = 0.3;
            }
            
            // åŠ¨ç”»è®¡æ—¶
            playerAnimTime += 0.12;
            const swimWave = Math.sin(playerAnimTime) * 0.08; // æ‘†å°¾
            const breathe = 1 + Math.sin(playerAnimTime * 0.6) * 0.025; // å‘¼å¸
            const finWave = Math.sin(playerAnimTime * 1.8) * 0.25; // é³æ‘†åŠ¨
            
            // æ ¹æ®æ­¦å™¨ç­‰çº§ç¡®å®šç¼©æ”¾ï¼ˆä¸å†æ˜¾ç¤ºå‘å…‰åœ†åœˆï¼‰
            const lvl = gameState.powerUpLevel || 0;
            const type = gameState.powerUpType;
            const LEVEL_SCALES = [1, 1.05, 1.1, 1.15];
            const sc = ((type !== 'none' && lvl >= 1) ? LEVEL_SCALES[Math.min(lvl, 3)] : 1) * 0.75; // ç¼©å°ç©å®¶é±¼ä½“å‹

            // æ°”æ³¡å°¾è¿¹
            player.trail.push({ x: player.x, y: player.y + 22 * sc, alpha: 1 });
            if (player.trail.length > 10) player.trail.shift();
            player.trail.forEach((t, i) => {
                const alpha = (i / player.trail.length) * 0.5;
                const size = 2 + (i / player.trail.length) * 6;
                ctx.beginPath();
                ctx.arc(t.x + (Math.random() - 0.5) * 5, t.y + (Math.random() - 0.5) * 3, size * sc, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 200, 230, ${alpha})`;
                ctx.fill();
            });

            // ç»˜åˆ¶ç©å®¶é±¼
            ctx.save();
            ctx.translate(player.x, player.y);
            
            // å¤–å±‚å…‰æ™•
            ctx.shadowColor = '#ff69b4';
            ctx.shadowBlur = 15;
            
            // é±¼èº«ä¸»ä½“æ¸å˜ï¼ˆç²‰è‰²å°é±¼ï¼‰
            const bodyGrad = ctx.createRadialGradient(0, -8 * sc, 0, 0, 0, 28 * sc);
            bodyGrad.addColorStop(0, '#ffb6d9');
            bodyGrad.addColorStop(0.3, '#ff69b4');
            bodyGrad.addColorStop(0.7, '#ff1493');
            bodyGrad.addColorStop(1, '#c71585');
            
            // é±¼å°¾ï¼ˆå¸¦æ‘†åŠ¨ï¼‰
            ctx.save();
            ctx.rotate(swimWave);
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.moveTo(0, 20 * sc);
            ctx.quadraticCurveTo(-10 * sc, 28 * sc, -15 * sc, 40 * sc);
            ctx.quadraticCurveTo(0, 34 * sc, 15 * sc, 40 * sc);
            ctx.quadraticCurveTo(10 * sc, 28 * sc, 0, 20 * sc);
            ctx.fill();
            ctx.restore();
            
            // é±¼èº«æ¤­åœ†ï¼ˆå¸¦å‘¼å¸ï¼‰
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.ellipse(0, 0, 18 * sc * breathe, 26 * sc, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // è…¹éƒ¨é«˜å…‰
            ctx.fillStyle = 'rgba(255,220,240,0.5)';
            ctx.beginPath();
            ctx.ellipse(3 * sc, 8 * sc, 10 * sc, 14 * sc, 0.15, 0, Math.PI * 2);
            ctx.fill();
            
            // ä¾§é³ï¼ˆå¸¦æ‘†åŠ¨ï¼‰
            ctx.fillStyle = bodyGrad;
            // å·¦ä¾§é³
            ctx.save();
            ctx.translate(-16 * sc, 3 * sc);
            ctx.rotate(-0.4 + finWave);
            ctx.beginPath();
            ctx.ellipse(0, 0, 14 * sc, 5 * sc, -0.6, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            // å³ä¾§é³
            ctx.save();
            ctx.translate(16 * sc, 3 * sc);
            ctx.rotate(0.4 - finWave);
            ctx.beginPath();
            ctx.ellipse(0, 0, 14 * sc, 5 * sc, 0.6, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            // å°ä¸‘é±¼æ¡çº¹ï¼ˆç™½è‰²ï¼‰
            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            ctx.beginPath();
            ctx.ellipse(-6 * sc, -2 * sc, 2.5 * sc, 18 * sc, -0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(6 * sc, -2 * sc, 2.5 * sc, 18 * sc, 0.1, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.shadowBlur = 0;
            
            // çœ¼ç›å¤–æ¡†
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.ellipse(-7 * sc, -10 * sc, 7 * sc, 6 * sc, 0, 0, Math.PI * 2);
            ctx.ellipse(7 * sc, -10 * sc, 7 * sc, 6 * sc, 0, 0, Math.PI * 2);
            ctx.fill();
            // çœ¼çƒ
            ctx.fillStyle = '#1a1a2e';
            ctx.beginPath();
            ctx.arc(-7 * sc, -9 * sc, 3.5 * sc, 0, Math.PI * 2);
            ctx.arc(7 * sc, -9 * sc, 3.5 * sc, 0, Math.PI * 2);
            ctx.fill();
            // çœ¼ç›é«˜å…‰
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-8.5 * sc, -11 * sc, 2 * sc, 0, Math.PI * 2);
            ctx.arc(5.5 * sc, -11 * sc, 2 * sc, 0, Math.PI * 2);
            ctx.fill();
            // ç¬¬äºŒå±‚é«˜å…‰
            ctx.beginPath();
            ctx.arc(-5.5 * sc, -8 * sc, 1 * sc, 0, Math.PI * 2);
            ctx.arc(8.5 * sc, -8 * sc, 1 * sc, 0, Math.PI * 2);
            ctx.fill();
            
            // å˜´å·´ï¼ˆå¾®ç¬‘ï¼‰
            ctx.strokeStyle = '#c71585';
            ctx.lineWidth = 2 * sc;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.arc(0, -16 * sc, 4 * sc, 0.15 * Math.PI, 0.85 * Math.PI);
            ctx.stroke();
            
            // è„¸é¢šçº¢æ™•
            ctx.fillStyle = 'rgba(255,100,150,0.3)';
            ctx.beginPath();
            ctx.ellipse(-14 * sc, -6 * sc, 4 * sc, 2.5 * sc, 0, 0, Math.PI * 2);
            ctx.ellipse(14 * sc, -6 * sc, 4 * sc, 2.5 * sc, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // é³ç‰‡çº¹ç†
            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.lineWidth = 0.8 * sc;
            for (let i = 0; i < 4; i++) {
                ctx.beginPath();
                ctx.arc(0, (2 + i * 5) * sc, (12 - i * 2) * sc, 0.65 * Math.PI, 0.35 * Math.PI, true);
                ctx.stroke();
            }
            
            ctx.restore();

            // æ— æ•ŒæŠ¤ç›¾ï¼ˆæ°”æ³¡ç›¾ï¼‰
            if (gameState.isInvincible) {
                ctx.save();
                const shieldGlow = ctx.createRadialGradient(player.x, player.y, 28, player.x, player.y, 50);
                shieldGlow.addColorStop(0, 'rgba(100, 200, 255, 0)');
                shieldGlow.addColorStop(0.5, 'rgba(100, 200, 255, 0.35)');
                shieldGlow.addColorStop(1, 'rgba(100, 200, 255, 0)');
                ctx.fillStyle = shieldGlow;
                ctx.beginPath();
                ctx.arc(player.x, player.y, 50, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#64c8ff';
                ctx.lineWidth = 2.5;
                ctx.shadowColor = '#64c8ff';
                ctx.shadowBlur = 18;
                ctx.beginPath();
                ctx.arc(player.x, player.y, 42, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }
            
            // æ¢å¤é€æ˜åº¦
            ctx.globalAlpha = 1;
        }

        // ç»˜åˆ¶å­å¼¹ï¼ˆæ°´æ³¡å½¢çŠ¶ï¼‰
        function drawBullets() {
            bullets.forEach(bullet => {
                ctx.save();
                ctx.translate(bullet.x, bullet.y);
                
                if (bullet.type === 'player') {
                    if (bullet.isLaser) {
                        // æ°´æŸ±æ”»å‡»ï¼ˆä½¿ç”¨ç¼“å­˜æ¸å˜ï¼‰
                        const w = bullet.laserWidth || 8;
                        ctx.fillStyle = GradientCache.cache['playerLaser'];
                        ctx.fillRect(-w/2, -30, w, 30);
                    } else {
                        // æ°´æ³¡å­å¼¹
                        const r = 8;
                        ctx.beginPath();
                        ctx.arc(0, 0, r, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(100, 200, 255, 0.6)';
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(200, 240, 255, 0.9)';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        // é«˜å…‰
                        ctx.beginPath();
                        ctx.arc(-2, -2, r * 0.3, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.fill();
                    }
                } else {
                    // æ•Œäººå­å¼¹ - æ ¹æ®ç±»å‹ç»˜åˆ¶ä¸åŒæ ·å¼
                    drawEnemyBullet(bullet);
                }
                
                ctx.shadowBlur = 0;
                ctx.restore();
            });
        }

        // ç»˜åˆ¶æ•Œäººå­å¼¹ï¼ˆæ ¹æ®ç±»å‹ä¸åŒæ ·å¼ï¼‰
        function drawEnemyBullet(bullet) {
            const style = bullet.bulletStyle || 'normal';
            const bossColor = bullet.bossColor || '#ff4757';
            
            // Bosså­å¼¹ç»Ÿä¸€å¤„ç†
            if (style.startsWith('boss_')) {
                drawBossBullet(style, bossColor);
                return;
            }
            
            switch(style) {
                case 'fast': // å¿«é€Ÿé±¼ - å°–é”ç»¿è‰²å°å­å¼¹
                    ctx.fillStyle = '#00d2d3';
                    ctx.shadowColor = '#00d2d3';
                    ctx.shadowBlur = 6;
                    ctx.beginPath();
                    ctx.moveTo(0, -8);
                    ctx.lineTo(-4, 4);
                    ctx.lineTo(0, 2);
                    ctx.lineTo(4, 4);
                    ctx.closePath();
                    ctx.fill();
                    // å°¾è¿¹
                    ctx.fillStyle = 'rgba(0, 210, 211, 0.4)';
                    ctx.beginPath();
                    ctx.moveTo(-2, 4);
                    ctx.lineTo(0, 12);
                    ctx.lineTo(2, 4);
                    ctx.fill();
                    break;
                    
                case 'tank': // å¦å…‹é±¼ - å¤§å‹æ©™è‰²çˆ†ç‚¸å­å¼¹ï¼ˆä½¿ç”¨ç¼“å­˜æ¸å˜ï¼‰
                    ctx.fillStyle = GradientCache.cache['tankBullet'];
                    ctx.shadowColor = '#e17055';
                    ctx.shadowBlur = 12;
                    ctx.beginPath();
                    ctx.arc(0, 0, 10, 0, Math.PI * 2);
                    ctx.fill();
                    // å°–åˆº
                    ctx.fillStyle = '#e17055';
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        ctx.save();
                        ctx.rotate(angle);
                        ctx.beginPath();
                        ctx.moveTo(8, 0);
                        ctx.lineTo(14, -2);
                        ctx.lineTo(14, 2);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    }
                    // é«˜å…‰
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.beginPath();
                    ctx.arc(-3, -3, 3, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'sniper': // ç‹™å‡»é±¼ - ç»¿è‰²ç²¾å‡†å…‰æŸï¼ˆä½¿ç”¨ç¼“å­˜æ¸å˜ï¼‰
                    ctx.shadowColor = '#00ff88';
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = GradientCache.cache['sniperBullet'];
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 3, 10, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // å…‰æ™•
                    ctx.fillStyle = 'rgba(0, 255, 136, 0.3)';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 6, 14, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // ä¸­å¿ƒäº®ç‚¹
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(0, -5, 2, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'splitter': // åˆ†è£‚é±¼ - ç´«è‰²é€æ˜æ°´æ¯å­å¼¹ï¼ˆä½¿ç”¨ç¼“å­˜æ¸å˜ï¼‰
                    ctx.shadowColor = '#a29bfe';
                    ctx.shadowBlur = 8;
                    ctx.fillStyle = GradientCache.cache['splitterBullet'];
                    ctx.beginPath();
                    ctx.arc(0, 0, 7, Math.PI, 0, false);
                    ctx.quadraticCurveTo(8, 4, 5, 6);
                    ctx.lineTo(-5, 6);
                    ctx.quadraticCurveTo(-8, 4, -7, 0);
                    ctx.fill();
                    // è§¦æ‰‹
                    ctx.strokeStyle = 'rgba(162, 155, 254, 0.7)';
                    ctx.lineWidth = 1.5;
                    ctx.lineCap = 'round';
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(-4 + i * 4, 6);
                        ctx.lineTo(-4 + i * 4 + (Math.random() - 0.5) * 3, 14);
                        ctx.stroke();
                    }
                    break;
                    
                case 'mini': // è¿·ä½ é±¼ - å¾®å°çº¢è‰²å­å¼¹
                    ctx.fillStyle = '#ff7675';
                    ctx.shadowColor = '#ff7675';
                    ctx.shadowBlur = 5;
                    ctx.beginPath();
                    ctx.arc(0, 0, 4, 0, Math.PI * 2);
                    ctx.fill();
                    // å°é«˜å…‰
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(-1, -1, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'bomber': // è½°ç‚¸é±¼ - ç‚¸å¼¹ï¼ˆä½¿ç”¨ç¼“å­˜æ¸å˜ï¼‰
                    ctx.shadowColor = '#2d3436';
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = GradientCache.cache['bomberBullet'];
                    ctx.beginPath();
                    ctx.arc(0, 0, 9, 0, Math.PI * 2);
                    ctx.fill();
                    // å¼•ä¿¡ç«èŠ±
                    ctx.fillStyle = '#f39c12';
                    ctx.beginPath();
                    ctx.arc(0, -10, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#e74c3c';
                    ctx.beginPath();
                    ctx.arc(0, -12, 2, 0, Math.PI * 2);
                    ctx.fill();
                    // å…‰æ³½
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.beginPath();
                    ctx.arc(-3, -3, 3, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'shield': // æŠ¤ç›¾é±¼ - ç”µå¼§å­å¼¹ï¼ˆä½¿ç”¨ç¼“å­˜æ¸å˜ï¼‰
                    ctx.shadowColor = '#00d2ff';
                    ctx.shadowBlur = 12;
                    ctx.fillStyle = GradientCache.cache['shieldBullet'];
                    ctx.beginPath();
                    ctx.arc(0, 0, 6, 0, Math.PI * 2);
                    ctx.fill();
                    // ç”µå¼§æ•ˆæœ
                    ctx.strokeStyle = 'rgba(0, 210, 255, 0.6)';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 4; i++) {
                        const angle = (i / 4) * Math.PI * 2 + Math.random() * 0.5;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(angle) * 6, Math.sin(angle) * 6);
                        ctx.lineTo(Math.cos(angle) * 12, Math.sin(angle) * 12);
                        ctx.stroke();
                    }
                    break;
                    
                case 'healer': // æ²»æ„ˆé±¼ - æ²»æ„ˆæ³¢ï¼ˆç»¿è‰²å¿ƒå½¢ï¼‰
                    ctx.shadowColor = '#2ecc71';
                    ctx.shadowBlur = 10;
                    // å¿ƒå½¢å­å¼¹
                    ctx.fillStyle = '#2ecc71';
                    ctx.beginPath();
                    ctx.moveTo(0, 3);
                    ctx.bezierCurveTo(-5, -2, -5, -6, 0, -8);
                    ctx.bezierCurveTo(5, -6, 5, -2, 0, 3);
                    ctx.fill();
                    // å†…éƒ¨äº®å…‰
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.beginPath();
                    ctx.arc(-2, -4, 2, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'swarm': // èœ‚ç¾¤é±¼ - å¾®å°é±¼é³å­å¼¹
                    ctx.shadowColor = '#74b9ff';
                    ctx.shadowBlur = 5;
                    // é±¼é³å½¢çŠ¶
                    ctx.fillStyle = '#74b9ff';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 3, 5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // é³ç‰‡çº¹ç†
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.arc(0, -1, 2, 0, Math.PI);
                    ctx.stroke();
                    break;
                    
                default: // æ™®é€šé±¼ - æ ‡å‡†çº¢è‰²æ°´æ³¡
                    const r = 6;
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 100, 100, 0.7)';
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 150, 150, 0.9)';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                    // é«˜å…‰
                    ctx.beginPath();
                    ctx.arc(-1.5, -1.5, r * 0.25, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.fill();
            }
        }
        
        // ç»˜åˆ¶Bosså­å¼¹ï¼ˆæ ¹æ®Bossé¢œè‰²å’Œå¼¹é“ç±»å‹ï¼‰
        function drawBossBullet(style, color) {
            ctx.shadowColor = color;
            ctx.shadowBlur = 12;
            
            switch(style) {
                case 'boss_spiral': // èºæ—‹ - æ˜Ÿå½¢æ—‹è½¬å­å¼¹
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i / 5) * Math.PI * 2 - Math.PI / 2;
                        const x = Math.cos(angle) * 8;
                        const y = Math.sin(angle) * 8;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                        const innerAngle = angle + Math.PI / 5;
                        ctx.lineTo(Math.cos(innerAngle) * 4, Math.sin(innerAngle) * 4);
                    }
                    ctx.closePath();
                    ctx.fill();
                    // ä¸­å¿ƒäº®ç‚¹
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(0, 0, 2, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'boss_burst': // çˆ†è£‚ - åœ†å½¢èƒ½é‡çƒ
                case 'boss_ring':
                    const burstGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 8);
                    burstGrad.addColorStop(0, '#ffffff');
                    burstGrad.addColorStop(0.3, color);
                    burstGrad.addColorStop(1, color + '88');
                    ctx.fillStyle = burstGrad;
                    ctx.beginPath();
                    ctx.arc(0, 0, 7, 0, Math.PI * 2);
                    ctx.fill();
                    // å¤–åœˆå…‰ç­›
                    ctx.strokeStyle = color + '66';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, 10, 0, Math.PI * 2);
                    ctx.stroke();
                    break;
                    
                case 'boss_breath': // é¾™æ¯ - ç«ç„°å½¢çŠ¶
                case 'boss_inferno':
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.moveTo(0, -10);
                    ctx.quadraticCurveTo(-6, -3, -5, 5);
                    ctx.quadraticCurveTo(-3, 8, 0, 10);
                    ctx.quadraticCurveTo(3, 8, 5, 5);
                    ctx.quadraticCurveTo(6, -3, 0, -10);
                    ctx.fill();
                    // å†…éƒ¨äº®è‰²
                    ctx.fillStyle = '#fff8';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 2, 4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'boss_petal': // èŠ±ç“£ - èŠ±ç“£å½¢çŠ¶
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 4, 8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // èŠ±ç“£çº¹ç†
                    ctx.strokeStyle = '#fff6';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(0, -6);
                    ctx.lineTo(0, 6);
                    ctx.stroke();
                    break;
                    
                case 'boss_meteor': // æµæ˜Ÿ - å¸¦å°¾è¿¹çš„åœ†å½¢
                    // å°¾è¿¹
                    const meteorGrad = ctx.createLinearGradient(0, -15, 0, 5);
                    meteorGrad.addColorStop(0, 'transparent');
                    meteorGrad.addColorStop(0.5, color + '44');
                    meteorGrad.addColorStop(1, color);
                    ctx.fillStyle = meteorGrad;
                    ctx.beginPath();
                    ctx.moveTo(-4, -15);
                    ctx.lineTo(4, -15);
                    ctx.lineTo(6, 5);
                    ctx.arc(0, 5, 6, 0, Math.PI, false);
                    ctx.lineTo(-6, 5);
                    ctx.closePath();
                    ctx.fill();
                    // æ ¸å¿ƒ
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(0, 3, 3, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'boss_tornado': // é¾™å· - æ—‹æ¶¡å½¢çŠ¶
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    for (let i = 0; i < 20; i++) {
                        const t = i / 20;
                        const angle = t * Math.PI * 3;
                        const r = 2 + t * 6;
                        const x = Math.cos(angle) * r;
                        const y = -8 + t * 16;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                    break;
                    
                case 'boss_homing': // è¿½è¸ª - ç®­å¤´å½¢çŠ¶
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.moveTo(0, -10);
                    ctx.lineTo(-6, 5);
                    ctx.lineTo(-2, 3);
                    ctx.lineTo(-2, 10);
                    ctx.lineTo(2, 10);
                    ctx.lineTo(2, 3);
                    ctx.lineTo(6, 5);
                    ctx.closePath();
                    ctx.fill();
                    // é«˜å…‰
                    ctx.fillStyle = '#fff8';
                    ctx.beginPath();
                    ctx.arc(0, 0, 2, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'boss_tentacle': // è§¦æ‰‹ - æ³¢æµªå½¢
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 5, 8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // è§¦æ‰‹çº¹ç†
                    ctx.strokeStyle = color + 'aa';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, 7, Math.PI * 0.3, Math.PI * 0.7);
                    ctx.stroke();
                    break;
                    
                case 'boss_feather': // ç¾½æ¯› - ç¾½æ¯›å½¢çŠ¶
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.moveTo(0, -10);
                    ctx.quadraticCurveTo(-5, 0, 0, 10);
                    ctx.quadraticCurveTo(5, 0, 0, -10);
                    ctx.fill();
                    // ç¾½æ¯›ä¸­çº¿
                    ctx.strokeStyle = '#fff6';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(0, -8);
                    ctx.lineTo(0, 8);
                    ctx.stroke();
                    break;
                    
                case 'boss_heart': // çˆ±å¿ƒ - å¿ƒå½¢
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.moveTo(0, 4);
                    ctx.bezierCurveTo(-7, -2, -7, -8, 0, -10);
                    ctx.bezierCurveTo(7, -8, 7, -2, 0, 4);
                    ctx.fill();
                    // é«˜å…‰
                    ctx.fillStyle = '#fff6';
                    ctx.beginPath();
                    ctx.arc(-3, -5, 2, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'boss_slash': // æ–©å‡» - åˆ€åˆƒå½¢
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.moveTo(0, -12);
                    ctx.lineTo(-3, 0);
                    ctx.lineTo(0, 12);
                    ctx.lineTo(3, 0);
                    ctx.closePath();
                    ctx.fill();
                    // å…‰æ³½
                    ctx.fillStyle = '#fff8';
                    ctx.beginPath();
                    ctx.moveTo(0, -8);
                    ctx.lineTo(-1, 0);
                    ctx.lineTo(0, 8);
                    ctx.lineTo(1, 0);
                    ctx.closePath();
                    ctx.fill();
                    break;
                    
                case 'boss_thorn': // è†æ£˜ - å°–åˆºå½¢
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.moveTo(0, -8);
                    ctx.lineTo(-4, 2);
                    ctx.lineTo(-2, 2);
                    ctx.lineTo(-2, 8);
                    ctx.lineTo(2, 8);
                    ctx.lineTo(2, 2);
                    ctx.lineTo(4, 2);
                    ctx.closePath();
                    ctx.fill();
                    break;
                    
                case 'boss_cross': // åå­— - åå­—å½¢
                    ctx.fillStyle = color;
                    ctx.fillRect(-2, -8, 4, 16);
                    ctx.fillRect(-8, -2, 16, 4);
                    // ä¸­å¿ƒäº®ç‚¹
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(0, 0, 2, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'boss_random': // æ··æ²Œ - ä¸è§„åˆ™å½¢çŠ¶
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        const r = 5 + (i % 2) * 3;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    break;
                    
                default: // é»˜è®¤Bosså­å¼¹ - å¸¦é¢œè‰²çš„åœ†å½¢
                    const defaultGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 8);
                    defaultGrad.addColorStop(0, '#ffffff');
                    defaultGrad.addColorStop(0.4, color);
                    defaultGrad.addColorStop(1, color + '88');
                    ctx.fillStyle = defaultGrad;
                    ctx.beginPath();
                    ctx.arc(0, 0, 7, 0, Math.PI * 2);
                    ctx.fill();
            }
            
            ctx.shadowBlur = 0;
        }

        // ç»˜åˆ¶å°é±¼åŠ©æ‰‹
        function drawDrones() {
            if (!gameState.droneActive || !drones.length) return;
            drones.forEach(d => {
                const x = player.x + d.offsetX;
                const y = player.y + d.offsetY;
                ctx.save();
                
                // å°é±¼åŠ©æ‰‹ï¼ˆçŸ¢é‡ç»˜åˆ¶ï¼‰
                d.t = (d.t || 0) + 0.1;
                const floatY = Math.sin(d.t) * 3;
                ctx.translate(x, y + floatY);
                
                const sc = 0.7;
                // é±¼èº«ï¼ˆè“è‰²å°é±¼ï¼‰
                const bodyGrad = ctx.createLinearGradient(0, -15 * sc, 0, 15 * sc);
                bodyGrad.addColorStop(0, '#4fc3f7');
                bodyGrad.addColorStop(0.5, '#03a9f4');
                bodyGrad.addColorStop(1, '#0288d1');
                ctx.fillStyle = bodyGrad;
                ctx.beginPath();
                ctx.ellipse(0, 0, 14 * sc, 20 * sc, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // é±¼å°¾
                ctx.beginPath();
                ctx.moveTo(0, 16 * sc);
                ctx.lineTo(-9 * sc, 26 * sc);
                ctx.lineTo(0, 20 * sc);
                ctx.lineTo(9 * sc, 26 * sc);
                ctx.closePath();
                ctx.fill();
                
                // èƒŒé³•
                ctx.beginPath();
                ctx.moveTo(0, -18 * sc);
                ctx.lineTo(-6 * sc, -24 * sc);
                ctx.lineTo(6 * sc, -24 * sc);
                ctx.closePath();
                ctx.fill();
                
                // ä¾§é³•
                ctx.beginPath();
                ctx.moveTo(-12 * sc, 0);
                ctx.lineTo(-20 * sc, 5 * sc);
                ctx.lineTo(-12 * sc, 3 * sc);
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(12 * sc, 0);
                ctx.lineTo(20 * sc, 5 * sc);
                ctx.lineTo(12 * sc, 3 * sc);
                ctx.closePath();
                ctx.fill();
                
                // çœ¼ç›
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(-5 * sc, -7 * sc, 4 * sc, 0, Math.PI * 2);
                ctx.arc(5 * sc, -7 * sc, 4 * sc, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#222';
                ctx.beginPath();
                ctx.arc(-5 * sc, -7 * sc, 2 * sc, 0, Math.PI * 2);
                ctx.arc(5 * sc, -7 * sc, 2 * sc, 0, Math.PI * 2);
                ctx.fill();
                
                // â€œèªä»”â€æ–‡å­—
                ctx.fillStyle = '#fff';
                ctx.font = `bold ${8 * sc}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('èªä»”', 0, 3 * sc);
                
                ctx.restore();
            });
        }

        // ç»˜åˆ¶æ•Œäººé±¼ï¼ˆæ ¹æ®ç±»å‹ç»˜åˆ¶ä¸åŒé€ å‹ï¼‰
        function drawEnemySmall(enemy) {
            const type = enemy.type || 'normal';
            switch(type) {
                case 'fast':
                    drawEnemyFast(enemy);
                    break;
                case 'tank':
                    drawEnemyTank(enemy);
                    break;
                case 'sniper':
                    drawEnemySniper(enemy);
                    break;
                case 'splitter':
                    drawEnemySplitter(enemy);
                    break;
                case 'mini':
                    drawEnemyMini(enemy);
                    break;
                case 'bomber':
                    drawEnemyBomber(enemy);
                    break;
                case 'shield':
                    drawEnemyShield(enemy);
                    break;
                case 'healer':
                    drawEnemyHealer(enemy);
                    break;
                case 'swarm':
                    drawEnemySwarm(enemy);
                    break;
                default:
                    drawEnemyNormal(enemy);
            }
        }
        
        // æ™®é€šé±¼ - åœ†æ¶¦çš„å°ä¸‘é±¼é€ å‹
        function drawEnemyNormal(enemy) {
            const s = Math.max(0.9, (enemy.width || 40) / 40);
            const colors = enemy.colors || ['#70a1ff', '#1e90ff', '#3742fa'];
            const isHit = enemy.hitFlash && enemy.hitFlash > 0;
            
            enemy.animTime = (enemy.animTime || Math.random() * 100) + 0.15;
            const swimWave = Math.sin(enemy.animTime) * 0.1;
            const breathe = 1 + Math.sin(enemy.animTime * 0.5) * 0.03;
            
            ctx.shadowColor = colors[0];
            ctx.shadowBlur = 10;
            
            const bodyGrad = ctx.createRadialGradient(0, -5 * s, 0, 0, 0, 22 * s);
            if (isHit) {
                bodyGrad.addColorStop(0, '#ffffff');
                bodyGrad.addColorStop(0.5, '#ffeeee');
                bodyGrad.addColorStop(1, '#ffcccc');
            } else {
                bodyGrad.addColorStop(0, colors[0]);
                bodyGrad.addColorStop(0.4, colors[1]);
                bodyGrad.addColorStop(1, colors[2]);
            }
            
            // é±¼å°¾
            ctx.save();
            ctx.rotate(swimWave);
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.moveTo(0, 16 * s);
            ctx.quadraticCurveTo(-8 * s, 22 * s, -12 * s, 30 * s);
            ctx.quadraticCurveTo(0, 26 * s, 12 * s, 30 * s);
            ctx.quadraticCurveTo(8 * s, 22 * s, 0, 16 * s);
            ctx.fill();
            ctx.restore();
            
            // é±¼èº«
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.ellipse(0, 0, 14 * s * breathe, 20 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // æ¡çº¹
            ctx.strokeStyle = isHit ? 'rgba(255,255,255,0.5)' : 'rgba(255,255,255,0.4)';
            ctx.lineWidth = 3 * s;
            ctx.beginPath();
            ctx.moveTo(-10 * s, -5 * s);
            ctx.lineTo(10 * s, -5 * s);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(-8 * s, 5 * s);
            ctx.lineTo(8 * s, 5 * s);
            ctx.stroke();
            
            // ä¾§é³
            const finWave = Math.sin(enemy.animTime * 1.5) * 0.2;
            ctx.fillStyle = bodyGrad;
            ctx.save();
            ctx.translate(-12 * s, 2 * s);
            ctx.rotate(-0.3 + finWave);
            ctx.beginPath();
            ctx.ellipse(0, 0, 10 * s, 4 * s, -0.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            ctx.save();
            ctx.translate(12 * s, 2 * s);
            ctx.rotate(0.3 - finWave);
            ctx.beginPath();
            ctx.ellipse(0, 0, 10 * s, 4 * s, 0.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            // çœ¼ç›
            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 0;
            ctx.beginPath();
            ctx.arc(-5 * s, -8 * s, 5 * s, 0, Math.PI * 2);
            ctx.arc(5 * s, -8 * s, 5 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#1a1a2e';
            ctx.beginPath();
            ctx.arc(-5 * s, -7.5 * s, 2.5 * s, 0, Math.PI * 2);
            ctx.arc(5 * s, -7.5 * s, 2.5 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-6 * s, -9 * s, 1.2 * s, 0, Math.PI * 2);
            ctx.arc(4 * s, -9 * s, 1.2 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // å˜´å·´
            ctx.strokeStyle = isHit ? '#faa' : colors[2];
            ctx.lineWidth = 1.5 * s;
            ctx.beginPath();
            ctx.arc(0, -14 * s, 3 * s, 0.2 * Math.PI, 0.8 * Math.PI);
            ctx.stroke();
        }
        
        // å¿«é€Ÿé±¼ - æµçº¿å‹æ——é±¼é€ å‹ï¼Œå°–é”çš„å˜´
        function drawEnemyFast(enemy) {
            const s = Math.max(0.9, (enemy.width || 35) / 35);
            const colors = enemy.colors || ['#00d2d3', '#01a3a4', '#006266'];
            const isHit = enemy.hitFlash && enemy.hitFlash > 0;
            
            enemy.animTime = (enemy.animTime || Math.random() * 100) + 0.25; // æ›´å¿«çš„åŠ¨ç”»
            const swimWave = Math.sin(enemy.animTime) * 0.15;
            
            ctx.shadowColor = colors[0];
            ctx.shadowBlur = 12;
            
            const bodyGrad = ctx.createLinearGradient(0, -25 * s, 0, 25 * s);
            if (isHit) {
                bodyGrad.addColorStop(0, '#ffffff');
                bodyGrad.addColorStop(1, '#ffcccc');
            } else {
                bodyGrad.addColorStop(0, colors[0]);
                bodyGrad.addColorStop(0.5, colors[1]);
                bodyGrad.addColorStop(1, colors[2]);
            }
            
            // å°–é”çš„é•¿å˜´ï¼ˆæ——é±¼ç‰¹å¾ï¼‰
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.moveTo(0, -28 * s);
            ctx.lineTo(-3 * s, -15 * s);
            ctx.lineTo(3 * s, -15 * s);
            ctx.closePath();
            ctx.fill();
            
            // æµçº¿å‹èº«ä½“
            ctx.beginPath();
            ctx.moveTo(0, -15 * s);
            ctx.quadraticCurveTo(-12 * s, 0, -8 * s, 18 * s);
            ctx.quadraticCurveTo(0, 22 * s, 8 * s, 18 * s);
            ctx.quadraticCurveTo(12 * s, 0, 0, -15 * s);
            ctx.fill();
            
            // é€Ÿåº¦çº¿æ¡ï¼ˆæµçº¿çº¹ï¼‰
            ctx.strokeStyle = isHit ? 'rgba(255,255,255,0.6)' : 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 1.5 * s;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.moveTo(-8 * s + i * 4 * s, -5 * s + i * 4 * s);
                ctx.lineTo(-8 * s + i * 4 * s, 10 * s + i * 2 * s);
                ctx.stroke();
            }
            
            // åˆ†å‰å°¾é³ï¼ˆå¿«é€Ÿæ¨è¿›ï¼‰
            ctx.save();
            ctx.rotate(swimWave);
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.moveTo(0, 18 * s);
            ctx.lineTo(-10 * s, 32 * s);
            ctx.lineTo(-2 * s, 24 * s);
            ctx.lineTo(0, 28 * s);
            ctx.lineTo(2 * s, 24 * s);
            ctx.lineTo(10 * s, 32 * s);
            ctx.lineTo(0, 18 * s);
            ctx.fill();
            ctx.restore();
            
            // èƒŒé³ï¼ˆé«˜è€¸ï¼‰
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.moveTo(0, -10 * s);
            ctx.lineTo(-2 * s, -20 * s);
            ctx.quadraticCurveTo(0, -22 * s, 2 * s, -15 * s);
            ctx.closePath();
            ctx.fill();
            
            // çœ¼ç›ï¼ˆè¾ƒå°ï¼Œå‡¶ç‹ ï¼‰
            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 0;
            ctx.beginPath();
            ctx.ellipse(-4 * s, -8 * s, 3.5 * s, 3 * s, -0.2, 0, Math.PI * 2);
            ctx.ellipse(4 * s, -8 * s, 3.5 * s, 3 * s, 0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#1a1a2e';
            ctx.beginPath();
            ctx.arc(-4 * s, -8 * s, 2 * s, 0, Math.PI * 2);
            ctx.arc(4 * s, -8 * s, 2 * s, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // å¦å…‹é±¼ - æ²³è±šé€ å‹ï¼Œåœ†èƒ–å¸¦åˆº
        function drawEnemyTank(enemy) {
            const s = Math.max(1, (enemy.width || 50) / 50);
            const colors = enemy.colors || ['#ffeaa7', '#fdcb6e', '#e17055'];
            const isHit = enemy.hitFlash && enemy.hitFlash > 0;
            
            enemy.animTime = (enemy.animTime || Math.random() * 100) + 0.1; // æ…¢é€ŸåŠ¨ç”»
            const puff = 1 + Math.sin(enemy.animTime * 0.8) * 0.08; // è†¨èƒ€æ•ˆæœ
            
            ctx.shadowColor = colors[0];
            ctx.shadowBlur = 15;
            
            const bodyGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 25 * s);
            if (isHit) {
                bodyGrad.addColorStop(0, '#ffffff');
                bodyGrad.addColorStop(1, '#ffcccc');
            } else {
                bodyGrad.addColorStop(0, colors[0]);
                bodyGrad.addColorStop(0.6, colors[1]);
                bodyGrad.addColorStop(1, colors[2]);
            }
            
            // åœ†èƒ–èº«ä½“
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.arc(0, 0, 22 * s * puff, 0, Math.PI * 2);
            ctx.fill();
            
            // å°–åˆºï¼ˆæ²³è±šç‰¹å¾ï¼‰
            const spikeColor = isHit ? '#ffaaaa' : colors[2];
            ctx.fillStyle = spikeColor;
            const spikeCount = 12;
            for (let i = 0; i < spikeCount; i++) {
                const angle = (i / spikeCount) * Math.PI * 2;
                const baseR = 20 * s * puff;
                const spikeLen = 8 * s;
                ctx.save();
                ctx.translate(Math.cos(angle) * baseR, Math.sin(angle) * baseR);
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.moveTo(0, -3 * s);
                ctx.lineTo(spikeLen, 0);
                ctx.lineTo(0, 3 * s);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
            
            // å°å°¾å·´
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.moveTo(0, 20 * s);
            ctx.quadraticCurveTo(-5 * s, 28 * s, -3 * s, 32 * s);
            ctx.quadraticCurveTo(0, 30 * s, 3 * s, 32 * s);
            ctx.quadraticCurveTo(5 * s, 28 * s, 0, 20 * s);
            ctx.fill();
            
            // è…¹éƒ¨ï¼ˆæµ…è‰²ï¼‰
            ctx.fillStyle = isHit ? 'rgba(255,255,255,0.7)' : 'rgba(255,255,255,0.5)';
            ctx.beginPath();
            ctx.ellipse(0, 5 * s, 12 * s * puff, 10 * s * puff, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // å¤§çœ¼ç›ï¼ˆå¯çˆ±ä½†å‡¶ç‹ ï¼‰
            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 0;
            ctx.beginPath();
            ctx.arc(-8 * s, -5 * s, 7 * s, 0, Math.PI * 2);
            ctx.arc(8 * s, -5 * s, 7 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#1a1a2e';
            ctx.beginPath();
            ctx.arc(-8 * s, -4 * s, 4 * s, 0, Math.PI * 2);
            ctx.arc(8 * s, -4 * s, 4 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-10 * s, -6 * s, 2 * s, 0, Math.PI * 2);
            ctx.arc(6 * s, -6 * s, 2 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // å˜Ÿå˜´
            ctx.fillStyle = isHit ? '#ffaaaa' : '#e17055';
            ctx.beginPath();
            ctx.ellipse(0, -15 * s, 5 * s, 3 * s, 0, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // ç‹™å‡»é±¼ - ç¯ç¬¼é±¼é€ å‹ï¼Œå¤´é¡¶å‘å…‰è¯±é¥µ
        function drawEnemySniper(enemy) {
            const s = Math.max(0.9, (enemy.width || 40) / 40);
            const colors = enemy.colors || ['#2d3436', '#636e72', '#b2bec3'];
            const isHit = enemy.hitFlash && enemy.hitFlash > 0;
            
            enemy.animTime = (enemy.animTime || Math.random() * 100) + 0.12;
            const glowPulse = 0.7 + Math.sin(enemy.animTime * 2) * 0.3; // å‘å…‰è„‰å†²
            
            ctx.shadowColor = '#00ff88';
            ctx.shadowBlur = 20 * glowPulse;
            
            // å¤´é¡¶å‘å…‰è¯±é¥µï¼ˆç¯ç¬¼é±¼ç‰¹å¾ï¼‰
            ctx.strokeStyle = isHit ? '#ffaaaa' : colors[1];
            ctx.lineWidth = 2 * s;
            ctx.beginPath();
            ctx.moveTo(0, -18 * s);
            ctx.quadraticCurveTo(-5 * s, -28 * s, 0, -35 * s);
            ctx.stroke();
            
            // å‘å…‰çƒ
            const glowGrad = ctx.createRadialGradient(0, -38 * s, 0, 0, -38 * s, 8 * s);
            glowGrad.addColorStop(0, isHit ? '#ffffff' : '#00ff88');
            glowGrad.addColorStop(0.5, isHit ? '#ffcccc' : '#00cc66');
            glowGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = glowGrad;
            ctx.beginPath();
            ctx.arc(0, -38 * s, 8 * s * glowPulse, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.shadowColor = colors[0];
            ctx.shadowBlur = 8;
            
            const bodyGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 20 * s);
            if (isHit) {
                bodyGrad.addColorStop(0, '#ffffff');
                bodyGrad.addColorStop(1, '#ffcccc');
            } else {
                bodyGrad.addColorStop(0, colors[2]);
                bodyGrad.addColorStop(0.5, colors[1]);
                bodyGrad.addColorStop(1, colors[0]);
            }
            
            // æ·±æµ·é±¼èº«ä½“ï¼ˆæš—è‰²è°ƒï¼‰
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.ellipse(0, 0, 14 * s, 18 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // å¤§å˜´ï¼ˆç ç‰™ï¼‰
            ctx.fillStyle = '#1a1a2e';
            ctx.beginPath();
            ctx.ellipse(0, -12 * s, 10 * s, 6 * s, 0, 0, Math.PI);
            ctx.fill();
            
            // å°–ç‰™
            ctx.fillStyle = '#fff';
            for (let i = -3; i <= 3; i++) {
                ctx.beginPath();
                ctx.moveTo(i * 2.5 * s, -12 * s);
                ctx.lineTo(i * 2.5 * s - 1 * s, -8 * s);
                ctx.lineTo(i * 2.5 * s + 1 * s, -8 * s);
                ctx.closePath();
                ctx.fill();
            }
            
            // å°å°¾å·´
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.moveTo(-5 * s, 16 * s);
            ctx.quadraticCurveTo(-8 * s, 25 * s, -4 * s, 28 * s);
            ctx.lineTo(4 * s, 28 * s);
            ctx.quadraticCurveTo(8 * s, 25 * s, 5 * s, 16 * s);
            ctx.fill();
            
            // å°çœ¼ç›ï¼ˆæ·±æµ·é±¼çœ¼ç›å°ï¼‰
            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 0;
            ctx.beginPath();
            ctx.arc(-6 * s, -2 * s, 3 * s, 0, Math.PI * 2);
            ctx.arc(6 * s, -2 * s, 3 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ff0000'; // çº¢è‰²çœ¼ç 
            ctx.beginPath();
            ctx.arc(-6 * s, -2 * s, 1.5 * s, 0, Math.PI * 2);
            ctx.arc(6 * s, -2 * s, 1.5 * s, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // åˆ†è£‚é±¼ - æ°´æ¯é€ å‹ï¼Œé€æ˜ä¼çŠ¶
        function drawEnemySplitter(enemy) {
            const s = Math.max(0.9, (enemy.width || 45) / 45);
            const colors = enemy.colors || ['#a29bfe', '#6c5ce7', '#4834d4'];
            const isHit = enemy.hitFlash && enemy.hitFlash > 0;
            
            enemy.animTime = (enemy.animTime || Math.random() * 100) + 0.1;
            const pulse = 1 + Math.sin(enemy.animTime) * 0.1; // æ”¶ç¼©æ•ˆæœ
            const tentacleWave = Math.sin(enemy.animTime * 0.8);
            
            // é€æ˜ä¼çŠ¶èº«ä½“
            ctx.shadowColor = colors[0];
            ctx.shadowBlur = 15;
            
            const bodyGrad = ctx.createRadialGradient(0, -5 * s, 0, 0, 5 * s, 25 * s);
            if (isHit) {
                bodyGrad.addColorStop(0, 'rgba(255,255,255,0.9)');
                bodyGrad.addColorStop(1, 'rgba(255,200,200,0.4)');
            } else {
                bodyGrad.addColorStop(0, colors[0] + 'cc');
                bodyGrad.addColorStop(0.5, colors[1] + '99');
                bodyGrad.addColorStop(1, colors[2] + '44');
            }
            
            // ä¼çŠ¶å¤´éƒ¨
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.arc(0, 0, 18 * s * pulse, Math.PI, 0, false);
            ctx.quadraticCurveTo(20 * s * pulse, 10 * s, 15 * s * pulse, 15 * s);
            ctx.lineTo(-15 * s * pulse, 15 * s);
            ctx.quadraticCurveTo(-20 * s * pulse, 10 * s, -18 * s * pulse, 0);
            ctx.fill();
            
            // å†…éƒ¨çº¹ç†
            ctx.strokeStyle = isHit ? 'rgba(255,255,255,0.5)' : 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 1.5 * s;
            for (let i = 0; i < 4; i++) {
                const r = (5 + i * 4) * s * pulse;
                ctx.beginPath();
                ctx.arc(0, 2 * s, r, Math.PI * 1.1, Math.PI * 1.9);
                ctx.stroke();
            }
            
            // è§¦æ‰‹ï¼ˆé£˜åŠ¨ï¼‰
            ctx.strokeStyle = bodyGrad;
            ctx.lineWidth = 3 * s;
            ctx.lineCap = 'round';
            const tentacles = 5;
            for (let i = 0; i < tentacles; i++) {
                const baseX = -12 * s + i * 6 * s;
                const waveOffset = i * 0.5;
                ctx.beginPath();
                ctx.moveTo(baseX, 15 * s);
                ctx.quadraticCurveTo(
                    baseX + Math.sin(enemy.animTime + waveOffset) * 8 * s,
                    25 * s,
                    baseX + Math.sin(enemy.animTime * 1.5 + waveOffset) * 12 * s,
                    38 * s
                );
                ctx.stroke();
            }
            
            // å‘å…‰æ ¸å¿ƒ
            ctx.shadowBlur = 0;
            const coreGrad = ctx.createRadialGradient(0, 3 * s, 0, 0, 3 * s, 8 * s);
            coreGrad.addColorStop(0, isHit ? '#ffffff' : '#ffffff');
            coreGrad.addColorStop(0.5, isHit ? '#ffcccc' : colors[0]);
            coreGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = coreGrad;
            ctx.beginPath();
            ctx.arc(0, 3 * s, 8 * s, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // è¿·ä½ é±¼ - å°é±¼ç¾¤ä¸­çš„ä¸€æ¡ï¼Œç®€å•åœ†å½¢
        function drawEnemyMini(enemy) {
            const s = Math.max(0.7, (enemy.width || 25) / 25);
            const colors = enemy.colors || ['#ff7675', '#d63031', '#b71540'];
            const isHit = enemy.hitFlash && enemy.hitFlash > 0;
            
            enemy.animTime = (enemy.animTime || Math.random() * 100) + 0.2;
            const wiggle = Math.sin(enemy.animTime * 2) * 0.2; // å¿«é€Ÿæ‘†åŠ¨
            
            ctx.shadowColor = colors[0];
            ctx.shadowBlur = 8;
            
            const bodyGrad = ctx.createRadialGradient(-2 * s, -2 * s, 0, 0, 0, 12 * s);
            if (isHit) {
                bodyGrad.addColorStop(0, '#ffffff');
                bodyGrad.addColorStop(1, '#ffcccc');
            } else {
                bodyGrad.addColorStop(0, colors[0]);
                bodyGrad.addColorStop(0.5, colors[1]);
                bodyGrad.addColorStop(1, colors[2]);
            }
            
            // å°åœ†èº«ä½“
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.ellipse(0, 0, 10 * s, 8 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // å°å°¾å·´ï¼ˆå¿«é€Ÿæ‘†åŠ¨ï¼‰
            ctx.save();
            ctx.rotate(wiggle);
            ctx.beginPath();
            ctx.moveTo(0, 7 * s);
            ctx.lineTo(-6 * s, 15 * s);
            ctx.lineTo(0, 12 * s);
            ctx.lineTo(6 * s, 15 * s);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            
            // å°èƒŒé³
            ctx.beginPath();
            ctx.moveTo(-3 * s, -6 * s);
            ctx.lineTo(0, -12 * s);
            ctx.lineTo(3 * s, -6 * s);
            ctx.closePath();
            ctx.fill();
            
            // å¤§çœ¼ç›ï¼ˆç›¸å¯¹èº«ä½“å¾ˆå¤§ï¼Œæ˜¾å¾—å¯çˆ±ï¼‰
            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 0;
            ctx.beginPath();
            ctx.arc(-3 * s, -1 * s, 4 * s, 0, Math.PI * 2);
            ctx.arc(3 * s, -1 * s, 4 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#1a1a2e';
            ctx.beginPath();
            ctx.arc(-3 * s, 0, 2 * s, 0, Math.PI * 2);
            ctx.arc(3 * s, 0, 2 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-4 * s, -2 * s, 1 * s, 0, Math.PI * 2);
            ctx.arc(2 * s, -2 * s, 1 * s, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // è½°ç‚¸é±¼ - é¹ˆé¹Šé±¼é€ å‹ï¼Œå¤§å˜´è¢‹ï¼Œè‚¥èƒ–èº«ä½“
        function drawEnemyBomber(enemy) {
            const s = Math.max(1, (enemy.width || 48) / 48);
            const colors = enemy.colors || ['#636e72', '#2d3436', '#1a1a2e'];
            const isHit = enemy.hitFlash && enemy.hitFlash > 0;
            
            enemy.animTime = (enemy.animTime || Math.random() * 100) + 0.12;
            const swimWave = Math.sin(enemy.animTime) * 0.1;
            const pouchWave = Math.sin(enemy.animTime * 2) * 0.05; // å˜´è¢‹å¼ åˆ
            
            ctx.shadowColor = colors[0];
            ctx.shadowBlur = 12;
            
            const bodyGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 25 * s);
            if (isHit) {
                bodyGrad.addColorStop(0, '#ffffff');
                bodyGrad.addColorStop(1, '#ffcccc');
            } else {
                bodyGrad.addColorStop(0, colors[0]);
                bodyGrad.addColorStop(0.6, colors[1]);
                bodyGrad.addColorStop(1, colors[2]);
            }
            
            // é±¼å°¾
            ctx.save();
            ctx.rotate(swimWave);
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.moveTo(0, 18 * s);
            ctx.lineTo(-10 * s, 30 * s);
            ctx.lineTo(0, 25 * s);
            ctx.lineTo(10 * s, 30 * s);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            
            // èº«ä½“ï¼ˆåœ†èƒ–ï¼‰
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.ellipse(0, 0, 18 * s, 22 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // å¤§å˜´è¢‹ï¼ˆé¹ˆé¹Šç‰¹å¾ï¼‰
            const pouchSize = 1 + pouchWave;
            ctx.fillStyle = isHit ? '#ffcccc' : '#4a4a4a';
            ctx.beginPath();
            ctx.ellipse(0, -20 * s, 12 * s * pouchSize, 10 * s * pouchSize, 0, 0, Math.PI);
            ctx.fill();
            
            // å˜´è¢‹å†…éƒ¨ï¼ˆæ·±è‰²ï¼‰
            ctx.fillStyle = isHit ? '#ffaaaa' : '#2d3436';
            ctx.beginPath();
            ctx.ellipse(0, -18 * s, 8 * s * pouchSize, 6 * s * pouchSize, 0, 0, Math.PI);
            ctx.fill();
            
            // ç¿…è†€
            ctx.fillStyle = bodyGrad;
            ctx.save();
            ctx.translate(-16 * s, 0);
            ctx.rotate(-0.3 + swimWave * 0.5);
            ctx.beginPath();
            ctx.ellipse(0, 0, 12 * s, 5 * s, -0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            ctx.save();
            ctx.translate(16 * s, 0);
            ctx.rotate(0.3 - swimWave * 0.5);
            ctx.beginPath();
            ctx.ellipse(0, 0, 12 * s, 5 * s, 0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            // çœ‰æ¯›ï¼ˆå‡¶æ‚¶ï¼‰
            ctx.strokeStyle = isHit ? '#ffaaaa' : colors[2];
            ctx.lineWidth = 2 * s;
            ctx.beginPath();
            ctx.moveTo(-10 * s, -8 * s);
            ctx.lineTo(-4 * s, -5 * s);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(10 * s, -8 * s);
            ctx.lineTo(4 * s, -5 * s);
            ctx.stroke();
            
            // å°çœ¼ç›
            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 0;
            ctx.beginPath();
            ctx.arc(-6 * s, -3 * s, 4 * s, 0, Math.PI * 2);
            ctx.arc(6 * s, -3 * s, 4 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#1a1a2e';
            ctx.beginPath();
            ctx.arc(-6 * s, -2 * s, 2.5 * s, 0, Math.PI * 2);
            ctx.arc(6 * s, -2 * s, 2.5 * s, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // æŠ¤ç›¾é±¼ - åˆ¶é³ƒé€ å‹ï¼Œæ‰å¹³èº«ä½“å¸¦ç”µå…‰æŠ¤ç›¾
        function drawEnemyShield(enemy) {
            const s = Math.max(1, (enemy.width || 45) / 45);
            const colors = enemy.colors || ['#00d2ff', '#0088ff', '#0055aa'];
            const isHit = enemy.hitFlash && enemy.hitFlash > 0;
            const hasShield = enemy.shieldHp > 0;
            
            enemy.animTime = (enemy.animTime || Math.random() * 100) + 0.15;
            const wingWave = Math.sin(enemy.animTime) * 0.15;
            const shieldPulse = 0.9 + Math.sin(enemy.animTime * 3) * 0.1;
            
            ctx.shadowColor = hasShield ? '#00d2ff' : colors[0];
            ctx.shadowBlur = hasShield ? 20 : 10;
            
            const bodyGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 25 * s);
            if (isHit) {
                bodyGrad.addColorStop(0, '#ffffff');
                bodyGrad.addColorStop(1, '#ffcccc');
            } else {
                bodyGrad.addColorStop(0, colors[0]);
                bodyGrad.addColorStop(0.5, colors[1]);
                bodyGrad.addColorStop(1, colors[2]);
            }
            
            // ç¿…è†€ï¼ˆåˆ¶é³ƒç‰¹å¾ï¼‰
            ctx.fillStyle = bodyGrad;
            ctx.save();
            ctx.rotate(wingWave);
            // å·¦ç¿…
            ctx.beginPath();
            ctx.moveTo(-5 * s, 0);
            ctx.quadraticCurveTo(-30 * s, -15 * s, -35 * s, 5 * s);
            ctx.quadraticCurveTo(-20 * s, 10 * s, -5 * s, 5 * s);
            ctx.fill();
            // å³ç¿…
            ctx.beginPath();
            ctx.moveTo(5 * s, 0);
            ctx.quadraticCurveTo(30 * s, -15 * s, 35 * s, 5 * s);
            ctx.quadraticCurveTo(20 * s, 10 * s, 5 * s, 5 * s);
            ctx.fill();
            ctx.restore();
            
            // èº«ä½“ï¼ˆæ‰å¹³è±å½¢ï¼‰
            ctx.beginPath();
            ctx.moveTo(0, -18 * s);
            ctx.quadraticCurveTo(-12 * s, 0, 0, 22 * s);
            ctx.quadraticCurveTo(12 * s, 0, 0, -18 * s);
            ctx.fill();
            
            // å°¾å·´
            ctx.beginPath();
            ctx.moveTo(0, 20 * s);
            ctx.lineTo(-3 * s, 35 * s);
            ctx.lineTo(0, 30 * s);
            ctx.lineTo(3 * s, 35 * s);
            ctx.closePath();
            ctx.fill();
            
            // ç”µå…‰æŠ¤ç›¾
            if (hasShield) {
                const shieldGrad = ctx.createRadialGradient(0, 0, 15 * s, 0, 0, 35 * s * shieldPulse);
                shieldGrad.addColorStop(0, 'rgba(0, 210, 255, 0)');
                shieldGrad.addColorStop(0.5, 'rgba(0, 210, 255, 0.3)');
                shieldGrad.addColorStop(1, 'rgba(0, 136, 255, 0.1)');
                ctx.fillStyle = shieldGrad;
                ctx.beginPath();
                ctx.ellipse(0, 0, 35 * s * shieldPulse, 30 * s * shieldPulse, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // ç”µå¼§æ•ˆæœ
                ctx.strokeStyle = 'rgba(0, 210, 255, 0.6)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 6; i++) {
                    const angle = (enemy.animTime + i * 1.05) % (Math.PI * 2);
                    const r = 28 * s * shieldPulse;
                    ctx.beginPath();
                    ctx.arc(Math.cos(angle) * r, Math.sin(angle) * r, 3, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            
            // çœ¼ç›
            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 0;
            ctx.beginPath();
            ctx.arc(-5 * s, -5 * s, 4 * s, 0, Math.PI * 2);
            ctx.arc(5 * s, -5 * s, 4 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#1a1a2e';
            ctx.beginPath();
            ctx.arc(-5 * s, -4 * s, 2 * s, 0, Math.PI * 2);
            ctx.arc(5 * s, -4 * s, 2 * s, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // æ²»æ„ˆé±¼ - æµ·é©¬é€ å‹ï¼Œç»¿è‰²å…‰ç¯
        function drawEnemyHealer(enemy) {
            const s = Math.max(1, (enemy.width || 35) / 35);
            const colors = enemy.colors || ['#2ecc71', '#27ae60', '#1e8449'];
            const isHit = enemy.hitFlash && enemy.hitFlash > 0;
            const isHealing = enemy.healCooldown <= 30; // æ²»æ„ˆæ—¶å‘å…‰
            
            enemy.animTime = (enemy.animTime || Math.random() * 100) + 0.18;
            const bodyWave = Math.sin(enemy.animTime) * 0.08;
            const tailCurl = Math.sin(enemy.animTime * 1.5) * 0.2;
            
            ctx.shadowColor = isHealing ? '#2ecc71' : colors[0];
            ctx.shadowBlur = isHealing ? 25 : 10;
            
            const bodyGrad = ctx.createLinearGradient(0, -25 * s, 0, 25 * s);
            if (isHit) {
                bodyGrad.addColorStop(0, '#ffffff');
                bodyGrad.addColorStop(1, '#ffcccc');
            } else {
                bodyGrad.addColorStop(0, colors[0]);
                bodyGrad.addColorStop(0.5, colors[1]);
                bodyGrad.addColorStop(1, colors[2]);
            }
            
            // å·æ›²å°¾å·´ï¼ˆæµ·é©¬ç‰¹å¾ï¼‰
            ctx.save();
            ctx.translate(0, 20 * s);
            ctx.rotate(tailCurl);
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(8 * s, 10 * s, 5 * s, 20 * s);
            ctx.quadraticCurveTo(0, 25 * s, -5 * s, 20 * s);
            ctx.quadraticCurveTo(-3 * s, 10 * s, 0, 0);
            ctx.fill();
            ctx.restore();
            
            // èº«ä½“ï¼ˆSå½¢æ›²çº¿ï¼‰
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.moveTo(0, -22 * s);
            ctx.bezierCurveTo(-10 * s, -15 * s, -8 * s, 0, -6 * s, 10 * s);
            ctx.bezierCurveTo(-4 * s, 18 * s, 4 * s, 18 * s, 6 * s, 10 * s);
            ctx.bezierCurveTo(8 * s, 0, 10 * s, -15 * s, 0, -22 * s);
            ctx.fill();
            
            // é©¬é¢ï¼ˆé©¬å¤´å½¢ï¼‰
            ctx.beginPath();
            ctx.moveTo(0, -22 * s);
            ctx.quadraticCurveTo(-3 * s, -30 * s, 0, -35 * s);
            ctx.quadraticCurveTo(3 * s, -30 * s, 0, -22 * s);
            ctx.fill();
            
            // èƒŒé³‘ï¼ˆå°åˆºï¼‰
            ctx.fillStyle = isHit ? '#ffaaaa' : colors[1];
            for (let i = 0; i < 5; i++) {
                const y = -15 * s + i * 6 * s;
                ctx.beginPath();
                ctx.moveTo(-6 * s, y);
                ctx.lineTo(-10 * s, y - 3 * s);
                ctx.lineTo(-6 * s, y + 2 * s);
                ctx.closePath();
                ctx.fill();
            }
            
            // æ²»æ„ˆå…‰ç¯
            if (isHealing) {
                const healGrad = ctx.createRadialGradient(0, 0, 10 * s, 0, 0, 40 * s);
                healGrad.addColorStop(0, 'rgba(46, 204, 113, 0.4)');
                healGrad.addColorStop(0.5, 'rgba(46, 204, 113, 0.2)');
                healGrad.addColorStop(1, 'rgba(46, 204, 113, 0)');
                ctx.fillStyle = healGrad;
                ctx.beginPath();
                ctx.arc(0, 0, 40 * s, 0, Math.PI * 2);
                ctx.fill();
                
                // æ²»æ„ˆç¬¦å·
                ctx.fillStyle = '#2ecc71';
                ctx.fillRect(-8 * s, -2 * s, 16 * s, 4 * s);
                ctx.fillRect(-2 * s, -8 * s, 4 * s, 16 * s);
            }
            
            // çœ¼ç›
            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 0;
            ctx.beginPath();
            ctx.arc(-3 * s, -25 * s, 3 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#1a1a2e';
            ctx.beginPath();
            ctx.arc(-3 * s, -24 * s, 1.5 * s, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // èœ‚ç¾¤é±¼ - å°å‹ç¾¤æ¸¸é±¼ï¼Œç®€å•é±¼å½¢ä½†æœ‰å…‰æ–‘
        function drawEnemySwarm(enemy) {
            const s = Math.max(0.7, (enemy.width || 22) / 22);
            const colors = enemy.colors || ['#74b9ff', '#0984e3', '#0652dd'];
            const isHit = enemy.hitFlash && enemy.hitFlash > 0;
            
            enemy.animTime = (enemy.animTime || Math.random() * 100) + 0.25; // å¿«é€ŸåŠ¨ç”»
            const wiggle = Math.sin(enemy.animTime * 3) * 0.25;
            const glitter = Math.sin(enemy.animTime * 5) * 0.3 + 0.7; // é—ªçƒæ•ˆæœ
            
            ctx.shadowColor = colors[0];
            ctx.shadowBlur = 6;
            
            const bodyGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 10 * s);
            if (isHit) {
                bodyGrad.addColorStop(0, '#ffffff');
                bodyGrad.addColorStop(1, '#ffcccc');
            } else {
                bodyGrad.addColorStop(0, colors[0]);
                bodyGrad.addColorStop(0.5, colors[1]);
                bodyGrad.addColorStop(1, colors[2]);
            }
            
            // å°å°¾å·´ï¼ˆå¿«é€Ÿæ‘†åŠ¨ï¼‰
            ctx.save();
            ctx.rotate(wiggle);
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.moveTo(0, 6 * s);
            ctx.lineTo(-5 * s, 14 * s);
            ctx.lineTo(0, 10 * s);
            ctx.lineTo(5 * s, 14 * s);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            
            // æµçº¿å½¢èº«ä½“
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.moveTo(0, -10 * s);
            ctx.quadraticCurveTo(-7 * s, 0, 0, 8 * s);
            ctx.quadraticCurveTo(7 * s, 0, 0, -10 * s);
            ctx.fill();
            
            // é—ªå…‰é³ç‰‡
            ctx.fillStyle = `rgba(255, 255, 255, ${glitter * 0.6})`;
            ctx.beginPath();
            ctx.arc(-2 * s, -2 * s, 2 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(2 * s, 2 * s, 1.5 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // å°çœ¼ç›
            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 0;
            ctx.beginPath();
            ctx.arc(-2 * s, -4 * s, 2.5 * s, 0, Math.PI * 2);
            ctx.arc(2 * s, -4 * s, 2.5 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#1a1a2e';
            ctx.beginPath();
            ctx.arc(-2 * s, -3.5 * s, 1.2 * s, 0, Math.PI * 2);
            ctx.arc(2 * s, -3.5 * s, 1.2 * s, 0, Math.PI * 2);
            ctx.fill();
        }

        // ç»˜åˆ¶BOSSï¼ˆæ ¹æ®ä¸åŒé€ å‹ç»˜åˆ¶ï¼‰
        function drawBossLarge(enemy) {
            const cfg = enemy.bossConfig || { shape: 'fighter', color: '#ff4757' };
            const mainColor = cfg.color || '#ff4757';
            const s = (enemy.width || 100) / 80;
            const isHit = enemy.hitFlash && enemy.hitFlash > 0;
            const shape = cfg.shape || 'fighter';
            
            // åŠ¨ç”»è®¡æ—¶
            enemy.animTimer = (enemy.animTimer || 0) + 0.05;
            const pulse = 1 + Math.sin(enemy.animTimer * 2) * 0.05;
            const wave = Math.sin(enemy.animTimer * 3) * 0.1;
            
            // ç”Ÿæˆé¢œè‰²å˜ä½“
            const lighterColor = isHit ? '#ffffff' : lightenColor(mainColor, 40);
            const darkerColor = isHit ? '#ffdddd' : darkenColor(mainColor, 30);
            
            ctx.shadowColor = mainColor;
            ctx.shadowBlur = 20;
            
            // ä¸»ä½“æ¸å˜
            const bodyGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 50 * s);
            bodyGrad.addColorStop(0, lighterColor);
            bodyGrad.addColorStop(0.5, mainColor);
            bodyGrad.addColorStop(1, darkerColor);
            
            // æ ¹æ®ä¸åŒé€ å‹ç»˜åˆ¶
            switch(shape) {
                case 'crescent': // ç„æœˆ - æ–°æœˆå½¢
                    drawBossCrescent(s, bodyGrad, mainColor, isHit, wave);
                    break;
                case 'bird': // æš—å¤œç„é¸¿ - é¸Ÿå½¢
                case 'phoenix': // çƒˆç„°å‡¤å‡°
                    drawBossPhoenix(s, bodyGrad, mainColor, isHit, wave, shape === 'phoenix');
                    break;
                case 'crystal': // å†°éœœå¥³ç‹ - æ°´æ™¶å½¢
                    drawBossCrystal(s, bodyGrad, mainColor, isHit, pulse);
                    break;
                case 'thunder': // é›·ç”µä¹‹ä¸» - é—ªç”µå½¢
                    drawBossThunder(s, bodyGrad, mainColor, isHit, wave);
                    break;
                case 'octopus': // æ·±æµ·å·¨å…½ - ç« é±¼å½¢
                    drawBossOctopus(s, bodyGrad, mainColor, isHit, wave);
                    break;
                case 'butterfly': // æ¯’åˆºç„è¶ - è´è¶å½¢
                    drawBossButterfly(s, bodyGrad, mainColor, isHit, wave);
                    break;
                case 'vampire': // è¡€æœˆé­”å› - è¡€è…¹è è›‡
                case 'demon': // åœ°ç‹±ç«ç„°
                    drawBossDemon(s, bodyGrad, mainColor, isHit, wave);
                    break;
                case 'witch': // å¹»å½±é­”å¥³ - å¸½å­å½¢
                    drawBossWitch(s, bodyGrad, mainColor, isHit, wave);
                    break;
                case 'dragon': // é»„é‡‘å¸é¾™ - é¾™å½¢
                    drawBossDragon(s, bodyGrad, mainColor, isHit, wave);
                    break;
                case 'sakura': // æ¨±èŠ±ç²¾çµ - èŠ±ç“£å½¢
                case 'rose': // èŠ±å›­å®ˆæŠ¤è€…
                    drawBossFlower(s, bodyGrad, mainColor, isHit, pulse);
                    break;
                case 'blade': // æš—å½±åˆƒ - å‰‘å½¢
                    drawBossBlade(s, bodyGrad, mainColor, isHit, wave);
                    break;
                case 'giant': // æ˜Ÿç©ºå·¨äºº - å·¨äººå½¢
                    drawBossGiant(s, bodyGrad, mainColor, isHit, pulse);
                    break;
                case 'eye': // é£æš´ä¹‹çœ¼ - çœ¼ç›å½¢
                    drawBossEye(s, bodyGrad, mainColor, isHit, pulse);
                    break;
                case 'angel': // å¤©ä½¿ä¹‹ç¿¼ - å¤©ä½¿å½¢
                    drawBossAngel(s, bodyGrad, mainColor, isHit, wave);
                    break;
                case 'chaos': // æ··æ²Œä¹‹å¿ƒ - æ··æ²Œå½¢
                    drawBossChaos(s, bodyGrad, mainColor, isHit, wave, enemy.animTimer);
                    break;
                case 'cupid': // çˆ±ç¥ä¸˜æ¯”ç‰¹ - çˆ±å¿ƒå½¢
                case 'fighter': // çŠç‘©å®ˆå« - é»˜è®¤é±¼å½¢
                default:
                    drawBossFish(s, bodyGrad, mainColor, isHit, wave);
                    break;
            }
            
            ctx.shadowBlur = 0;
        }
        
        // é¢œè‰²è¾…åŠ©å‡½æ•°
        function lightenColor(color, percent) {
            const num = parseInt(color.slice(1), 16);
            const r = Math.min(255, (num >> 16) + Math.floor(255 * percent / 100));
            const g = Math.min(255, ((num >> 8) & 0x00FF) + Math.floor(255 * percent / 100));
            const b = Math.min(255, (num & 0x0000FF) + Math.floor(255 * percent / 100));
            return `rgb(${r},${g},${b})`;
        }
        function darkenColor(color, percent) {
            const num = parseInt(color.slice(1), 16);
            const r = Math.max(0, (num >> 16) - Math.floor(255 * percent / 100));
            const g = Math.max(0, ((num >> 8) & 0x00FF) - Math.floor(255 * percent / 100));
            const b = Math.max(0, (num & 0x0000FF) - Math.floor(255 * percent / 100));
            return `rgb(${r},${g},${b})`;
        }
        
        // Bossé€ å‹: é»˜è®¤é±¼å½¢ - éœ¸æ°”æ·±æµ·å·¨é±¼
        function drawBossFish(s, grad, color, isHit, wave) {
            const time = Date.now() * 0.003;
            
            // åŠ¨æ€å…‰æ™•åº•å±‚
            ctx.fillStyle = `rgba(${parseInt(color.slice(1,3),16)}, ${parseInt(color.slice(3,5),16)}, ${parseInt(color.slice(5,7),16)}, 0.15)`;
            ctx.beginPath();
            ctx.ellipse(0, 0, 55 * s + Math.sin(time) * 5 * s, 70 * s + Math.sin(time) * 5 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = grad;
            // å¨æ­¦çš„å°¾é³ - ä¸‰å‰æˆŸå½¢
            ctx.save();
            ctx.rotate(Math.sin(time * 2) * 0.1);
            ctx.beginPath();
            ctx.moveTo(0, -42 * s);
            ctx.quadraticCurveTo(-15 * s, -55 * s, -30 * s, -80 * s);
            ctx.quadraticCurveTo(-20 * s, -60 * s, -8 * s, -55 * s);
            ctx.lineTo(0, -65 * s);
            ctx.lineTo(8 * s, -55 * s);
            ctx.quadraticCurveTo(20 * s, -60 * s, 30 * s, -80 * s);
            ctx.quadraticCurveTo(15 * s, -55 * s, 0, -42 * s);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            
            // èƒŒé³ - é”¯é½¿çŠ¶
            ctx.beginPath();
            ctx.moveTo(-5 * s, -35 * s);
            for (let i = 0; i < 5; i++) {
                ctx.lineTo((-3 + i * 2) * s, (-40 - 15 + Math.sin(time + i) * 3) * s);
                ctx.lineTo((i * 2) * s, -35 * s);
            }
            ctx.fill();
            
            // æµçº¿å½¢èº«ä½“
            ctx.beginPath();
            ctx.ellipse(0, 0, 38 * s, 52 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // è…¹éƒ¨é«˜å…‰
            const bellyGrad = ctx.createLinearGradient(0, 0, 0, 40 * s);
            bellyGrad.addColorStop(0, 'rgba(255,255,255,0)');
            bellyGrad.addColorStop(0.5, 'rgba(255,255,255,0.25)');
            bellyGrad.addColorStop(1, 'rgba(255,255,255,0.1)');
            ctx.fillStyle = bellyGrad;
            ctx.beginPath();
            ctx.ellipse(0, 10 * s, 25 * s, 35 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // ä¾§é³ - åŠ¨æ€æ‰‡å½¢
            ctx.fillStyle = grad;
            ctx.save();
            ctx.rotate(Math.sin(time * 3) * 0.15);
            ctx.beginPath();
            ctx.moveTo(-32 * s, -5 * s);
            ctx.quadraticCurveTo(-60 * s, -25 * s, -65 * s, 5 * s);
            ctx.quadraticCurveTo(-55 * s, 15 * s, -32 * s, 10 * s);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            ctx.save();
            ctx.rotate(-Math.sin(time * 3) * 0.15);
            ctx.beginPath();
            ctx.moveTo(32 * s, -5 * s);
            ctx.quadraticCurveTo(60 * s, -25 * s, 65 * s, 5 * s);
            ctx.quadraticCurveTo(55 * s, 15 * s, 32 * s, 10 * s);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            
            // é³ç‰‡çº¹ç†
            ctx.fillStyle = isHit ? 'rgba(255,255,255,0.6)' : `rgba(255,255,255,0.2)`;
            for (let row = 0; row < 4; row++) {
                for (let col = -2; col <= 2; col++) {
                    const ox = col * 12 * s + (row % 2) * 6 * s;
                    const oy = -15 * s + row * 12 * s;
                    ctx.beginPath();
                    ctx.ellipse(ox, oy, 5 * s, 4 * s, 0, 0, Math.PI);
                    ctx.fill();
                }
            }
            
            // ç ç‰™
            ctx.fillStyle = isHit ? '#fff' : '#fffff0';
            ctx.beginPath();
            ctx.moveTo(-12 * s, 45 * s);
            ctx.lineTo(-8 * s, 55 * s);
            ctx.lineTo(-5 * s, 45 * s);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(12 * s, 45 * s);
            ctx.lineTo(8 * s, 55 * s);
            ctx.lineTo(5 * s, 45 * s);
            ctx.closePath();
            ctx.fill();
            
            // çœ¼ç› - å‡¶æ¶
            drawBossEyes(s, 25, isHit, 14, true);
        }
        
        // Bossé€ å‹: æ–°æœˆå½¢ - ç¥ç§˜æœˆç¥
        function drawBossCrescent(s, grad, color, isHit, wave) {
            const time = Date.now() * 0.002;
            
            // æœˆå…‰å…‰æ™•
            const glowGrad = ctx.createRadialGradient(0, 0, 20 * s, 0, 0, 60 * s);
            glowGrad.addColorStop(0, `rgba(${parseInt(color.slice(1,3),16)}, ${parseInt(color.slice(3,5),16)}, ${parseInt(color.slice(5,7),16)}, 0.3)`);
            glowGrad.addColorStop(1, 'rgba(255,255,200,0)');
            ctx.fillStyle = glowGrad;
            ctx.beginPath();
            ctx.arc(0, 0, 60 * s + Math.sin(time) * 5 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // ä¸»ä½“æ–°æœˆ
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(0, 0, 48 * s, 0.25 * Math.PI, 1.75 * Math.PI);
            ctx.arc(18 * s, 0, 38 * s, 1.75 * Math.PI, 0.25 * Math.PI, true);
            ctx.closePath();
            ctx.fill();
            
            // æœˆé¢çº¹ç† - ç¯å½¢å±±
            ctx.fillStyle = isHit ? 'rgba(255,255,255,0.5)' : 'rgba(200,200,150,0.3)';
            ctx.beginPath();
            ctx.arc(-15 * s, -5 * s, 8 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(-25 * s, 10 * s, 5 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(-8 * s, 18 * s, 6 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // æµ®åŠ¨æ˜Ÿå°˜
            ctx.fillStyle = isHit ? '#fff' : 'rgba(255,255,200,0.8)';
            for (let i = 0; i < 8; i++) {
                const angle = time + i * 0.8;
                const dist = 40 * s + Math.sin(time * 2 + i) * 8 * s;
                const px = Math.cos(angle) * dist * 0.6 - 5 * s;
                const py = Math.sin(angle) * dist * 0.8;
                const size = 2 + Math.sin(time * 3 + i) * 1;
                ctx.beginPath();
                ctx.arc(px, py, size * s, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // æœˆç‰™å°–ç«¯è£…é¥° - é—ªçƒå®çŸ³
            ctx.fillStyle = isHit ? '#fff' : 'rgba(255,255,220,0.9)';
            const tipAngles = [0.3 * Math.PI, 1.7 * Math.PI];
            for (const a of tipAngles) {
                const tx = Math.cos(a) * 45 * s;
                const ty = Math.sin(a) * 45 * s;
                ctx.beginPath();
                ctx.arc(tx, ty, (4 + Math.sin(time * 4) * 2) * s, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // ç¥ç§˜çœ¼ç›
            drawBossEyes(s, 12, isHit, 10);
        }
        
        // Bossé€ å‹: å‡¤å‡°/é¸Ÿå½¢ - çƒˆç„°ç¥é¸Ÿ
        function drawBossPhoenix(s, grad, color, isHit, wave, isPhoenix) {
            const time = Date.now() * 0.003;
            const wingFlap = Math.sin(time * 4) * 0.2;
            
            // ç«ç„°å…‰æ™•
            if (isPhoenix) {
                const fireGrad = ctx.createRadialGradient(0, 0, 10 * s, 0, 0, 80 * s);
                fireGrad.addColorStop(0, 'rgba(255,200,50,0.4)');
                fireGrad.addColorStop(0.5, 'rgba(255,100,0,0.2)');
                fireGrad.addColorStop(1, 'rgba(255,50,0,0)');
                ctx.fillStyle = fireGrad;
                ctx.beginPath();
                ctx.ellipse(0, 0, 80 * s, 90 * s, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // å·¨å¤§ç¿…è†€ - å¤šå±‚ç¾½æ¯›
            ctx.fillStyle = grad;
            ctx.save();
            ctx.rotate(wingFlap);
            // å·¦ç¿…å¤–å±‚
            ctx.beginPath();
            ctx.moveTo(-22 * s, 5 * s);
            ctx.quadraticCurveTo(-50 * s, -10 * s, -80 * s, -20 * s);
            ctx.quadraticCurveTo(-85 * s, 10 * s, -75 * s, 35 * s);
            ctx.quadraticCurveTo(-50 * s, 25 * s, -22 * s, 20 * s);
            ctx.closePath();
            ctx.fill();
            // å·¦ç¿…å†…å±‚ç¾½æ¯›
            ctx.fillStyle = isHit ? '#fff' : 'rgba(255,255,200,0.4)';
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.moveTo((-25 - i * 10) * s, (5 + i * 3) * s);
                ctx.quadraticCurveTo((-35 - i * 12) * s, (0 - i * 5) * s, (-45 - i * 10) * s, (-5 - i * 8) * s);
                ctx.lineWidth = (3 - i * 0.3) * s;
                ctx.strokeStyle = isHit ? '#fff' : `rgba(255,${200 - i * 20},${100 - i * 15},0.6)`;
                ctx.stroke();
            }
            ctx.restore();
            
            ctx.save();
            ctx.rotate(-wingFlap);
            ctx.fillStyle = grad;
            // å³ç¿…å¤–å±‚
            ctx.beginPath();
            ctx.moveTo(22 * s, 5 * s);
            ctx.quadraticCurveTo(50 * s, -10 * s, 80 * s, -20 * s);
            ctx.quadraticCurveTo(85 * s, 10 * s, 75 * s, 35 * s);
            ctx.quadraticCurveTo(50 * s, 25 * s, 22 * s, 20 * s);
            ctx.closePath();
            ctx.fill();
            // å³ç¿…å†…å±‚ç¾½æ¯›
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.moveTo((25 + i * 10) * s, (5 + i * 3) * s);
                ctx.quadraticCurveTo((35 + i * 12) * s, (0 - i * 5) * s, (45 + i * 10) * s, (-5 - i * 8) * s);
                ctx.lineWidth = (3 - i * 0.3) * s;
                ctx.strokeStyle = isHit ? '#fff' : `rgba(255,${200 - i * 20},${100 - i * 15},0.6)`;
                ctx.stroke();
            }
            ctx.restore();
            
            // åä¸½å°¾ç¾½
            if (isPhoenix) {
                for (let i = -3; i <= 3; i++) {
                    const tailWave = Math.sin(time * 3 + i * 0.5) * 5 * s;
                    ctx.beginPath();
                    ctx.moveTo(i * 6 * s, -28 * s);
                    ctx.quadraticCurveTo(i * 12 * s + tailWave, -55 * s, i * 8 * s, -90 * s);
                    ctx.quadraticCurveTo(i * 5 * s - tailWave * 0.5, -70 * s, i * 6 * s, -28 * s);
                    const tailGrad = ctx.createLinearGradient(i * 6 * s, -28 * s, i * 8 * s, -90 * s);
                    tailGrad.addColorStop(0, color);
                    tailGrad.addColorStop(0.5, isHit ? '#fff' : '#ffcc00');
                    tailGrad.addColorStop(1, isHit ? '#fff' : '#ff6600');
                    ctx.fillStyle = tailGrad;
                    ctx.fill();
                }
                // å°¾ç¾½ç«ç„°å°–ç«¯
                ctx.fillStyle = isHit ? '#fff' : 'rgba(255,255,150,0.8)';
                for (let i = -3; i <= 3; i++) {
                    ctx.beginPath();
                    ctx.arc(i * 8 * s, -88 * s + Math.sin(time * 5 + i) * 3 * s, 3 * s, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // èº«ä½“
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.ellipse(0, 12 * s, 22 * s, 32 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // èƒ¸å‰ç¾½æ¯›çº¹ç†
            ctx.fillStyle = isHit ? 'rgba(255,255,255,0.6)' : 'rgba(255,200,100,0.4)';
            for (let i = 0; i < 4; i++) {
                ctx.beginPath();
                ctx.ellipse(0, (5 + i * 8) * s, (15 - i * 2) * s, 5 * s, 0, 0, Math.PI);
                ctx.fill();
            }
            
            // å¤´éƒ¨
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(0, 38 * s, 14 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // å†¤å†’ - ç«ç„°å½¢
            if (isPhoenix) {
                const crownColors = ['#ff6600', '#ff9900', '#ffcc00'];
                for (let i = 0; i < 3; i++) {
                    ctx.fillStyle = isHit ? '#fff' : crownColors[i];
                    ctx.beginPath();
                    ctx.moveTo((i - 1) * 8 * s, 50 * s);
                    ctx.quadraticCurveTo((i - 1) * 6 * s, 62 * s + Math.sin(time * 5 + i) * 3 * s, (i - 1) * 8 * s, 68 * s);
                    ctx.quadraticCurveTo((i - 1) * 10 * s, 60 * s, (i - 0.5) * 8 * s, 50 * s);
                    ctx.fill();
                }
            }
            
            // å–‡å­
            ctx.fillStyle = isHit ? '#fff' : '#ffcc00';
            ctx.beginPath();
            ctx.moveTo(-4 * s, 50 * s);
            ctx.lineTo(0, 58 * s);
            ctx.lineTo(4 * s, 50 * s);
            ctx.closePath();
            ctx.fill();
            
            drawBossEyes(s, 38, isHit, 7, isPhoenix);
        }
        
        // Bossé€ å‹: æ°´æ™¶å½¢ - å†°éœœå¥³çš‡
        function drawBossCrystal(s, grad, color, isHit, pulse) {
            const time = Date.now() * 0.002;
            
            // å†°å†»å…‰æ™•
            const iceGrad = ctx.createRadialGradient(0, 0, 10 * s, 0, 0, 70 * s);
            iceGrad.addColorStop(0, 'rgba(200,240,255,0.3)');
            iceGrad.addColorStop(0.5, 'rgba(150,220,255,0.15)');
            iceGrad.addColorStop(1, 'rgba(100,200,255,0)');
            ctx.fillStyle = iceGrad;
            ctx.beginPath();
            ctx.arc(0, 0, 70 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // å¤–å±‚å°–åˆºæ°´æ™¶
            ctx.fillStyle = grad;
            for (let i = 0; i < 6; i++) {
                const angle = i * Math.PI / 3 - Math.PI / 2 + Math.sin(time + i) * 0.05;
                const spikeLen = (55 + Math.sin(time * 2 + i) * 5) * s;
                ctx.save();
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.moveTo(0, -20 * s);
                ctx.lineTo(-8 * s, -spikeLen);
                ctx.lineTo(0, -spikeLen - 15 * s);
                ctx.lineTo(8 * s, -spikeLen);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
            
            // ä¸»ä½“å…­è¾¹å½¢æ°´æ™¶
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = i * Math.PI / 3 - Math.PI / 2;
                const r = 40 * s * pulse;
                const x = Math.cos(angle) * r;
                const y = Math.sin(angle) * r;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            
            // å†…éƒ¨å¤šå±‚æŠ˜å°„
            const innerColors = [
                isHit ? 'rgba(255,255,255,0.6)' : 'rgba(200,240,255,0.5)',
                isHit ? 'rgba(255,255,255,0.4)' : 'rgba(180,230,255,0.4)',
                isHit ? 'rgba(255,255,255,0.3)' : 'rgba(150,220,255,0.3)'
            ];
            [28, 20, 12].forEach((r, idx) => {
                ctx.fillStyle = innerColors[idx];
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = i * Math.PI / 3 - Math.PI / 2 + (idx * 0.1);
                    const x = Math.cos(angle) * r * s;
                    const y = Math.sin(angle) * r * s;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
            });
            
            // é—ªçƒå…‰çº¿
            ctx.strokeStyle = isHit ? '#fff' : 'rgba(255,255,255,0.7)';
            ctx.lineWidth = 1.5 * s;
            for (let i = 0; i < 3; i++) {
                const angle = time + i * Math.PI * 2 / 3;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(Math.cos(angle) * 35 * s, Math.sin(angle) * 35 * s);
                ctx.stroke();
            }
            
            // æ¼‚æµ®å†°æ™¶ç¢‘ç‰‡
            ctx.fillStyle = isHit ? '#fff' : 'rgba(220,245,255,0.8)';
            for (let i = 0; i < 5; i++) {
                const fx = Math.cos(time * 0.5 + i * 1.3) * 50 * s;
                const fy = Math.sin(time * 0.7 + i * 1.3) * 50 * s;
                ctx.save();
                ctx.translate(fx, fy);
                ctx.rotate(time + i);
                ctx.beginPath();
                ctx.moveTo(0, -5 * s);
                ctx.lineTo(3 * s, 0);
                ctx.lineTo(0, 5 * s);
                ctx.lineTo(-3 * s, 0);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
            
            // å†°å†»ä¹‹çœ¼
            drawBossEyes(s, 8, isHit, 10);
        }
        
        // Bossé€ å‹: é—ªç”µå½¢ - é›·ç”µä¹‹ä¸»
        function drawBossThunder(s, grad, color, isHit, wave) {
            const time = Date.now() * 0.004;
            
            // é›·ç”µå…‰æ™•
            const thunderGlow = ctx.createRadialGradient(0, 0, 5 * s, 0, 0, 60 * s);
            thunderGlow.addColorStop(0, 'rgba(255,255,100,0.5)');
            thunderGlow.addColorStop(0.5, 'rgba(255,200,50,0.2)');
            thunderGlow.addColorStop(1, 'rgba(255,150,0,0)');
            ctx.fillStyle = thunderGlow;
            ctx.beginPath();
            ctx.arc(0, 0, 60 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // ä¸»ä½“é—ªç”µ - æ›´å¤æ‚çš„å½¢çŠ¶
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.moveTo(-5 * s, -55 * s);
            ctx.lineTo(15 * s, -55 * s);
            ctx.lineTo(25 * s, -20 * s);
            ctx.lineTo(12 * s, -20 * s);
            ctx.lineTo(30 * s, 20 * s);
            ctx.lineTo(15 * s, 20 * s);
            ctx.lineTo(35 * s, 60 * s);
            ctx.lineTo(-5 * s, 15 * s);
            ctx.lineTo(8 * s, 15 * s);
            ctx.lineTo(-10 * s, -15 * s);
            ctx.lineTo(5 * s, -15 * s);
            ctx.lineTo(-15 * s, -55 * s);
            ctx.closePath();
            ctx.fill();
            
            // ç”µå…‰è¾¹ç¼˜
            ctx.strokeStyle = isHit ? '#fff' : 'rgba(255,255,200,0.9)';
            ctx.lineWidth = 3 * s;
            ctx.stroke();
            
            // å†…éƒ¨é«˜äº®æ ¸å¿ƒ
            const coreGrad = ctx.createLinearGradient(0, -55 * s, 0, 60 * s);
            coreGrad.addColorStop(0, 'rgba(255,255,255,0.8)');
            coreGrad.addColorStop(0.5, 'rgba(255,255,200,0.5)');
            coreGrad.addColorStop(1, 'rgba(255,200,100,0.3)');
            ctx.fillStyle = coreGrad;
            ctx.beginPath();
            ctx.moveTo(0, -45 * s);
            ctx.lineTo(10 * s, -20 * s);
            ctx.lineTo(5 * s, -20 * s);
            ctx.lineTo(18 * s, 15 * s);
            ctx.lineTo(8 * s, 15 * s);
            ctx.lineTo(20 * s, 45 * s);
            ctx.lineTo(0, 10 * s);
            ctx.lineTo(5 * s, 10 * s);
            ctx.lineTo(-5 * s, -15 * s);
            ctx.lineTo(2 * s, -15 * s);
            ctx.lineTo(-8 * s, -45 * s);
            ctx.closePath();
            ctx.fill();
            
            // åˆ†å‰ç”µå¼§
            ctx.strokeStyle = isHit ? '#fff' : 'rgba(255,255,150,0.7)';
            ctx.lineWidth = 2 * s;
            const branches = [
                {sx: -10, sy: -30, ex: -35, ey: -45},
                {sx: 20, sy: -10, ex: 45, ey: -20},
                {sx: -5, sy: 10, ex: -30, ey: 25},
                {sx: 25, sy: 35, ex: 50, ey: 50}
            ];
            branches.forEach((b, i) => {
                if (Math.sin(time * 5 + i * 2) > 0.3) {
                    ctx.beginPath();
                    ctx.moveTo(b.sx * s, b.sy * s);
                    const midX = (b.sx + b.ex) / 2 + Math.sin(time * 10 + i) * 5;
                    const midY = (b.sy + b.ey) / 2;
                    ctx.lineTo(midX * s, midY * s);
                    ctx.lineTo(b.ex * s, b.ey * s);
                    ctx.stroke();
                }
            });
            
            // ç”µç«èŠ±ç²’å­
            ctx.fillStyle = isHit ? '#fff' : 'rgba(255,255,200,0.9)';
            for (let i = 0; i < 6; i++) {
                if (Math.sin(time * 8 + i * 1.5) > 0) {
                    const px = (Math.random() - 0.5) * 60 * s;
                    const py = (Math.random() - 0.5) * 100 * s;
                    ctx.beginPath();
                    ctx.arc(px, py, (1 + Math.random() * 2) * s, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        // Bossé€ å‹: ç« é±¼å½¢ - æ·±æµ·å·¨å…½
        function drawBossOctopus(s, grad, color, isHit, wave) {
            const time = Date.now() * 0.002;
            
            // æ·±æµ·å…‰æ™•
            const deepGlow = ctx.createRadialGradient(0, 10 * s, 10 * s, 0, 10 * s, 80 * s);
            deepGlow.addColorStop(0, `rgba(${parseInt(color.slice(1,3),16)}, ${parseInt(color.slice(3,5),16)}, ${parseInt(color.slice(5,7),16)}, 0.3)`);
            deepGlow.addColorStop(1, 'rgba(0,50,100,0)');
            ctx.fillStyle = deepGlow;
            ctx.beginPath();
            ctx.arc(0, 10 * s, 80 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // è§¦æ‰‹ - æ›´ç²¾ç»†çš„å·æ›²
            for (let i = 0; i < 8; i++) {
                const baseAngle = (i / 8) * Math.PI * 2;
                const startX = Math.cos(baseAngle) * 28 * s;
                const startY = 15 * s + Math.sin(baseAngle) * 22 * s;
                
                // è§¦æ‰‹æ¸å˜
                const tentGrad = ctx.createLinearGradient(
                    startX, startY,
                    startX + Math.cos(baseAngle) * 55 * s,
                    startY + Math.sin(baseAngle) * 45 * s
                );
                tentGrad.addColorStop(0, color);
                tentGrad.addColorStop(1, isHit ? '#fff' : darkenColor(color, 20));
                
                // ç»˜åˆ¶å·æ›²è§¦æ‰‹
                const wiggle1 = Math.sin(time * 3 + i) * 12 * s;
                const wiggle2 = Math.sin(time * 2 + i * 0.7) * 8 * s;
                
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                
                // å¤šæ®µè´å¡å°”æ›²çº¿å½¢æˆå·æ›²
                const cp1x = startX + Math.cos(baseAngle) * 25 * s + wiggle1;
                const cp1y = startY + Math.sin(baseAngle) * 20 * s;
                const cp2x = startX + Math.cos(baseAngle) * 40 * s - wiggle2;
                const cp2y = startY + Math.sin(baseAngle) * 35 * s;
                const endX = startX + Math.cos(baseAngle + 0.3) * 55 * s + wiggle2;
                const endY = startY + Math.sin(baseAngle) * 50 * s;
                
                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);
                ctx.lineWidth = (10 - i * 0.3) * s;
                ctx.lineCap = 'round';
                ctx.strokeStyle = tentGrad;
                ctx.stroke();
                
                // å¸ç›˜
                ctx.fillStyle = isHit ? 'rgba(255,255,255,0.7)' : 'rgba(255,200,200,0.6)';
                for (let j = 1; j <= 4; j++) {
                    const t = j / 5;
                    const sx = startX + (endX - startX) * t + Math.sin(time + i + j) * 3 * s;
                    const sy = startY + (endY - startY) * t;
                    ctx.beginPath();
                    ctx.arc(sx, sy, (3 - j * 0.4) * s, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // å·¨å¤§å¤´éƒ¨
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.ellipse(0, 12 * s, 38 * s, 35 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // å¤´éƒ¨çº¹ç†
            ctx.fillStyle = isHit ? 'rgba(255,255,255,0.4)' : 'rgba(255,255,255,0.15)';
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.ellipse((i - 2) * 10 * s, (5 + Math.abs(i - 2) * 5) * s, 6 * s, 10 * s, 0, 0, Math.PI);
                ctx.fill();
            }
            
            // å‘å…‰æ–‘ç‚¹
            ctx.fillStyle = isHit ? '#fff' : 'rgba(100,200,255,0.6)';
            const spots = [[15, 25], [-18, 20], [5, -5], [-10, 0], [20, 5]];
            spots.forEach(([x, y], i) => {
                const glow = 0.5 + Math.sin(time * 2 + i) * 0.3;
                ctx.globalAlpha = glow;
                ctx.beginPath();
                ctx.arc(x * s, y * s, (3 + Math.sin(time * 3 + i)) * s, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
            
            // å·¨å¤§çœ¼ç›
            drawBossEyes(s, 20, isHit, 15);
        }
        
        // Bossé€ å‹: è´è¶å½¢ - æ¯’åˆºç„è¶
        function drawBossButterfly(s, grad, color, isHit, wave) {
            const time = Date.now() * 0.003;
            const wingFlap = Math.sin(time * 5) * 0.12;
            
            // æ¢¦å¹»å…‰æ™•
            const butterflyGlow = ctx.createRadialGradient(0, 0, 10 * s, 0, 0, 70 * s);
            butterflyGlow.addColorStop(0, `rgba(${parseInt(color.slice(1,3),16)}, ${parseInt(color.slice(3,5),16)}, ${parseInt(color.slice(5,7),16)}, 0.25)`);
            butterflyGlow.addColorStop(1, 'rgba(200,100,255,0)');
            ctx.fillStyle = butterflyGlow;
            ctx.beginPath();
            ctx.ellipse(0, 0, 75 * s, 60 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // å·¦ç¿… - å¤šå±‚ç»“æ„
            ctx.save();
            ctx.rotate(wingFlap);
            // å¤–å±‚ç¿…è†€
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.moveTo(-10 * s, -30 * s);
            ctx.quadraticCurveTo(-55 * s, -50 * s, -70 * s, -10 * s);
            ctx.quadraticCurveTo(-75 * s, 20 * s, -55 * s, 45 * s);
            ctx.quadraticCurveTo(-30 * s, 35 * s, -10 * s, 25 * s);
            ctx.closePath();
            ctx.fill();
            // ç¿…è†€èŠ±çº¹ - çœ¼çŠ¶æ–‘
            ctx.fillStyle = isHit ? 'rgba(255,255,255,0.7)' : 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(-40 * s, -5 * s, 18 * s, 22 * s, -0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = isHit ? '#fff' : color;
            ctx.beginPath();
            ctx.ellipse(-40 * s, -5 * s, 12 * s, 15 * s, -0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = isHit ? 'rgba(255,255,255,0.8)' : 'rgba(255,255,255,0.6)';
            ctx.beginPath();
            ctx.ellipse(-38 * s, -10 * s, 5 * s, 6 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            // ç¿…è†€è¾¹ç¼˜è£…é¥°
            ctx.fillStyle = isHit ? '#fff' : 'rgba(255,255,255,0.4)';
            for (let i = 0; i < 6; i++) {
                const t = i / 5;
                const ex = -10 * s + (-60 + 10) * t * s;
                const ey = (-30 + 55 * Math.sin(t * Math.PI)) * s;
                ctx.beginPath();
                ctx.arc(ex, ey, (2 + Math.sin(time * 2 + i)) * s, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
            
            // å³ç¿… - é•œåƒ
            ctx.save();
            ctx.rotate(-wingFlap);
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.moveTo(10 * s, -30 * s);
            ctx.quadraticCurveTo(55 * s, -50 * s, 70 * s, -10 * s);
            ctx.quadraticCurveTo(75 * s, 20 * s, 55 * s, 45 * s);
            ctx.quadraticCurveTo(30 * s, 35 * s, 10 * s, 25 * s);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = isHit ? 'rgba(255,255,255,0.7)' : 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(40 * s, -5 * s, 18 * s, 22 * s, 0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = isHit ? '#fff' : color;
            ctx.beginPath();
            ctx.ellipse(40 * s, -5 * s, 12 * s, 15 * s, 0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = isHit ? 'rgba(255,255,255,0.8)' : 'rgba(255,255,255,0.6)';
            ctx.beginPath();
            ctx.ellipse(38 * s, -10 * s, 5 * s, 6 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = isHit ? '#fff' : 'rgba(255,255,255,0.4)';
            for (let i = 0; i < 6; i++) {
                const t = i / 5;
                const ex = 10 * s + (60 - 10) * t * s;
                const ey = (-30 + 55 * Math.sin(t * Math.PI)) * s;
                ctx.beginPath();
                ctx.arc(ex, ey, (2 + Math.sin(time * 2 + i)) * s, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
            
            // ç²¾è‡´èº«ä½“
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.ellipse(0, 0, 7 * s, 38 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            // èº«ä½“çº¹ç†
            ctx.fillStyle = isHit ? 'rgba(255,255,255,0.5)' : 'rgba(0,0,0,0.2)';
            for (let i = 0; i < 6; i++) {
                ctx.beginPath();
                ctx.ellipse(0, (-25 + i * 10) * s, 5 * s, 3 * s, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // ä¼˜é›…è§¦è§’
            ctx.strokeStyle = grad;
            ctx.lineWidth = 2.5 * s;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(-4 * s, 35 * s);
            ctx.bezierCurveTo(-10 * s, 50 * s, -18 * s, 60 * s, -12 * s, 72 * s);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(4 * s, 35 * s);
            ctx.bezierCurveTo(10 * s, 50 * s, 18 * s, 60 * s, 12 * s, 72 * s);
            ctx.stroke();
            // è§¦è§’å°–ç«¯å…‰çƒ
            ctx.fillStyle = isHit ? '#fff' : 'rgba(255,200,255,0.9)';
            ctx.beginPath();
            ctx.arc(-12 * s, 72 * s, (3 + Math.sin(time * 4)) * s, 0, Math.PI * 2);
            ctx.arc(12 * s, 72 * s, (3 + Math.sin(time * 4 + 1)) * s, 0, Math.PI * 2);
            ctx.fill();
            
            // é³ç²‰ç‰¹æ•ˆ
            ctx.fillStyle = isHit ? 'rgba(255,255,255,0.8)' : 'rgba(255,200,255,0.5)';
            for (let i = 0; i < 8; i++) {
                const px = Math.sin(time + i * 0.8) * 50 * s;
                const py = Math.cos(time * 0.7 + i) * 40 * s + (i % 2) * 10 * s;
                ctx.beginPath();
                ctx.arc(px, py, (1 + Math.sin(time * 3 + i) * 0.5) * s, 0, Math.PI * 2);
                ctx.fill();
            }
            
            drawBossEyes(s, 32, isHit, 5);
        }
        
        // Bossé€ å‹: æ¶é­”å½¢ - åœ°ç‹±é­”å›
        function drawBossDemon(s, grad, color, isHit, wave) {
            const time = Date.now() * 0.003;
            
            // é‚ªæ¶å…‰æ™•
            const demonGlow = ctx.createRadialGradient(0, 0, 10 * s, 0, 0, 75 * s);
            demonGlow.addColorStop(0, 'rgba(255,50,0,0.3)');
            demonGlow.addColorStop(0.5, 'rgba(150,0,50,0.15)');
            demonGlow.addColorStop(1, 'rgba(50,0,50,0)');
            ctx.fillStyle = demonGlow;
            ctx.beginPath();
            ctx.arc(0, 0, 75 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // è“è…†ç¿…è†€
            const wingFlap = Math.sin(time * 3) * 0.1;
            ctx.save();
            ctx.rotate(wingFlap);
            ctx.fillStyle = grad;
            // å·¦ç¿… - å¤šèŠ‚ç»“æ„
            ctx.beginPath();
            ctx.moveTo(-28 * s, -15 * s);
            ctx.lineTo(-50 * s, -45 * s);
            ctx.lineTo(-45 * s, -25 * s);
            ctx.lineTo(-70 * s, -35 * s);
            ctx.lineTo(-55 * s, -15 * s);
            ctx.lineTo(-80 * s, -10 * s);
            ctx.lineTo(-60 * s, 5 * s);
            ctx.lineTo(-70 * s, 25 * s);
            ctx.lineTo(-45 * s, 15 * s);
            ctx.lineTo(-28 * s, 10 * s);
            ctx.closePath();
            ctx.fill();
            // ç¿…è†€éª¨éª¼
            ctx.strokeStyle = isHit ? '#fff' : 'rgba(0,0,0,0.4)';
            ctx.lineWidth = 2 * s;
            ctx.beginPath();
            ctx.moveTo(-30 * s, 0);
            ctx.lineTo(-55 * s, -30 * s);
            ctx.moveTo(-35 * s, -5 * s);
            ctx.lineTo(-65 * s, -20 * s);
            ctx.moveTo(-35 * s, 5 * s);
            ctx.lineTo(-60 * s, 15 * s);
            ctx.stroke();
            ctx.restore();
            
            ctx.save();
            ctx.rotate(-wingFlap);
            ctx.fillStyle = grad;
            // å³ç¿…
            ctx.beginPath();
            ctx.moveTo(28 * s, -15 * s);
            ctx.lineTo(50 * s, -45 * s);
            ctx.lineTo(45 * s, -25 * s);
            ctx.lineTo(70 * s, -35 * s);
            ctx.lineTo(55 * s, -15 * s);
            ctx.lineTo(80 * s, -10 * s);
            ctx.lineTo(60 * s, 5 * s);
            ctx.lineTo(70 * s, 25 * s);
            ctx.lineTo(45 * s, 15 * s);
            ctx.lineTo(28 * s, 10 * s);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = isHit ? '#fff' : 'rgba(0,0,0,0.4)';
            ctx.lineWidth = 2 * s;
            ctx.beginPath();
            ctx.moveTo(30 * s, 0);
            ctx.lineTo(55 * s, -30 * s);
            ctx.moveTo(35 * s, -5 * s);
            ctx.lineTo(65 * s, -20 * s);
            ctx.moveTo(35 * s, 5 * s);
            ctx.lineTo(60 * s, 15 * s);
            ctx.stroke();
            ctx.restore();
            
            // å·¨å¤§é­”è§’
            ctx.fillStyle = grad;
            // å·¦è§’ - å¼¯æ›²
            ctx.beginPath();
            ctx.moveTo(-22 * s, -32 * s);
            ctx.quadraticCurveTo(-35 * s, -50 * s, -28 * s, -72 * s);
            ctx.quadraticCurveTo(-22 * s, -65 * s, -18 * s, -72 * s);
            ctx.quadraticCurveTo(-25 * s, -55 * s, -15 * s, -35 * s);
            ctx.closePath();
            ctx.fill();
            // å³è§’
            ctx.beginPath();
            ctx.moveTo(22 * s, -32 * s);
            ctx.quadraticCurveTo(35 * s, -50 * s, 28 * s, -72 * s);
            ctx.quadraticCurveTo(22 * s, -65 * s, 18 * s, -72 * s);
            ctx.quadraticCurveTo(25 * s, -55 * s, 15 * s, -35 * s);
            ctx.closePath();
            ctx.fill();
            // è§’ä¸Šçº¹ç†
            ctx.strokeStyle = isHit ? '#fff' : 'rgba(255,150,0,0.5)';
            ctx.lineWidth = 1.5 * s;
            [-1, 1].forEach(dir => {
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.arc(dir * 23 * s, (-45 - i * 8) * s, (8 - i * 2) * s, dir > 0 ? Math.PI : 0, dir > 0 ? 0 : Math.PI);
                    ctx.stroke();
                }
            });
            
            // èº«ä½“
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.ellipse(0, 0, 32 * s, 42 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // èƒ¸ç”²çº¹ç†
            ctx.fillStyle = isHit ? 'rgba(255,255,255,0.5)' : 'rgba(0,0,0,0.25)';
            ctx.beginPath();
            ctx.ellipse(0, 5 * s, 20 * s, 25 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            // çº¹ç†çº¿æ¡
            ctx.strokeStyle = isHit ? 'rgba(255,255,255,0.4)' : 'rgba(255,100,0,0.3)';
            ctx.lineWidth = 1.5 * s;
            for (let i = 0; i < 4; i++) {
                ctx.beginPath();
                ctx.ellipse(0, (-5 + i * 8) * s, (15 - i * 2) * s, 4 * s, 0, 0, Math.PI);
                ctx.stroke();
            }
            
            // å°–ç‰™
            ctx.fillStyle = isHit ? '#fff' : '#fffff0';
            ctx.beginPath();
            ctx.moveTo(-10 * s, 38 * s);
            ctx.lineTo(-6 * s, 50 * s);
            ctx.lineTo(-3 * s, 38 * s);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(10 * s, 38 * s);
            ctx.lineTo(6 * s, 50 * s);
            ctx.lineTo(3 * s, 38 * s);
            ctx.closePath();
            ctx.fill();
            
            // ç«ç„°ç‰¹æ•ˆ
            ctx.fillStyle = isHit ? 'rgba(255,255,255,0.7)' : 'rgba(255,100,0,0.6)';
            for (let i = 0; i < 5; i++) {
                const fx = Math.sin(time * 4 + i * 1.3) * 25 * s;
                const fy = -40 * s + Math.sin(time * 3 + i) * 10 * s;
                ctx.beginPath();
                ctx.arc(fx, fy, (2 + Math.sin(time * 5 + i) * 1.5) * s, 0, Math.PI * 2);
                ctx.fill();
            }
            
            drawBossEyes(s, 15, isHit, 13, true);
        }
        
        // Bossé€ å‹: å¥³å·«å½¢ - å¹»å½±é­”å¥³
        function drawBossWitch(s, grad, color, isHit, wave) {
            const time = Date.now() * 0.002;
            
            // é­”æ³•å…‰æ™•
            const witchGlow = ctx.createRadialGradient(0, 0, 10 * s, 0, 0, 65 * s);
            witchGlow.addColorStop(0, `rgba(${parseInt(color.slice(1,3),16)}, ${parseInt(color.slice(3,5),16)}, ${parseInt(color.slice(5,7),16)}, 0.25)`);
            witchGlow.addColorStop(1, 'rgba(100,0,150,0)');
            ctx.fillStyle = witchGlow;
            ctx.beginPath();
            ctx.arc(0, 0, 65 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // æµ®åŠ¨é­”æ³•ç¬¦æ–‡
            ctx.strokeStyle = isHit ? 'rgba(255,255,255,0.6)' : 'rgba(200,150,255,0.4)';
            ctx.lineWidth = 1.5 * s;
            for (let i = 0; i < 3; i++) {
                const orbitR = (40 + i * 15) * s;
                ctx.beginPath();
                ctx.arc(0, 5 * s, orbitR, time + i, time + i + Math.PI * 0.5);
                ctx.stroke();
            }
            
            // é­”æ³•å¸½ - æ›´ç²¾è‡´çš„å½¢çŠ¶
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.moveTo(0, -78 * s);
            ctx.quadraticCurveTo(-8 * s, -60 * s, -38 * s, -12 * s);
            ctx.lineTo(38 * s, -12 * s);
            ctx.quadraticCurveTo(8 * s, -60 * s, 0, -78 * s);
            ctx.closePath();
            ctx.fill();
            
            // å¸½å­è£…é¥°å¸¦
            ctx.fillStyle = isHit ? '#fff' : 'rgba(255,200,100,0.8)';
            ctx.beginPath();
            ctx.ellipse(0, -40 * s, 12 * s, 5 * s, -0.3, 0, Math.PI * 2);
            ctx.fill();
            // å¸½å­å°–ç«¯æ˜Ÿæ˜Ÿ
            ctx.fillStyle = isHit ? '#fff' : 'rgba(255,255,150,0.9)';
            ctx.beginPath();
            ctx.arc(0, -78 * s, (4 + Math.sin(time * 3) * 2) * s, 0, Math.PI * 2);
            ctx.fill();
            
            // å¸½æª - æ³¢æµªå½¢
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.ellipse(0, -12 * s, 52 * s, 14 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            // å¸½æªè£…é¥°
            ctx.fillStyle = isHit ? 'rgba(255,255,255,0.5)' : 'rgba(0,0,0,0.2)';
            ctx.beginPath();
            ctx.ellipse(0, -10 * s, 48 * s, 10 * s, 0, 0, Math.PI);
            ctx.fill();
            
            // å¤´å‘ - æ³¢æµªå·å‘
            ctx.fillStyle = grad;
            for (let i = -2; i <= 2; i++) {
                const hairWave = Math.sin(time * 2 + i) * 5 * s;
                ctx.beginPath();
                ctx.moveTo(i * 12 * s, 0);
                ctx.quadraticCurveTo((i * 15 + hairWave) * s, 25 * s, (i * 18 + hairWave * 1.5) * s, 55 * s);
                ctx.quadraticCurveTo((i * 12) * s, 40 * s, (i * 10) * s, 0);
                ctx.fill();
            }
            
            // è„¸éƒ¨
            ctx.fillStyle = isHit ? '#fff' : 'rgba(255,230,210,0.95)';
            ctx.beginPath();
            ctx.ellipse(0, 18 * s, 22 * s, 26 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // è…•çº¢
            ctx.fillStyle = isHit ? 'rgba(255,255,255,0.5)' : 'rgba(255,150,150,0.3)';
            ctx.beginPath();
            ctx.ellipse(-12 * s, 22 * s, 6 * s, 4 * s, 0, 0, Math.PI * 2);
            ctx.ellipse(12 * s, 22 * s, 6 * s, 4 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // å˜²ç¬‘çš„å˜´
            ctx.strokeStyle = isHit ? '#fff' : 'rgba(100,50,80,0.8)';
            ctx.lineWidth = 2 * s;
            ctx.beginPath();
            ctx.arc(0, 28 * s, 8 * s, 0.1 * Math.PI, 0.9 * Math.PI);
            ctx.stroke();
            
            // é­”æ³•ç²’å­
            ctx.fillStyle = isHit ? '#fff' : 'rgba(200,150,255,0.7)';
            for (let i = 0; i < 6; i++) {
                const px = Math.sin(time * 1.5 + i * 1.1) * 45 * s;
                const py = Math.cos(time + i * 0.9) * 40 * s;
                ctx.beginPath();
                ctx.arc(px, py, (2 + Math.sin(time * 3 + i)) * s, 0, Math.PI * 2);
                ctx.fill();
            }
            
            drawBossEyes(s, 12, isHit, 7);
        }
        
        // Bossé€ å‹: é¾™å½¢ - é»„é‡‘å¸é¾™
        function drawBossDragon(s, grad, color, isHit, wave) {
            const time = Date.now() * 0.003;
            const wingFlap = Math.sin(time * 3) * 0.15;
            
            // é¾™ç„°å…‰æ™•
            const dragonGlow = ctx.createRadialGradient(0, 0, 15 * s, 0, 0, 80 * s);
            dragonGlow.addColorStop(0, 'rgba(255,200,50,0.3)');
            dragonGlow.addColorStop(0.5, 'rgba(255,100,0,0.15)');
            dragonGlow.addColorStop(1, 'rgba(200,50,0,0)');
            ctx.fillStyle = dragonGlow;
            ctx.beginPath();
            ctx.arc(0, 0, 80 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // å·¨å¤§é¾™ç¿…
            ctx.save();
            ctx.rotate(wingFlap);
            ctx.fillStyle = grad;
            // å·¦ç¿… - å¤šæŒ‡éª¨æ¶
            ctx.beginPath();
            ctx.moveTo(-28 * s, -15 * s);
            ctx.lineTo(-55 * s, -55 * s);
            ctx.lineTo(-48 * s, -30 * s);
            ctx.lineTo(-75 * s, -45 * s);
            ctx.lineTo(-62 * s, -20 * s);
            ctx.lineTo(-85 * s, -15 * s);
            ctx.lineTo(-70 * s, 5 * s);
            ctx.lineTo(-85 * s, 25 * s);
            ctx.lineTo(-60 * s, 20 * s);
            ctx.lineTo(-70 * s, 40 * s);
            ctx.lineTo(-45 * s, 25 * s);
            ctx.lineTo(-28 * s, 15 * s);
            ctx.closePath();
            ctx.fill();
            // ç¿…è†œ
            ctx.fillStyle = isHit ? 'rgba(255,255,255,0.4)' : 'rgba(255,150,50,0.3)';
            ctx.beginPath();
            ctx.moveTo(-30 * s, -10 * s);
            ctx.quadraticCurveTo(-55 * s, -35 * s, -70 * s, -20 * s);
            ctx.quadraticCurveTo(-60 * s, 5 * s, -70 * s, 30 * s);
            ctx.quadraticCurveTo(-45 * s, 15 * s, -30 * s, 10 * s);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            
            ctx.save();
            ctx.rotate(-wingFlap);
            ctx.fillStyle = grad;
            // å³ç¿…
            ctx.beginPath();
            ctx.moveTo(28 * s, -15 * s);
            ctx.lineTo(55 * s, -55 * s);
            ctx.lineTo(48 * s, -30 * s);
            ctx.lineTo(75 * s, -45 * s);
            ctx.lineTo(62 * s, -20 * s);
            ctx.lineTo(85 * s, -15 * s);
            ctx.lineTo(70 * s, 5 * s);
            ctx.lineTo(85 * s, 25 * s);
            ctx.lineTo(60 * s, 20 * s);
            ctx.lineTo(70 * s, 40 * s);
            ctx.lineTo(45 * s, 25 * s);
            ctx.lineTo(28 * s, 15 * s);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = isHit ? 'rgba(255,255,255,0.4)' : 'rgba(255,150,50,0.3)';
            ctx.beginPath();
            ctx.moveTo(30 * s, -10 * s);
            ctx.quadraticCurveTo(55 * s, -35 * s, 70 * s, -20 * s);
            ctx.quadraticCurveTo(60 * s, 5 * s, 70 * s, 30 * s);
            ctx.quadraticCurveTo(45 * s, 15 * s, 30 * s, 10 * s);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            
            // å¨ä¸¥é¾™è§’
            ctx.fillStyle = grad;
            // å·¦è§’ - åˆ†å‰
            ctx.beginPath();
            ctx.moveTo(-12 * s, -42 * s);
            ctx.quadraticCurveTo(-20 * s, -55 * s, -18 * s, -75 * s);
            ctx.quadraticCurveTo(-15 * s, -65 * s, -12 * s, -70 * s);
            ctx.quadraticCurveTo(-18 * s, -60 * s, -8 * s, -45 * s);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(-18 * s, -50 * s);
            ctx.quadraticCurveTo(-28 * s, -55 * s, -32 * s, -65 * s);
            ctx.quadraticCurveTo(-25 * s, -55 * s, -18 * s, -50 * s);
            ctx.fill();
            // å³è§’
            ctx.beginPath();
            ctx.moveTo(12 * s, -42 * s);
            ctx.quadraticCurveTo(20 * s, -55 * s, 18 * s, -75 * s);
            ctx.quadraticCurveTo(15 * s, -65 * s, 12 * s, -70 * s);
            ctx.quadraticCurveTo(18 * s, -60 * s, 8 * s, -45 * s);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(18 * s, -50 * s);
            ctx.quadraticCurveTo(28 * s, -55 * s, 32 * s, -65 * s);
            ctx.quadraticCurveTo(25 * s, -55 * s, 18 * s, -50 * s);
            ctx.fill();
            
            // èº«ä½“
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.ellipse(0, 0, 28 * s, 48 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // é¾™é³ - é‡‘è‰²è±å½¢
            ctx.fillStyle = isHit ? '#fff' : 'rgba(255,215,0,0.7)';
            for (let row = 0; row < 6; row++) {
                for (let col = -1; col <= 1; col++) {
                    const sx = col * 10 * s + (row % 2) * 5 * s;
                    const sy = (-35 + row * 12) * s;
                    ctx.save();
                    ctx.translate(sx, sy);
                    ctx.rotate(Math.PI / 4);
                    ctx.beginPath();
                    ctx.rect(-4 * s, -4 * s, 8 * s, 8 * s);
                    ctx.fill();
                    ctx.restore();
                }
            }
            
            // é¾™é¡»
            ctx.strokeStyle = isHit ? '#fff' : 'rgba(255,200,100,0.7)';
            ctx.lineWidth = 2 * s;
            const whiskerWave = Math.sin(time * 2) * 5 * s;
            ctx.beginPath();
            ctx.moveTo(-15 * s, 40 * s);
            ctx.quadraticCurveTo(-30 * s + whiskerWave, 50 * s, -40 * s + whiskerWave, 45 * s);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(15 * s, 40 * s);
            ctx.quadraticCurveTo(30 * s - whiskerWave, 50 * s, 40 * s - whiskerWave, 45 * s);
            ctx.stroke();
            
            // ç ç‰™
            ctx.fillStyle = isHit ? '#fff' : '#fffff0';
            ctx.beginPath();
            ctx.moveTo(-8 * s, 42 * s);
            ctx.lineTo(-5 * s, 52 * s);
            ctx.lineTo(-2 * s, 42 * s);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(8 * s, 42 * s);
            ctx.lineTo(5 * s, 52 * s);
            ctx.lineTo(2 * s, 42 * s);
            ctx.closePath();
            ctx.fill();
            
            // å–œæ€’åŒçœ¼
            drawBossEyes(s, 28, isHit, 11, true);
        }
        
        // Bossé€ å‹: èŠ±æœµå½¢ - æ¨±èŠ±ç²¾çµ
        function drawBossFlower(s, grad, color, isHit, pulse) {
            const time = Date.now() * 0.002;
            const petalWave = Math.sin(time) * 0.05;
            
            // èŠ±é¦™å…‰æ™•
            const flowerGlow = ctx.createRadialGradient(0, 0, 10 * s, 0, 0, 70 * s);
            flowerGlow.addColorStop(0, `rgba(${parseInt(color.slice(1,3),16)}, ${parseInt(color.slice(3,5),16)}, ${parseInt(color.slice(5,7),16)}, 0.25)`);
            flowerGlow.addColorStop(1, 'rgba(255,200,220,0)');
            ctx.fillStyle = flowerGlow;
            ctx.beginPath();
            ctx.arc(0, 0, 70 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // å¤šå±‚èŠ±ç“£
            // å¤–å±‚èŠ±ç“£
            ctx.fillStyle = grad;
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + petalWave;
                const petalPulse = pulse + Math.sin(time * 2 + i) * 0.05;
                ctx.save();
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.moveTo(0, -15 * s);
                ctx.quadraticCurveTo(-20 * s, -40 * s * petalPulse, 0, -55 * s * petalPulse);
                ctx.quadraticCurveTo(20 * s, -40 * s * petalPulse, 0, -15 * s);
                ctx.fill();
                // èŠ±ç“£çº¹ç†
                ctx.fillStyle = isHit ? 'rgba(255,255,255,0.5)' : 'rgba(255,255,255,0.3)';
                ctx.beginPath();
                ctx.moveTo(0, -18 * s);
                ctx.quadraticCurveTo(-8 * s, -30 * s, 0, -40 * s * petalPulse);
                ctx.quadraticCurveTo(8 * s, -30 * s, 0, -18 * s);
                ctx.fill();
                ctx.fillStyle = grad;
                ctx.restore();
            }
            
            // å†…å±‚å°èŠ±ç“£
            ctx.fillStyle = isHit ? '#fff' : lightenColor(color, 20);
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + Math.PI / 8 - petalWave;
                ctx.save();
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.ellipse(0, -22 * s * pulse, 8 * s, 15 * s, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            
            // èŠ±å¿ƒ - å¤šå±‚ç»“æ„
            const centerGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 22 * s);
            centerGrad.addColorStop(0, isHit ? '#fff' : '#ffff80');
            centerGrad.addColorStop(0.5, isHit ? '#fff' : '#ffcc00');
            centerGrad.addColorStop(1, isHit ? '#fff' : '#ff9900');
            ctx.fillStyle = centerGrad;
            ctx.beginPath();
            ctx.arc(0, 0, 22 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // èŠ±å¿ƒçº¹ç† - å°åœ†ç‚¹
            ctx.fillStyle = isHit ? 'rgba(255,255,255,0.6)' : 'rgba(200,100,0,0.4)';
            for (let i = 0; i < 12; i++) {
                const dotAngle = (i / 12) * Math.PI * 2 + time;
                const dotR = 12 * s;
                ctx.beginPath();
                ctx.arc(Math.cos(dotAngle) * dotR, Math.sin(dotAngle) * dotR, 3 * s, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // é£˜è½èŠ±ç“£
            ctx.fillStyle = isHit ? 'rgba(255,255,255,0.7)' : 'rgba(255,180,200,0.6)';
            for (let i = 0; i < 5; i++) {
                const px = Math.sin(time * 0.8 + i * 1.3) * 55 * s;
                const py = Math.cos(time * 0.6 + i) * 50 * s + (time * 10 + i * 20) % 60 * s - 30 * s;
                ctx.save();
                ctx.translate(px, py);
                ctx.rotate(time + i);
                ctx.beginPath();
                ctx.ellipse(0, 0, 4 * s, 6 * s, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            
            drawBossEyes(s, 0, isHit, 5);
        }
        
        // Bossé€ å‹: å‰‘åˆƒå½¢ - æš—å½±åœ£å‰‘
        function drawBossBlade(s, grad, color, isHit, wave) {
            const time = Date.now() * 0.003;
            
            // å‰‘æ°”å…‰æ™•
            const bladeGlow = ctx.createRadialGradient(0, 0, 5 * s, 0, 0, 60 * s);
            bladeGlow.addColorStop(0, `rgba(${parseInt(color.slice(1,3),16)}, ${parseInt(color.slice(3,5),16)}, ${parseInt(color.slice(5,7),16)}, 0.3)`);
            bladeGlow.addColorStop(1, 'rgba(150,150,200,0)');
            ctx.fillStyle = bladeGlow;
            ctx.beginPath();
            ctx.ellipse(0, 0, 50 * s, 80 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // å‰‘èº« - ç²¾ç»†åŒåˆƒ
            const bladeGrad = ctx.createLinearGradient(-20 * s, 0, 20 * s, 0);
            bladeGrad.addColorStop(0, darkenColor(color, 20));
            bladeGrad.addColorStop(0.3, color);
            bladeGrad.addColorStop(0.5, isHit ? '#fff' : lightenColor(color, 40));
            bladeGrad.addColorStop(0.7, color);
            bladeGrad.addColorStop(1, darkenColor(color, 20));
            ctx.fillStyle = bladeGrad;
            ctx.beginPath();
            ctx.moveTo(0, -68 * s);
            ctx.lineTo(18 * s, 15 * s);
            ctx.lineTo(12 * s, 22 * s);
            ctx.lineTo(0, 55 * s);
            ctx.lineTo(-12 * s, 22 * s);
            ctx.lineTo(-18 * s, 15 * s);
            ctx.closePath();
            ctx.fill();
            
            // å‰‘èº«ä¸­å¿ƒçº¿
            ctx.strokeStyle = isHit ? '#fff' : 'rgba(255,255,255,0.6)';
            ctx.lineWidth = 2 * s;
            ctx.beginPath();
            ctx.moveTo(0, -60 * s);
            ctx.lineTo(0, 45 * s);
            ctx.stroke();
            
            // å‰‘èº«çº¹è·¯ - æ³¢çº¹
            ctx.strokeStyle = isHit ? 'rgba(255,255,255,0.5)' : 'rgba(200,200,255,0.4)';
            ctx.lineWidth = 1 * s;
            for (let i = 0; i < 5; i++) {
                const waveY = (-45 + i * 18) * s;
                ctx.beginPath();
                ctx.moveTo(-10 * s, waveY);
                ctx.quadraticCurveTo(0, waveY + 5 * s * Math.sin(time + i), 10 * s, waveY);
                ctx.stroke();
            }
            
            // å‰‘åˆƒå°–ç«¯å…‰èŠ’
            ctx.fillStyle = isHit ? '#fff' : 'rgba(255,255,200,0.9)';
            ctx.beginPath();
            ctx.arc(0, -68 * s, (3 + Math.sin(time * 4) * 1.5) * s, 0, Math.PI * 2);
            ctx.fill();
            
            // åä¸½å‰‘æ ¼
            const guardGrad = ctx.createLinearGradient(-35 * s, 20 * s, 35 * s, 20 * s);
            guardGrad.addColorStop(0, '#8B4513');
            guardGrad.addColorStop(0.2, '#FFD700');
            guardGrad.addColorStop(0.5, '#FFFACD');
            guardGrad.addColorStop(0.8, '#FFD700');
            guardGrad.addColorStop(1, '#8B4513');
            ctx.fillStyle = isHit ? '#fff' : guardGrad;
            ctx.beginPath();
            ctx.moveTo(-35 * s, 18 * s);
            ctx.quadraticCurveTo(-38 * s, 22 * s, -35 * s, 26 * s);
            ctx.lineTo(35 * s, 26 * s);
            ctx.quadraticCurveTo(38 * s, 22 * s, 35 * s, 18 * s);
            ctx.closePath();
            ctx.fill();
            // å‰‘æ ¼å®çŸ³
            ctx.fillStyle = isHit ? '#fff' : '#ff0000';
            ctx.beginPath();
            ctx.arc(0, 22 * s, 6 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            ctx.beginPath();
            ctx.arc(-2 * s, 20 * s, 2 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // å‰‘æŸ„
            const hiltGrad = ctx.createLinearGradient(-10 * s, 28 * s, 10 * s, 28 * s);
            hiltGrad.addColorStop(0, '#4a3520');
            hiltGrad.addColorStop(0.5, '#8B4513');
            hiltGrad.addColorStop(1, '#4a3520');
            ctx.fillStyle = isHit ? '#fff' : hiltGrad;
            ctx.beginPath();
            ctx.roundRect(-9 * s, 28 * s, 18 * s, 32 * s, 3 * s);
            ctx.fill();
            // å‰‘æŸ„ç¼ ç»•
            ctx.strokeStyle = isHit ? '#fff' : '#DAA520';
            ctx.lineWidth = 2 * s;
            for (let i = 0; i < 4; i++) {
                ctx.beginPath();
                ctx.moveTo(-8 * s, (32 + i * 7) * s);
                ctx.lineTo(8 * s, (35 + i * 7) * s);
                ctx.stroke();
            }
            
            // å‰‘é¦–
            ctx.fillStyle = isHit ? '#fff' : '#FFD700';
            ctx.beginPath();
            ctx.arc(0, 62 * s, 8 * s, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Bossé€ å‹: å·¨äººå½¢ - æ˜Ÿç©ºå·¨äºº
        function drawBossGiant(s, grad, color, isHit, pulse) {
            const time = Date.now() * 0.002;
            
            // å·¨äººå…‰æ™•
            const giantGlow = ctx.createRadialGradient(0, 0, 20 * s, 0, 0, 80 * s);
            giantGlow.addColorStop(0, `rgba(${parseInt(color.slice(1,3),16)}, ${parseInt(color.slice(3,5),16)}, ${parseInt(color.slice(5,7),16)}, 0.2)`);
            giantGlow.addColorStop(1, 'rgba(100,100,150,0)');
            ctx.fillStyle = giantGlow;
            ctx.beginPath();
            ctx.arc(0, 0, 80 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // å·¨å¤§èº«ä½“ - ç›”ç”²çº¹ç†
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.moveTo(-28 * s, -22 * s);
            ctx.lineTo(-32 * s, 48 * s);
            ctx.lineTo(32 * s, 48 * s);
            ctx.lineTo(28 * s, -22 * s);
            ctx.closePath();
            ctx.fill();
            
            // èƒ¸ç”²çº¹ç†
            ctx.fillStyle = isHit ? 'rgba(255,255,255,0.4)' : 'rgba(0,0,0,0.2)';
            ctx.beginPath();
            ctx.moveTo(-20 * s, -15 * s);
            ctx.lineTo(0, 5 * s);
            ctx.lineTo(20 * s, -15 * s);
            ctx.lineTo(20 * s, 40 * s);
            ctx.lineTo(0, 25 * s);
            ctx.lineTo(-20 * s, 40 * s);
            ctx.closePath();
            ctx.fill();
            
            // è‚©ç”²
            ctx.fillStyle = grad;
            // å·¦è‚©
            ctx.beginPath();
            ctx.ellipse(-38 * s, -15 * s, 15 * s, 12 * s, -0.3, 0, Math.PI * 2);
            ctx.fill();
            // å³è‚©
            ctx.beginPath();
            ctx.ellipse(38 * s, -15 * s, 15 * s, 12 * s, 0.3, 0, Math.PI * 2);
            ctx.fill();
            
            // å·¨å¤§æ‰‹è‡‚
            const armSwing = Math.sin(time * 2) * 0.1;
            // å·¦è‡‚
            ctx.save();
            ctx.translate(-45 * s, -5 * s);
            ctx.rotate(armSwing);
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.roundRect(-12 * s, 0, 24 * s, 55 * s, 8 * s);
            ctx.fill();
            // å·¦æ‹³
            ctx.beginPath();
            ctx.arc(0, 58 * s, 15 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            // å³è‡‚
            ctx.save();
            ctx.translate(45 * s, -5 * s);
            ctx.rotate(-armSwing);
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.roundRect(-12 * s, 0, 24 * s, 55 * s, 8 * s);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(0, 58 * s, 15 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            // å¤´éƒ¨ - å¤´ç›”
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(0, -38 * s, 26 * s * pulse, 0, Math.PI * 2);
            ctx.fill();
            
            // å¤´ç›”è£…é¥°
            ctx.fillStyle = isHit ? '#fff' : 'rgba(255,215,0,0.8)';
            // å¤´ç›”ç¾½æ¯›
            ctx.beginPath();
            ctx.moveTo(-5 * s, -60 * s);
            ctx.quadraticCurveTo(0, -75 * s, 5 * s, -60 * s);
            ctx.quadraticCurveTo(0, -65 * s, -5 * s, -60 * s);
            ctx.fill();
            // å¤´ç›”å‰é¢è£…é¥°
            ctx.beginPath();
            ctx.moveTo(-15 * s, -55 * s);
            ctx.lineTo(0, -48 * s);
            ctx.lineTo(15 * s, -55 * s);
            ctx.lineTo(0, -58 * s);
            ctx.closePath();
            ctx.fill();
            
            // å‘å…‰çº¹ç†
            ctx.fillStyle = isHit ? '#fff' : 'rgba(150,200,255,0.5)';
            for (let i = 0; i < 4; i++) {
                const runeAngle = time + i * Math.PI / 2;
                const runeX = Math.cos(runeAngle) * 18 * s;
                const runeY = 15 * s + Math.sin(runeAngle) * 18 * s;
                ctx.beginPath();
                ctx.arc(runeX, runeY, (2 + Math.sin(time * 3 + i)) * s, 0, Math.PI * 2);
                ctx.fill();
            }
            
            drawBossEyes(s, -38, isHit, 9);
        }
        
        // Bossé€ å‹: çœ¼ç›å½¢ - é£æš´ä¹‹çœ¼
        function drawBossEye(s, grad, color, isHit, pulse) {
            const time = Date.now() * 0.002;
            
            // ç¥ç§˜å…‰æ™•
            const eyeGlow = ctx.createRadialGradient(0, 0, 10 * s, 0, 0, 70 * s);
            eyeGlow.addColorStop(0, `rgba(${parseInt(color.slice(1,3),16)}, ${parseInt(color.slice(3,5),16)}, ${parseInt(color.slice(5,7),16)}, 0.4)`);
            eyeGlow.addColorStop(0.5, 'rgba(100,50,150,0.2)');
            eyeGlow.addColorStop(1, 'rgba(50,0,100,0)');
            ctx.fillStyle = eyeGlow;
            ctx.beginPath();
            ctx.arc(0, 0, 70 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // çœ‰æ¯›/çœ¼çœ¶
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.ellipse(0, -8 * s, 55 * s, 20 * s, 0, Math.PI, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(0, 8 * s, 55 * s, 20 * s, 0, 0, Math.PI);
            ctx.fill();
            
            // å¤–çœ¼çœ¶ - å¸¦çº¹ç†
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.ellipse(0, 0, 52 * s, 38 * s * pulse, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // çœ¼çœ¶çº¹ç†
            ctx.strokeStyle = isHit ? 'rgba(255,255,255,0.4)' : 'rgba(0,0,0,0.2)';
            ctx.lineWidth = 1.5 * s;
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                ctx.beginPath();
                ctx.moveTo(Math.cos(angle) * 35 * s, Math.sin(angle) * 25 * s * pulse);
                ctx.lineTo(Math.cos(angle) * 50 * s, Math.sin(angle) * 36 * s * pulse);
                ctx.stroke();
            }
            
            // çœ¼ç™½ - å¤šå±‚æ¸å˜
            const whiteGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 38 * s);
            whiteGrad.addColorStop(0, '#ffffff');
            whiteGrad.addColorStop(0.7, '#f5f5f5');
            whiteGrad.addColorStop(1, isHit ? '#fff' : '#e8e0e8');
            ctx.fillStyle = whiteGrad;
            ctx.beginPath();
            ctx.ellipse(0, 0, 38 * s, 28 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // è™¹è†œ - å¤æ‚çº¹ç†
            const irisGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 22 * s);
            irisGrad.addColorStop(0, isHit ? '#fff' : '#000');
            irisGrad.addColorStop(0.3, isHit ? '#ccc' : darkenColor(color, 30));
            irisGrad.addColorStop(0.6, isHit ? '#aaa' : color);
            irisGrad.addColorStop(1, isHit ? '#888' : lightenColor(color, 20));
            ctx.fillStyle = irisGrad;
            ctx.beginPath();
            ctx.arc(0, 0, 22 * s * pulse, 0, Math.PI * 2);
            ctx.fill();
            
            // è™¹è†œçº¹ç† - æ”¾å°„çŠ¶
            ctx.strokeStyle = isHit ? 'rgba(255,255,255,0.3)' : 'rgba(0,0,0,0.2)';
            ctx.lineWidth = 0.5 * s;
            for (let i = 0; i < 24; i++) {
                const angle = (i / 24) * Math.PI * 2 + time * 0.5;
                ctx.beginPath();
                ctx.moveTo(Math.cos(angle) * 8 * s, Math.sin(angle) * 8 * s);
                ctx.lineTo(Math.cos(angle) * 20 * s * pulse, Math.sin(angle) * 20 * s * pulse);
                ctx.stroke();
            }
            
            // çœµå­”
            ctx.fillStyle = isHit ? '#444' : '#000008';
            ctx.beginPath();
            ctx.arc(0, 0, 10 * s * pulse, 0, Math.PI * 2);
            ctx.fill();
            
            // é«˜å…‰ - å¤šä¸ª
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.beginPath();
            ctx.arc(-8 * s, -8 * s, 7 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(5 * s, -5 * s, 3 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(-4 * s, 6 * s, 2 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // ç¥ç§˜ç¬¦æ–‡ç¯ç»•
            ctx.strokeStyle = isHit ? 'rgba(255,255,255,0.5)' : 'rgba(150,100,200,0.4)';
            ctx.lineWidth = 1.5 * s;
            ctx.beginPath();
            ctx.arc(0, 0, 60 * s, time, time + Math.PI * 0.7);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(0, 0, 60 * s, time + Math.PI, time + Math.PI * 1.7);
            ctx.stroke();
        }
        
        // Bossé€ å‹: å¤©ä½¿å½¢ - åœ£å…‰å¤©ä½¿
        function drawBossAngel(s, grad, color, isHit, wave) {
            const time = Date.now() * 0.002;
            const wingFlap = Math.sin(time * 4) * 0.15;
            
            // åœ£å…‰å…‰æ™•
            const angelGlow = ctx.createRadialGradient(0, 0, 10 * s, 0, 0, 80 * s);
            angelGlow.addColorStop(0, 'rgba(255,255,200,0.4)');
            angelGlow.addColorStop(0.5, 'rgba(255,220,150,0.2)');
            angelGlow.addColorStop(1, 'rgba(255,200,100,0)');
            ctx.fillStyle = angelGlow;
            ctx.beginPath();
            ctx.arc(0, 0, 80 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // ç¾½æ¯›ç¿…è†€ - å¤šå±‚
            const wingLayers = 3;
            for (let layer = wingLayers - 1; layer >= 0; layer--) {
                const layerScale = 1 - layer * 0.15;
                const layerAlpha = 1 - layer * 0.2;
                
                ctx.save();
                ctx.rotate(wingFlap * (1 + layer * 0.3));
                
                // å·¦ç¿…
                ctx.fillStyle = layer === 0 ? grad : `rgba(255,255,255,${layerAlpha * 0.7})`;
                ctx.beginPath();
                ctx.moveTo(-18 * s, 5 * s);
                // å¤šä¸ªç¾½æ¯›å±‚æ¬¡
                for (let i = 0; i < 5; i++) {
                    const featherAngle = -0.8 + i * 0.4;
                    const featherLen = (55 + i * 8) * layerScale * s;
                    const featherWave = Math.sin(time * 3 + i * 0.5) * 3 * s;
                    ctx.quadraticCurveTo(
                        -30 * s + featherWave, (-15 + i * 8) * s,
                        Math.cos(featherAngle) * featherLen - 20 * s, Math.sin(featherAngle) * featherLen * 0.6
                    );
                }
                ctx.quadraticCurveTo(-40 * s, 25 * s, -18 * s, 20 * s);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
                
                ctx.save();
                ctx.rotate(-wingFlap * (1 + layer * 0.3));
                // å³ç¿…
                ctx.fillStyle = layer === 0 ? grad : `rgba(255,255,255,${layerAlpha * 0.7})`;
                ctx.beginPath();
                ctx.moveTo(18 * s, 5 * s);
                for (let i = 0; i < 5; i++) {
                    const featherAngle = Math.PI + 0.8 - i * 0.4;
                    const featherLen = (55 + i * 8) * layerScale * s;
                    const featherWave = Math.sin(time * 3 + i * 0.5) * 3 * s;
                    ctx.quadraticCurveTo(
                        30 * s - featherWave, (-15 + i * 8) * s,
                        -Math.cos(featherAngle) * featherLen + 20 * s, -Math.sin(featherAngle) * featherLen * 0.6
                    );
                }
                ctx.quadraticCurveTo(40 * s, 25 * s, 18 * s, 20 * s);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
            
            // å…‰ç¾½æ•£è½
            ctx.fillStyle = isHit ? '#fff' : 'rgba(255,255,200,0.6)';
            for (let i = 0; i < 6; i++) {
                const fx = Math.sin(time * 0.5 + i * 1.1) * 60 * s;
                const fy = (time * 20 + i * 30) % 100 * s - 50 * s;
                ctx.save();
                ctx.translate(fx, fy);
                ctx.rotate(time + i);
                ctx.beginPath();
                ctx.ellipse(0, 0, 3 * s, 8 * s, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            
            // èº«ä½“ - é•¿è¢
            const robeGrad = ctx.createLinearGradient(0, -10 * s, 0, 50 * s);
            robeGrad.addColorStop(0, color);
            robeGrad.addColorStop(1, isHit ? '#fff' : lightenColor(color, 30));
            ctx.fillStyle = robeGrad;
            ctx.beginPath();
            ctx.moveTo(-15 * s, -10 * s);
            ctx.quadraticCurveTo(-22 * s, 20 * s, -25 * s, 50 * s);
            ctx.lineTo(25 * s, 50 * s);
            ctx.quadraticCurveTo(22 * s, 20 * s, 15 * s, -10 * s);
            ctx.closePath();
            ctx.fill();
            
            // è¢å­çº¹ç†
            ctx.strokeStyle = isHit ? 'rgba(255,255,255,0.5)' : 'rgba(255,215,0,0.4)';
            ctx.lineWidth = 1.5 * s;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.moveTo((-12 + i * 12) * s, 0);
                ctx.lineTo((-15 + i * 15) * s, 45 * s);
                ctx.stroke();
            }
            
            // å…‰ç¯ - å‘å…‰
            const haloGlow = ctx.createRadialGradient(0, -52 * s, 5 * s, 0, -52 * s, 25 * s);
            haloGlow.addColorStop(0, 'rgba(255,215,0,0.8)');
            haloGlow.addColorStop(1, 'rgba(255,200,100,0)');
            ctx.fillStyle = haloGlow;
            ctx.beginPath();
            ctx.ellipse(0, -52 * s, 25 * s, 10 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = isHit ? '#fff' : '#FFD700';
            ctx.lineWidth = 3 * s;
            ctx.beginPath();
            ctx.ellipse(0, -52 * s, 20 * s, 7 * s, 0, 0, Math.PI * 2);
            ctx.stroke();
            
            // å¤´éƒ¨
            ctx.fillStyle = isHit ? '#fff' : 'rgba(255,230,210,0.98)';
            ctx.beginPath();
            ctx.arc(0, -28 * s, 16 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // å¤´å‘
            ctx.fillStyle = isHit ? '#fff' : '#FFD700';
            ctx.beginPath();
            ctx.arc(0, -30 * s, 14 * s, Math.PI, Math.PI * 2);
            ctx.fill();
            
            drawBossEyes(s, -28, isHit, 5);
        }
        
        // Bossé€ å‹: æ··æ²Œå½¢ - è™šç©ºä¹‹å¿ƒ
        function drawBossChaos(s, grad, color, isHit, wave, animTime) {
            const time = Date.now() * 0.002;
            
            // æ··æ²Œå…‰æ™• - å¤šå±‚
            const chaosGlow = ctx.createRadialGradient(0, 0, 5 * s, 0, 0, 75 * s);
            chaosGlow.addColorStop(0, 'rgba(100,0,150,0.5)');
            chaosGlow.addColorStop(0.3, `rgba(${parseInt(color.slice(1,3),16)}, ${parseInt(color.slice(3,5),16)}, ${parseInt(color.slice(5,7),16)}, 0.3)`);
            chaosGlow.addColorStop(0.7, 'rgba(50,0,100,0.15)');
            chaosGlow.addColorStop(1, 'rgba(0,0,50,0)');
            ctx.fillStyle = chaosGlow;
            ctx.beginPath();
            ctx.arc(0, 0, 75 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // è§¦æ‰‹çŠ¶çªèµ·
            ctx.fillStyle = grad;
            for (let i = 0; i < 8; i++) {
                const tentAngle = (i / 8) * Math.PI * 2 + time * 0.5;
                const tentLen = (40 + Math.sin(time * 2 + i * 0.8) * 15) * s;
                const tentWave = Math.sin(time * 3 + i) * 10 * s;
                
                ctx.beginPath();
                ctx.moveTo(Math.cos(tentAngle) * 25 * s, Math.sin(tentAngle) * 25 * s);
                ctx.quadraticCurveTo(
                    Math.cos(tentAngle + 0.2) * (tentLen * 0.6) + tentWave,
                    Math.sin(tentAngle + 0.2) * (tentLen * 0.6),
                    Math.cos(tentAngle) * tentLen,
                    Math.sin(tentAngle) * tentLen
                );
                ctx.quadraticCurveTo(
                    Math.cos(tentAngle - 0.2) * (tentLen * 0.6) - tentWave,
                    Math.sin(tentAngle - 0.2) * (tentLen * 0.6),
                    Math.cos(tentAngle) * 25 * s,
                    Math.sin(tentAngle) * 25 * s
                );
                ctx.fill();
            }
            
            // æ ¸å¿ƒ - ä¸è§„åˆ™å½¢çŠ¶
            ctx.fillStyle = grad;
            ctx.beginPath();
            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2 + time;
                const r = (30 + Math.sin(time * 3 + i * 1.5) * 10) * s;
                const x = Math.cos(angle) * r;
                const y = Math.sin(angle) * r;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            
            // æ··æ²Œæ¼©æ¶¡
            ctx.strokeStyle = isHit ? 'rgba(255,255,255,0.5)' : 'rgba(150,0,200,0.4)';
            ctx.lineWidth = 2 * s;
            for (let i = 0; i < 3; i++) {
                const spiralR = (15 + i * 12) * s;
                ctx.beginPath();
                for (let j = 0; j < 50; j++) {
                    const t = j / 50;
                    const spiralAngle = t * Math.PI * 4 + time * (1 + i * 0.3);
                    const sr = spiralR * t;
                    const sx = Math.cos(spiralAngle) * sr;
                    const sy = Math.sin(spiralAngle) * sr;
                    if (j === 0) ctx.moveTo(sx, sy);
                    else ctx.lineTo(sx, sy);
                }
                ctx.stroke();
            }
            
            // å¤šçœ¼ - æ›´å¤šæ›´ç²¾ç»†
            const eyePositions = [
                {x: 0, y: 0, size: 1.2},
                {x: Math.cos(time * 0.5) * 18, y: Math.sin(time * 0.7) * 18, size: 0.8},
                {x: Math.cos(time * 0.5 + 2) * 15, y: Math.sin(time * 0.7 + 2) * 15, size: 0.7},
                {x: Math.cos(time * 0.5 + 4) * 20, y: Math.sin(time * 0.7 + 4) * 12, size: 0.6},
                {x: Math.cos(time * 0.3) * 8, y: Math.sin(time * 0.4) * 22, size: 0.5}
            ];
            
            eyePositions.forEach((eye, i) => {
                const ex = eye.x * s;
                const ey = eye.y * s;
                const eSize = 10 * eye.size * s;
                
                // çœ¼ç™½
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(ex, ey, eSize, 0, Math.PI * 2);
                ctx.fill();
                
                // è™¹è†œ
                const irisColor = isHit ? '#888' : ['#400040', '#004040', '#400000', '#004000', '#000040'][i];
                ctx.fillStyle = irisColor;
                ctx.beginPath();
                ctx.arc(ex, ey, eSize * 0.6, 0, Math.PI * 2);
                ctx.fill();
                
                // çœµå­”
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(ex, ey, eSize * 0.3, 0, Math.PI * 2);
                ctx.fill();
                
                // é«˜å…‰
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                ctx.beginPath();
                ctx.arc(ex - eSize * 0.25, ey - eSize * 0.25, eSize * 0.2, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // æ··æ²Œç²’å­
            ctx.fillStyle = isHit ? '#fff' : 'rgba(200,100,255,0.6)';
            for (let i = 0; i < 10; i++) {
                const px = Math.sin(time * 1.5 + i * 0.7) * (30 + i * 5) * s;
                const py = Math.cos(time + i * 0.9) * (25 + i * 4) * s;
                ctx.beginPath();
                ctx.arc(px, py, (1 + Math.sin(time * 4 + i)) * s, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // é€šç”¨Bossçœ¼ç›ç»˜åˆ¶ - å¢å¼ºç‰ˆ
        function drawBossEyes(s, yOffset, isHit, size = 12, evil = false) {
            const time = Date.now() * 0.003;
            const eyeSize = size * s;
            const y = yOffset * s;
            const lookX = Math.sin(time * 0.5) * 2 * s; // çœ¼çƒè½»å¾®è½¬åŠ¨
            const lookY = Math.cos(time * 0.7) * 1 * s;
            
            // çœ¼çªé˜´å½±
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.beginPath();
            ctx.ellipse(-15 * s, y + 2 * s, eyeSize * 1.1, eyeSize * 0.9, 0, 0, Math.PI * 2);
            ctx.ellipse(15 * s, y + 2 * s, eyeSize * 1.1, eyeSize * 0.9, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // çœ¼ç™½ - æ¸å˜
            const whiteGrad = ctx.createRadialGradient(-15 * s, y, 0, -15 * s, y, eyeSize);
            whiteGrad.addColorStop(0, '#ffffff');
            whiteGrad.addColorStop(0.8, '#f8f8f8');
            whiteGrad.addColorStop(1, '#e8e8e8');
            ctx.fillStyle = whiteGrad;
            ctx.beginPath();
            ctx.arc(-15 * s, y, eyeSize, 0, Math.PI * 2);
            ctx.fill();
            
            const whiteGrad2 = ctx.createRadialGradient(15 * s, y, 0, 15 * s, y, eyeSize);
            whiteGrad2.addColorStop(0, '#ffffff');
            whiteGrad2.addColorStop(0.8, '#f8f8f8');
            whiteGrad2.addColorStop(1, '#e8e8e8');
            ctx.fillStyle = whiteGrad2;
            ctx.beginPath();
            ctx.arc(15 * s, y, eyeSize, 0, Math.PI * 2);
            ctx.fill();
            
            // çœ¼çƒ/è™¹è†œ
            const irisColor = isHit ? '#666' : (evil ? '#aa0000' : '#1a1a3e');
            const irisGrad = ctx.createRadialGradient(-15 * s + lookX, y + lookY, 0, -15 * s + lookX, y + lookY, eyeSize * 0.55);
            irisGrad.addColorStop(0, isHit ? '#444' : '#000');
            irisGrad.addColorStop(0.5, irisColor);
            irisGrad.addColorStop(1, isHit ? '#888' : (evil ? '#660000' : '#0a0a1e'));
            ctx.fillStyle = irisGrad;
            ctx.beginPath();
            ctx.arc(-15 * s + lookX, y + lookY, eyeSize * 0.55, 0, Math.PI * 2);
            ctx.fill();
            
            const irisGrad2 = ctx.createRadialGradient(15 * s + lookX, y + lookY, 0, 15 * s + lookX, y + lookY, eyeSize * 0.55);
            irisGrad2.addColorStop(0, isHit ? '#444' : '#000');
            irisGrad2.addColorStop(0.5, irisColor);
            irisGrad2.addColorStop(1, isHit ? '#888' : (evil ? '#660000' : '#0a0a1e'));
            ctx.fillStyle = irisGrad2;
            ctx.beginPath();
            ctx.arc(15 * s + lookX, y + lookY, eyeSize * 0.55, 0, Math.PI * 2);
            ctx.fill();
            
            // çœµå­”
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(-15 * s + lookX, y + lookY, eyeSize * 0.25, 0, Math.PI * 2);
            ctx.arc(15 * s + lookX, y + lookY, eyeSize * 0.25, 0, Math.PI * 2);
            ctx.fill();
            
            // ä¸»é«˜å…‰
            ctx.fillStyle = 'rgba(255,255,255,0.95)';
            ctx.beginPath();
            ctx.arc(-13 * s, y - eyeSize * 0.25, eyeSize * 0.28, 0, Math.PI * 2);
            ctx.arc(17 * s, y - eyeSize * 0.25, eyeSize * 0.28, 0, Math.PI * 2);
            ctx.fill();
            
            // æ¬¡é«˜å…‰
            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            ctx.beginPath();
            ctx.arc(-17 * s, y + eyeSize * 0.15, eyeSize * 0.12, 0, Math.PI * 2);
            ctx.arc(13 * s, y + eyeSize * 0.15, eyeSize * 0.12, 0, Math.PI * 2);
            ctx.fill();
            
            // é‚ªæ¶çœ¼çš„é¢å¤–æ•ˆæœ
            if (evil && !isHit) {
                ctx.fillStyle = 'rgba(255,0,0,0.15)';
                ctx.beginPath();
                ctx.arc(-15 * s, y, eyeSize * 1.2, 0, Math.PI * 2);
                ctx.arc(15 * s, y, eyeSize * 1.2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // === Bosså‘½ä¸­è·¯å¾„ï¼ˆç®€åŒ–ä¸ºæ¤­åœ†å½¢ï¼‰===
        function buildBossHitPath(enemy) {
            const s = (enemy.width || 100) / 80;
            const p = new Path2D();
            // ç®€åŒ–ä¸ºæ¤­åœ†å½¢é±¼èº«
            p.ellipse(0, 0, 35 * s, 50 * s, 0, 0, Math.PI * 2);
            return p;
        }

        // ç»˜åˆ¶æ•Œäºº
        function drawEnemies() {
            // å…ˆç»˜åˆ¶æ²»æ„ˆè¿æ¥çº¿ï¼ˆåœ¨æ•Œäººä¸‹æ–¹ï¼‰
            for (let i = 0, len = enemies.length; i < len; i++) {
                const healer = enemies[i];
                if (healer.type !== 'healer') continue;
                
                const isHealing = healer.healCooldown <= 30;
                const healRange = healer.healRange || 150;
                
                for (let j = 0; j < len; j++) {
                    const target = enemies[j];
                    if (target === healer || target.type === 'boss') continue;
                    if (target.hp >= target.maxHp) continue;
                    
                    const dx = target.x - healer.x;
                    const dy = target.y - healer.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist <= healRange) {
                        ctx.save();
                        
                        const lineAlpha = isHealing ? 0.6 : 0.25;
                        const lineWidth = isHealing ? 2.5 : 1.5;
                        
                        const gradient = ctx.createLinearGradient(healer.x, healer.y, target.x, target.y);
                        gradient.addColorStop(0, `rgba(46, 204, 113, ${lineAlpha})`);
                        gradient.addColorStop(0.5, `rgba(100, 255, 150, ${lineAlpha * 0.8})`);
                        gradient.addColorStop(1, `rgba(46, 204, 113, ${lineAlpha * 0.5})`);
                        
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = lineWidth;
                        ctx.shadowColor = '#2ecc71';
                        ctx.shadowBlur = isHealing ? 8 : 3;
                        
                        ctx.beginPath();
                        ctx.moveTo(healer.x, healer.y);
                        ctx.lineTo(target.x, target.y);
                        ctx.stroke();
                        
                        if (isHealing) {
                            const t = ((gameState.elapsedFrames || 0) % 60) / 60;
                            const px = healer.x + dx * t;
                            const py = healer.y + dy * t;
                            ctx.fillStyle = 'rgba(150, 255, 200, 0.8)';
                            ctx.beginPath();
                            ctx.arc(px, py, 4, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        ctx.restore();
                    }
                }
            }
            
            // ç»˜åˆ¶æ•Œäººæœ¬ä½“
            for (let i = 0, len = enemies.length; i < len; i++) {
                const enemy = enemies[i];
                ctx.save();
                ctx.translate(enemy.x, enemy.y);
                
                // æ²»æ„ˆç‰¹æ•ˆï¼ˆç»¿è‰²å…‰ç¯ï¼‰
                if (enemy.healFlash && enemy.healFlash > 0) {
                    const healAlpha = enemy.healFlash / 15;
                    ctx.fillStyle = `rgba(46, 204, 113, ${healAlpha * 0.4})`;
                    ctx.beginPath();
                    ctx.arc(0, 0, Math.max(enemy.width, enemy.height) * 0.8, 0, Math.PI * 2);
                    ctx.fill();
                    enemy.healFlash--;
                }
                
                if (enemy.type === 'boss') {
                    // Bossä¸æ—‹è½¬ï¼Œç»˜åˆ¶å‡½æ•°å†…éƒ¨å·²è°ƒæ•´ä¸ºå¤´æœä¸‹
                    drawBossLarge(enemy);
                } else {
                    // æ™®é€šæ•Œäººæ—‹è½¬180åº¦ï¼Œä½¿å¤´æœä¸‹
                    ctx.rotate(Math.PI);
                    drawEnemySmall(enemy);
                }
                if (enemy.hitFlash > 0) enemy.hitFlash--;
                ctx.restore();
            }
        }

        // ç»˜åˆ¶èªä»”æœº
        function drawPowerUps() {
            powerUps.forEach(p => {
                ctx.save();
                ctx.translate(p.x, p.y);
                
                // åŠ¨ç”»è®¡æ—¶
                p.animTime = (p.animTime || 0) + 0.08;
                const pulse = 1 + Math.sin(p.animTime) * 0.1; // å‘¼å¸æ•ˆæœ
                const floatY = Math.sin(p.animTime * 0.8) * 3; // æ¼‚æµ®æ•ˆæœ
                
                ctx.translate(0, floatY);
                ctx.scale(pulse, pulse);
                
                // å¤–å±‚å…‰æ™•
                const outerGlow = ctx.createRadialGradient(0, 0, 15, 0, 0, 40);
                outerGlow.addColorStop(0, p.color + '60');
                outerGlow.addColorStop(0.6, p.color + '20');
                outerGlow.addColorStop(1, 'transparent');
                ctx.fillStyle = outerGlow;
                ctx.beginPath();
                ctx.arc(0, 0, 40, 0, Math.PI * 2);
                ctx.fill();
                
                // å†…å±‚åœ†å½¢èƒŒæ™¯
                const innerGrad = ctx.createRadialGradient(0, -8, 0, 0, 5, 25);
                innerGrad.addColorStop(0, '#ffffff');
                innerGrad.addColorStop(0.3, p.color);
                innerGrad.addColorStop(1, p.color + '88');
                ctx.fillStyle = innerGrad;
                ctx.shadowColor = p.color;
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(0, 0, 22, 0, Math.PI * 2);
                ctx.fill();
                
                // é‡‘è‰²è¾¹æ¡†
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 8;
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                // é“å…·å›¾æ ‡
                ctx.font = 'bold 22px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#fff';
                ctx.fillText(p.icon, 0, 1);
                
                // é—ªå…‰ç‚¹
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                ctx.beginPath();
                ctx.arc(-8, -8, 4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            });
        }

        // ç»˜åˆ¶çˆ†ç‚¸æ•ˆæœï¼ˆä»åå‘å‰éå†ä»¥é¿å…spliceç´¢å¼•é—®é¢˜ï¼‰
        function drawExplosions() {
            for (let index = explosions.length - 1; index >= 0; index--) {
                const exp = explosions[index];
                const progress = exp.frame / exp.maxFrame;
                const radius = exp.maxRadius * progress;
                const alpha = 1 - progress;
                
                // æ ¹æ®ç­‰çº§é€‰æ‹©é¢œè‰²
                const colors = exp.colors || { inner: [255,255,200], mid: [255,150,50], outer: [255,50,0] };
                
                // å¤šå±‚çˆ†ç‚¸æ•ˆæœ
                const layers = exp.layers || 4;
                for (let i = layers - 1; i >= 0; i--) {
                    const layerRadius = radius * (1 - i * 0.15);
                    const layerAlpha = alpha * (1 - i * 0.15);
                    
                    const gradient = ctx.createRadialGradient(
                        exp.x, exp.y, 0,
                        exp.x, exp.y, layerRadius
                    );
                    gradient.addColorStop(0, `rgba(${colors.inner.join(',')}, ${layerAlpha})`);
                    gradient.addColorStop(0.3, `rgba(${colors.mid.join(',')}, ${layerAlpha * 0.8})`);
                    gradient.addColorStop(0.6, `rgba(${colors.outer.join(',')}, ${layerAlpha * 0.5})`);
                    gradient.addColorStop(1, 'rgba(100, 0, 0, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(exp.x, exp.y, layerRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // ç²’å­æ•ˆæœï¼ˆä½¿ç”¨ for å¾ªç¯é¿å…é—­åŒ…ï¼‰
                const particles = exp.particles;
                for (let pi = particles.length - 1; pi >= 0; pi--) {
                    const particle = particles[pi];
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vy += 0.1; // é‡åŠ›
                    particle.alpha -= exp.particleFade || 0.03;
                    
                    if (particle.alpha > 0) {
                        ctx.fillStyle = `rgba(${particle.color || '255,200,50'}, ${particle.alpha})`;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // ç²’å­æ¶ˆå¤±ï¼Œå›æ”¶åˆ°å¯¹è±¡æ± 
                        ObjectPool.releaseParticle(particle);
                        particles.splice(pi, 1);
                    }
                }
                
                exp.frame++;
                if (exp.frame >= exp.maxFrame) {
                    // å›æ”¶å‰©ä½™ç²’å­
                    for (let pi = 0; pi < particles.length; pi++) {
                        ObjectPool.releaseParticle(particles[pi]);
                    }
                    explosions.splice(index, 1);
                }
            }
        }

        // åˆ›å»ºçˆ†ç‚¸ - æ ¹æ®è¿å‡»æ•°å‡çº§ç‰¹æ•ˆ
        function createExplosion(x, y, size = 1) {
            const combo = gameState.combo || 0;
            
            // è¿å‡»ç­‰çº§ï¼š0-4æ™®é€š, 5-9é“œ, 10-19é“¶, 20-29é‡‘, 30+å½©è™¹
            let level = 0;
            if (combo >= 30) level = 4;
            else if (combo >= 20) level = 3;
            else if (combo >= 10) level = 2;
            else if (combo >= 5) level = 1;
            
            // ç‰¹æ•ˆé…ç½®
            const configs = [
                { // ç­‰çº§ 0: æ™®é€šæ©™è‰²
                    colors: { inner: [255,255,200], mid: [255,150,50], outer: [255,50,0] },
                    particleColors: ['255,200,100', '255,150,50'],
                    particleCount: 15,
                    layers: 4,
                    sizeMult: 1,
                    particleFade: 0.035
                },
                { // ç­‰çº§ 1: é“œè‰² - ç²’å­æ›´å¤š
                    colors: { inner: [255,220,180], mid: [205,127,50], outer: [139,69,19] },
                    particleColors: ['255,180,100', '205,127,50', '255,215,0'],
                    particleCount: 22,
                    layers: 5,
                    sizeMult: 1.15,
                    particleFade: 0.03
                },
                { // ç­‰çº§ 2: é“¶è‰² - é—ªäº®
                    colors: { inner: [255,255,255], mid: [192,192,192], outer: [128,128,192] },
                    particleColors: ['255,255,255', '200,200,255', '150,150,255'],
                    particleCount: 28,
                    layers: 5,
                    sizeMult: 1.3,
                    particleFade: 0.025
                },
                { // ç­‰çº§ 3: é‡‘è‰² - è€€çœ¼
                    colors: { inner: [255,255,220], mid: [255,215,0], outer: [255,165,0] },
                    particleColors: ['255,255,150', '255,215,0', '255,200,50'],
                    particleCount: 35,
                    layers: 6,
                    sizeMult: 1.5,
                    particleFade: 0.022
                },
                { // ç­‰çº§ 4: å½©è™¹ - æè‡´ç»™åŠ›
                    colors: { inner: [255,255,255], mid: [255,100,200], outer: [100,100,255] },
                    particleColors: ['255,100,100', '255,200,100', '100,255,100', '100,200,255', '200,100,255'],
                    particleCount: 45,
                    layers: 7,
                    sizeMult: 1.8,
                    particleFade: 0.018
                }
            ];
            
            const cfg = configs[level];
            const finalSize = size * cfg.sizeMult;
            
            // åˆ›å»ºç²’å­ï¼ˆä½¿ç”¨å¯¹è±¡æ± ï¼‰
            const particles = [];
            const particleCount = Math.floor(cfg.particleCount * size);
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * (4 + level) + 2;
                const colorIdx = Math.floor(Math.random() * cfg.particleColors.length);
                const p = ObjectPool.getParticle();
                p.x = x;
                p.y = y;
                p.vx = Math.cos(angle) * speed;
                p.vy = Math.sin(angle) * speed - 1;
                p.size = Math.random() * (3 + level * 0.5) + 1;
                p.alpha = 1;
                p.color = cfg.particleColors[colorIdx];
                particles.push(p);
            }
            
            explosions.push({
                x: x,
                y: y,
                frame: 0,
                maxFrame: 30 + level * 5,
                maxRadius: 40 * finalSize,
                particles: particles,
                colors: cfg.colors,
                layers: cfg.layers,
                particleFade: cfg.particleFade
            });
        }

        // ç©å®¶å°„å‡» - æ”¯æŒæ­¦å™¨é“å…·å‡çº§ï¼ˆæœ€å¤š3çº§ï¼‰ï¼Œä½¿ç”¨WEAPON_CONFIG
        function playerShoot() {
            if (player.shootCooldown > 0) return;
            
            const type = gameState.powerUpType;
            const lvl = Math.max(1, Math.min(3, gameState.powerUpLevel));
            const idx = lvl - 1;
            const speed = CONFIG.BULLET_SPEED;
            const cfg = WEAPON_CONFIG[type] || WEAPON_CONFIG.none;
            let cooldown = cfg.cd[idx] ?? cfg.cd[0];
            
            // å½©è›‹Bosså¼ºåŒ–ï¼šæ”»é€Ÿ+50%
            if (gameState.secretBuff) {
                cooldown = Math.floor(cooldown * 0.5);
            }
            
            if (type === 'rapid') {
                createBullet({ x: player.x, y: player.y - 25, vx: 0, vy: -speed, type: 'player' });
            } else if (type === 'double') {
                const o = cfg.offset[idx];
                createBullet({ x: player.x - o, y: player.y - 20, vx: 0, vy: -speed, type: 'player' });
                createBullet({ x: player.x + o, y: player.y - 20, vx: 0, vy: -speed, type: 'player' });
                if (cfg.extraBullet[idx]) createBullet({ x: player.x, y: player.y - 25, vx: 0, vy: -speed, type: 'player' });
            } else if (type === 'triple') {
                const lines = cfg.lines[idx];
                const gap = cfg.gap;
                const half = (lines - 1) / 2;
                for (let i = 0; i < lines; i++) {
                    createBullet({ x: player.x + (i - half) * gap, y: player.y - 20, vx: 0, vy: -speed, type: 'player' });
                }
            } else if (type === 'spread') {
                const angles = cfg.angles[idx];
                for (let i = 0; i < angles.length; i++) {
                    createBullet({ x: player.x, y: player.y - 22, vx: angles[i], vy: -speed * 0.95, type: 'player' });
                }
            } else if (type === 'laser') {
                const w = cfg.width[idx];
                createBullet({ x: player.x, y: player.y - 25, vx: 0, vy: -speed * 1.6, type: 'player', isLaser: true, laserWidth: w });
            } else {
                // æ— é“å…·ï¼šæ™®é€šå•å‘
                createBullet({ x: player.x, y: player.y - 25, vx: 0, vy: -speed, type: 'player' });
            }
            
            player.shootCooldown = cooldown;
        }

        // ç”Ÿæˆæ•Œäººï¼ˆæŒ‰å…³å¡ä¸»é¢˜æŒ‘é€‰æ•Œæœº+é…è‰²ï¼‰
        function spawnEnemy() {
            let type, hp, speed, shootRate, width, height;
            
            // éš¾åº¦ä¸ä¸»é¢˜
            const stage = gameState.gameMode === 'stage' ? gameState.currentStage : gameState.wave;
            // é—¯å…³æ¨¡å¼éš¾åº¦å°é¡¶ä¸º1ï¼Œæ— å°½æ¨¡å¼éš¾åº¦ç»§ç»­å¢åŠ ï¼ˆè¶…è¿‡20æ³¢åæ¯10æ³¢+0.1ï¼‰
            let diffMult;
            if (gameState.gameMode === 'stage') {
                diffMult = (stage - 1) / 19;
            } else {
                // æ— å°½æ¨¡å¼ï¼šå‰20æ³¢æ­£å¸¸å¢é•¿ï¼Œä¹‹åç¼“æ…¢å¢åŠ ï¼Œå°é¡¶1.3å€
                const baseDiff = Math.min(1, (stage - 1) / 19);
                const extraDiff = stage > 20 ? (stage - 20) * 0.015 : 0; // æ¯æ³¢+0.015
                diffMult = Math.min(1.3, baseDiff + extraDiff); // æœ€é«˜éš¾åº¦1.3å€
            }
            const theme = STAGE_THEMES[(stage - 1) % STAGE_THEMES.length];
            const pool = theme.types;
            type = pool[Math.floor(Math.random() * pool.length)];
            const defaultByType = { normal:'fighter', fast:'interceptor', tank:'bomber', sniper:'sniperJet', splitter:'splitterJet', mini:'droneJet', bomber:'bomberPlane', shield:'shieldCarrier', healer:'healerShip', swarm:'swarmDrone' };
            const shape = (theme.shapesByType && theme.shapesByType[type]) || defaultByType[type] || 'triangle';
            
            // æŒ‰ç±»å‹è®¾å®šå±æ€§ - å°„é€Ÿå’Œé€Ÿåº¦éšå…³å¡é€’å¢
            const shootMult = 1 + diffMult * ENEMY_SHOOT_MAX_MULT;
            // é€Ÿåº¦å€ç‡ï¼šç¬¬1å…³åŸºç¡€é€Ÿåº¦0.3å€ï¼Œç¬¬20å…³è¾¾åˆ°0.7å€
            const speedMult = 0.3 + diffMult * 0.4; // 0.3 ~ 0.7
            switch(type) {
                case 'fast':
                    hp = 1;
                    speed = (1.2 + diffMult * 1.5) * speedMult;
                    shootRate = ENEMY_SHOOT_BASE.fast * shootMult;
                    width = 35; height = 30; break;
                case 'tank':
                    hp = 1 + Math.floor(stage / 4);
                    speed = (0.8 + diffMult * 1.0) * speedMult;
                    shootRate = ENEMY_SHOOT_BASE.tank * shootMult;
                    width = 50; height = 45; break;
                case 'sniper':
                    hp = 1;
                    speed = (0.8 + diffMult * 1.0) * speedMult;
                    shootRate = ENEMY_SHOOT_BASE.sniper * shootMult;
                    width = 40; height = 35; break;
                case 'splitter':
                    hp = 1 + Math.floor(stage / 6);
                    speed = (1.0 + diffMult * 1.2) * speedMult;
                    shootRate = ENEMY_SHOOT_BASE.splitter * shootMult;
                    width = 45; height = 40; break;
                case 'mini':
                    hp = 1;
                    speed = (1.4 + diffMult * 1.5) * speedMult;
                    shootRate = ENEMY_SHOOT_BASE.mini * shootMult;
                    width = 25; height = 22; break;
                case 'bomber': // è½°ç‚¸é±¼ - æŠ•å¼¹
                    hp = 2 + Math.floor(stage / 5);
                    speed = (0.8 + diffMult * 0.8) * speedMult;
                    shootRate = ENEMY_SHOOT_BASE.bomber * shootMult;
                    width = 48; height = 40; break;
                case 'shield': // æŠ¤ç›¾é±¼ - æœ‰æŠ¤ç›¾
                    hp = 2 + Math.floor(stage / 5);
                    speed = (0.9 + diffMult * 1.0) * speedMult;
                    shootRate = ENEMY_SHOOT_BASE.shield * shootMult;
                    width = 45; height = 38; break;
                case 'healer': // æ²»æ„ˆé±¼
                    hp = 1 + Math.floor(stage / 6);
                    speed = (0.8 + diffMult * 0.8) * speedMult;
                    shootRate = ENEMY_SHOOT_BASE.healer * shootMult;
                    width = 35; height = 45; break;
                case 'swarm': // èœ‚ç¾¤é±¼
                    hp = 1;
                    speed = (1.3 + diffMult * 1.5) * speedMult;
                    shootRate = ENEMY_SHOOT_BASE.swarm * shootMult;
                    width = 22; height = 20; break;
                default: // normal
                    hp = 1 + Math.floor(stage / 8);
                    speed = (1.0 + diffMult * 1.2) * speedMult;
                    shootRate = ENEMY_SHOOT_BASE.normal * shootMult;
                    width = 40; height = 35; break;
            }
            
            // éšæœºç§»åŠ¨å‚æ•° - æ¯æ¡é±¼éƒ½ä¸ä¸€æ ·
            const enemyObj = {
                x: Math.random() * (CONFIG.CANVAS_WIDTH - 60) + 30,
                y: -50,
                width,
                height,
                type,
                hp,
                maxHp: hp,
                speed,
                shootRate,
                movePattern: 0, // æ™®é€šæ•Œäººç»Ÿä¸€ç”¨åŠ¨æ€ç»„åˆ
                // ç¬¬ä¸€å±‚æ³¢åŠ¨
                waveAmp: 1.5 + Math.random() * 3,
                waveFreq: 0.03 + Math.random() * 0.05,
                phase1: Math.random() * Math.PI * 2,
                // ç¬¬äºŒå±‚æ³¢åŠ¨ï¼ˆä¸åŒé¢‘ç‡å åŠ ï¼‰
                waveAmp2: 0.5 + Math.random() * 2,
                waveFreq2: 0.01 + Math.random() * 0.03,
                phase2: Math.random() * Math.PI * 2,
                // æ¼‚ç§»
                driftDir: Math.random() > 0.5 ? 1 : -1,
                driftSpeed: 0.2 + Math.random() * 0.6,
                // çªå˜é—´éš”ï¼ˆ40-120å¸§éšæœºæ”¹å˜æ–¹å‘ï¼‰
                switchInterval: 40 + Math.floor(Math.random() * 80),
                // è¿½è¸ªå¼ºåº¦ï¼ˆ0=ä¸è¿½è¸ªï¼Œéšæœºéƒ¨åˆ†æ•Œäººä¼šè¿½è¸ªï¼‰
                chaseStrength: Math.random() < 0.3 ? (0.3 + Math.random() * 0.5) : 0,
                moveTime: Math.random() * 100,
                colors: theme.palette,
                shape: shape
            };
            
            // æŠ¤ç›¾é±¼ç‰¹æœ‰å±æ€§
            if (type === 'shield') {
                enemyObj.shieldHp = 2 + Math.floor(stage / 7); // æŠ¤ç›¾è¡€é‡
                enemyObj.maxShieldHp = enemyObj.shieldHp;
            }
            
            // æ²»æ„ˆé±¼ç‰¹æœ‰å±æ€§
            if (type === 'healer') {
                enemyObj.healCooldown = 0;
                enemyObj.healRange = 150; // æ²»æ„ˆèŒƒå›´
            }
            
            enemies.push(enemyObj);
        }
        
        // ç”Ÿæˆèœ‚ç¾¤é±¼ï¼ˆæŒ‡å®šä½ç½®ï¼‰
        function spawnSwarmEnemy(x, theme) {
            const stage = gameState.gameMode === 'stage' ? gameState.currentStage : gameState.wave;
            let diffMult;
            if (gameState.gameMode === 'stage') {
                diffMult = (stage - 1) / 19;
            } else {
                const baseDiff = Math.min(1, (stage - 1) / 19);
                const extraDiff = stage > 20 ? (stage - 20) * 0.015 : 0;
                diffMult = Math.min(1.3, baseDiff + extraDiff);
            }
            
            const shootMult = 1 + diffMult * ENEMY_SHOOT_MAX_MULT;
            const speedMult = 0.4 + diffMult * 0.6;
            
            const enemyObj = {
                x: Math.max(30, Math.min(CONFIG.CANVAS_WIDTH - 30, x)),
                y: -50 - Math.random() * 30, // ç¨å¾®é”™å¼€Yä½ç½®
                width: 22,
                height: 20,
                type: 'swarm',
                hp: 1,
                maxHp: 1,
                speed: (1.6 + diffMult * 2.2) * speedMult,
                shootRate: ENEMY_SHOOT_BASE.swarm * shootMult,
                movePattern: 0,
                hitFlash: 0, // å‡»ä¸­é—ªçƒæ•ˆæœ
                waveAmp: 1.5 + Math.random() * 3,
                waveFreq: 0.03 + Math.random() * 0.05,
                phase1: Math.random() * Math.PI * 2,
                waveAmp2: 0.5 + Math.random() * 2,
                waveFreq2: 0.01 + Math.random() * 0.03,
                phase2: Math.random() * Math.PI * 2,
                driftDir: Math.random() > 0.5 ? 1 : -1,
                driftSpeed: 0.2 + Math.random() * 0.6,
                switchInterval: 40 + Math.floor(Math.random() * 80),
                chaseStrength: Math.random() < 0.3 ? (0.3 + Math.random() * 0.5) : 0,
                moveTime: Math.random() * 100,
                colors: theme.palette,
                shape: 'swarmDrone'
            };
            
            enemies.push(enemyObj);
        }
        
        // å…³å¡ä¸»é¢˜ï¼šæ¯å…³ä¸åŒæ•Œæœºç»„åˆä¸é…è‰²ï¼ˆ20å…³å¾ªç¯ï¼‰- é¿å…ä½¿ç”¨ç²‰è‰²ï¼ˆç©å®¶é±¼é¢œè‰²ï¼‰
        // å¹³è¡¡è®¾è®¡ï¼šå‰æœŸç®€å•æ•Œäººä¸ºä¸»ï¼Œé€æ­¥å¢åŠ ç‰¹æ®Šæ•Œäºº
        const STAGE_THEMES = [
            // ç¬¬1-5å…³ï¼šæ–°æ‰‹å…¥é—¨ï¼Œä»¥æ™®é€š/å¿«é€Ÿ/è¿·ä½ ä¸ºä¸»
            { name: 'æ·±æµ·æš—æµ',  types: ['normal','normal','mini'], palette: ['#5c6bc0','#3949ab','#283593'], shapesByType: {normal:'fighter', mini:'droneJet'} },
            { name: 'æ¹›è“ä¹‹æµ·',  types: ['normal','fast','mini'], palette: ['#74c0ff','#4dabf7','#228be6'], shapesByType: {fast:'interceptor', normal:'fighter', mini:'droneJet'} },
            { name: 'ç¥ç€è’åŸ',  types: ['normal','fast','fast'], palette: ['#ffb74d','#fb8c00','#ef6c00'], shapesByType: {normal:'fighter', fast:'interceptor'} },
            { name: 'ç´«æ™¶ç§˜åŸŸ',  types: ['normal','mini','sniper'], palette: ['#b388ff','#7c4dff','#651fff'], shapesByType: {normal:'fighter', mini:'droneJet', sniper:'sniperJet'} },
            { name: 'ç¿¡ç¿ æ—åœ°',  types: ['fast','normal','splitter'], palette: ['#66e6a8','#2ecc71','#1abc9c'], shapesByType: {fast:'interceptor', normal:'fighter', splitter:'splitterJet'} },
            // ç¬¬6-10å…³ï¼šå¼•å…¥ç‰¹æ®Šæ•Œäºº
            { name: 'æå¤œæ˜Ÿç©º',  types: ['fast','normal','tank'], palette: ['#a29bfe','#6c5ce7','#341f97'], shapesByType: {fast:'interceptor', normal:'fighter', tank:'bomber'} },
            { name: 'ç†”ç«ä¹‹éƒ½',  types: ['normal','splitter','bomber'], palette: ['#ff6b6b','#ff3d3d','#c71f1f'], shapesByType: {normal:'fighter', splitter:'splitterJet', bomber:'bomberPlane'} },
            { name: 'é£æš´ç¾¤å²›',  types: ['fast','mini','swarm'], palette: ['#00e5ff','#00b3ff','#0088ff'], shapesByType: {fast:'interceptor', mini:'droneJet', swarm:'swarmDrone'} },
            { name: 'é›ªåŸæ™¨å…‰',  types: ['normal','sniper','shield'], palette: ['#e3f2fd','#bbdefb','#90caf9'], shapesByType: {normal:'fighter', sniper:'sniperJet', shield:'shieldCarrier'} },
            { name: 'æ²™æµ·é—è¿¹',  types: ['tank','normal','healer'], palette: ['#ffd166','#f8b400','#e09f3e'], shapesByType: {tank:'bomber', normal:'fighter', healer:'healerShip'} },
            // ç¬¬11-15å…³ï¼šæ··åˆç»„åˆ
            { name: 'å¹½å†¥æ·±æ¸Š',  types: ['splitter','bomber','fast'], palette: ['#00d1b2','#00a896','#05668d'], shapesByType: {splitter:'splitterJet', bomber:'bomberPlane', fast:'interceptor'} },
            { name: 'é›·éœ†é«˜åŸ',  types: ['fast','shield','sniper'], palette: ['#ffd54f','#ffca28','#ffa000'], shapesByType: {fast:'interceptor', shield:'shieldCarrier', sniper:'sniperJet'} },
            { name: 'çŠç‘©ç¤å²©',  types: ['normal','swarm','healer'], palette: ['#ff8a65','#ff7043','#f4511e'], shapesByType: {normal:'fighter', swarm:'swarmDrone', healer:'healerShip'} },
            { name: 'ç£æš´åŸå¢™',  types: ['healer','sniper','tank'], palette: ['#8fd3fe','#69bff8','#4098d7'], shapesByType: {healer:'healerShip', sniper:'sniperJet', tank:'bomber'} },
            { name: 'æš®è‰²æµ·æ¹¾',  types: ['mini','bomber','shield'], palette: ['#98c1d9','#6ea8d6','#3d5a80'], shapesByType: {mini:'droneJet', bomber:'bomberPlane', shield:'shieldCarrier'} },
            // ç¬¬16-20å…³ï¼šé«˜éš¾åº¦ç»„åˆ
            { name: 'é»‘æ›œå³¡è°·',  types: ['tank','shield','bomber'], palette: ['#95a5a6','#7f8c8d','#566573'], shapesByType: {tank:'bomber', shield:'shieldCarrier', bomber:'bomberPlane'} },
            { name: 'ç–¾é£è’å²­',  types: ['swarm','splitter','fast'], palette: ['#a8e6cf','#56c7c2','#2fb7b0'], shapesByType: {swarm:'swarmDrone', splitter:'splitterJet', fast:'interceptor'} },
            { name: 'ç´«ç”µç å¤´',  types: ['fast','healer','bomber'], palette: ['#9575cd','#7e57c2','#5e35b1'], shapesByType: {fast:'interceptor', healer:'healerShip', bomber:'bomberPlane'} },
            { name: 'é’é›·ç«¹æµ·',  types: ['tank','shield','swarm'], palette: ['#a7ff83','#17b978','#086972'], shapesByType: {tank:'bomber', shield:'shieldCarrier', swarm:'swarmDrone'} },
            { name: 'æœˆå…‰å¤©ç©¹',  types: ['bomber','healer','sniper'], palette: ['#c5b3ff','#9d7dff','#6b4eff'], shapesByType: {bomber:'bomberPlane', healer:'healerShip', sniper:'sniperJet'} }
        ];

        // Bossé…ç½® - 20ç§ç‹¬ç‰¹Boss
        const BOSS_CONFIGS = [
            { name: 'çŠç‘šå®ˆå«', color: '#ff6b9d', shape: 'fighter', bulletPattern: 'spread3' },
            { name: 'ç„æœˆ', color: '#9b59b6', shape: 'crescent', bulletPattern: 'spiral' },
            { name: 'æš—å¤œç„é¸¿', color: '#2c3e50', shape: 'bird', bulletPattern: 'wave' },
            { name: 'çƒˆç„°å‡¤å‡°', color: '#e74c3c', shape: 'phoenix', bulletPattern: 'burst' },
            { name: 'å†°éœœå¥³ç‹', color: '#74b9ff', shape: 'crystal', bulletPattern: 'ring' },
            { name: 'é›·ç”µä¹‹ä¸»', color: '#f39c12', shape: 'thunder', bulletPattern: 'zigzag' },
            { name: 'æ·±æµ·å·¨å…½', color: '#0984e3', shape: 'octopus', bulletPattern: 'tentacle' },
            { name: 'æ¯’åˆºç„è¶', color: '#00b894', shape: 'butterfly', bulletPattern: 'scatter' },
            { name: 'è¡€æœˆé­”å›', color: '#c0392b', shape: 'vampire', bulletPattern: 'cross' },
            { name: 'å¹»å½±é­”å¥³', color: '#8e44ad', shape: 'witch', bulletPattern: 'homing' },
            { name: 'é»„é‡‘å¸é¾™', color: '#f1c40f', shape: 'dragon', bulletPattern: 'breath' },
            { name: 'æ¨±èŠ±ç²¾çµ', color: '#fd79a8', shape: 'sakura', bulletPattern: 'petal' },
            { name: 'æš—å½±åˆƒ', color: '#636e72', shape: 'blade', bulletPattern: 'slash' },
            { name: 'æ˜Ÿç©ºå·¨äºº', color: '#6c5ce7', shape: 'giant', bulletPattern: 'meteor' },
            { name: 'èŠ±å›­å®ˆæŠ¤è€…', color: '#e056fd', shape: 'rose', bulletPattern: 'thorn' },
            { name: 'é£æš´ä¹‹çœ¼', color: '#00cec9', shape: 'eye', bulletPattern: 'tornado' },
            { name: 'åœ°ç‹±ç«ç„°', color: '#d63031', shape: 'demon', bulletPattern: 'inferno' },
            { name: 'å¤©ä½¿ä¹‹ç¿¼', color: '#ffeaa7', shape: 'angel', bulletPattern: 'feather' },
            { name: 'æ··æ²Œä¹‹å¿ƒ', color: '#2d3436', shape: 'chaos', bulletPattern: 'random' },
            { name: 'çˆ±ç¥ä¸˜æ¯”ç‰¹', color: '#ff69b4', shape: 'cupid', bulletPattern: 'heart' }
        ];
        
        // å½©è›‹ Boss é…ç½® - 5%æ¦‚ç‡æ›¿ä»£æ™®é€š Boss
        const SECRET_BOSS_CONFIGS = [
            { name: 'ğŸ§™â€â™€ï¸ æµ·æ´‹ç¾äººé±¼', color: '#ff69b4', shape: 'mermaid', bulletPattern: 'heart', hpMult: 1.5, rewardMult: 3 },
            { name: 'ğŸ² æµ·é¾™ç‹', color: '#ffd700', shape: 'seadragon', bulletPattern: 'breath', hpMult: 2, rewardMult: 5 },
            { name: 'ğŸ¦‘ è¿œå¤å·¨é±¸', color: '#4a69bd', shape: 'whale', bulletPattern: 'wave', hpMult: 1.8, rewardMult: 4 }
        ];
        const SECRET_BOSS_CHANCE = 0.05; // 5%æ¦‚ç‡
        
        // ä¸‰é˜¶æ®µBossé…ç½®ï¼ˆç¬¬5/10/15/20å…³ï¼‰
        const MULTI_PHASE_BOSS_STAGES = [5, 10, 15, 20];
        const PHASE_BOSS_CONFIGS = {
            5: { // ç¬¬5å…³ - æ·±æµ·éœ¸ä¸»
                name: 'æ·±æµ·éœ¸ä¸»',
                phases: [
                    { shape: 'octopus', color: '#0984e3', pattern: 'tentacle', hpRatio: 0.35 },
                    { shape: 'octopus', color: '#6c5ce7', pattern: 'ring', hpRatio: 0.35 },
                    { shape: 'octopus', color: '#d63031', pattern: 'tornado', hpRatio: 0.30 }
                ],
                totalHp: 800
            },
            10: { // ç¬¬10å…³ - çƒˆç„°é¾™ç‹
                name: 'çƒˆç„°é¾™ç‹',
                phases: [
                    { shape: 'dragon', color: '#e17055', pattern: 'breath', hpRatio: 0.35 },
                    { shape: 'dragon', color: '#d63031', pattern: 'inferno', hpRatio: 0.35 },
                    { shape: 'dragon', color: '#ff0000', pattern: 'meteor', hpRatio: 0.30 }
                ],
                totalHp: 1000
            },
            15: { // ç¬¬15å…³ - æ··æ²Œé­”ç¥
                name: 'æ··æ²Œé­”ç¥',
                phases: [
                    { shape: 'demon', color: '#636e72', pattern: 'cross', hpRatio: 0.35 },
                    { shape: 'chaos', color: '#2d3436', pattern: 'random', hpRatio: 0.35 },
                    { shape: 'eye', color: '#9b59b6', pattern: 'spiral', hpRatio: 0.30 }
                ],
                totalHp: 1200
            },
            20: { // ç¬¬20å…³ - çˆ±ä¸æ¯ç­ä¹‹ç¥
                name: 'çˆ±ä¸æ¯ç­ä¹‹ç¥',
                phases: [
                    { shape: 'angel', color: '#ffeaa7', pattern: 'feather', hpRatio: 0.35 },
                    { shape: 'cupid', color: '#ff69b4', pattern: 'heart', hpRatio: 0.35 },
                    { shape: 'chaos', color: '#d63031', pattern: 'inferno', hpRatio: 0.30 }
                ],
                totalHp: 1500
            }
        };
        
        // ç”ŸæˆBoss
        function spawnBoss() {
            if (gameState.bossActive) return;
            
            gameState.bossActive = true;
            
            // æ ¹æ®æ¨¡å¼è®¡ç®—Bossç­‰çº§
            let bossLevel;
            if (gameState.gameMode === 'stage') {
                bossLevel = gameState.currentStage;
            } else {
                bossLevel = Math.floor(gameState.nextBossScore / 1000);
                if (bossLevel < 1) bossLevel = 1;
                if (bossLevel > 20) bossLevel = ((bossLevel - 1) % 20) + 1;
            }
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯ä¸‰é˜¶æ®µBosså…³å¡
            const isMultiPhaseBoss = gameState.gameMode === 'stage' && MULTI_PHASE_BOSS_STAGES.includes(bossLevel);
            
            // åˆ¤æ–­æ˜¯å¦è§¦å‘å½©è›‹Bossï¼ˆä¸‰é˜¶æ®µBosså…³ä¸è§¦å‘å½©è›‹ï¼‰
            const isSecretBoss = !isMultiPhaseBoss && Math.random() < SECRET_BOSS_CHANCE;
            let bossConfig;
            let hpMultiplier = 1;
            let rewardMultiplier = 1;
            let multiPhaseConfig = null;
            
            if (isMultiPhaseBoss) {
                // ä¸‰é˜¶æ®µBoss
                multiPhaseConfig = PHASE_BOSS_CONFIGS[bossLevel];
                const phase1 = multiPhaseConfig.phases[0];
                bossConfig = {
                    name: multiPhaseConfig.name + ' â… ',
                    color: phase1.color,
                    shape: phase1.shape,
                    bulletPattern: phase1.pattern
                };
                rewardMultiplier = 3; // ä¸‰é˜¶æ®µBosså¥–åŠ±æ›´é«˜
            } else if (isSecretBoss) {
                const secretBoss = SECRET_BOSS_CONFIGS[Math.floor(Math.random() * SECRET_BOSS_CONFIGS.length)];
                bossConfig = secretBoss;
                hpMultiplier = secretBoss.hpMult || 1;
                rewardMultiplier = secretBoss.rewardMult || 1;
            } else {
                bossConfig = BOSS_CONFIGS[(bossLevel - 1) % 20];
            }
            
            // Bosså±æ€§
            const baseHp = isMultiPhaseBoss ? multiPhaseConfig.totalHp : 500;
            const hp = Math.floor(baseHp * hpMultiplier);
            const size = 220;
            
            // æ ¹æ®Bossé€ å‹æ˜ å°„åˆ°é£æœºæ¨¡å‹ï¼ˆä¸ç»˜åˆ¶ä¿æŒä¸€è‡´ï¼‰ï¼Œç”¨äºä¼°ç®—æ›´è´´åˆçš„åˆ¤å®šæ¡†
            const planeByShape = {
                heart: 'aceFighter', cupid: 'aceFighter',
                crescent: 'stealthWing',
                butterfly: 'interceptorX', bird: 'interceptorX', thunder: 'interceptorX', blade: 'interceptorX',
                dragon: 'heavyFighter', phoenix: 'heavyFighter', angel: 'heavyFighter', vampire: 'heavyFighter', demon: 'heavyFighter',
                crystal: 'bomberX', witch: 'bomberX',
                octopus: 'gunship', giant: 'gunship', eye: 'gunship',
                sakura: 'stealthWing', rose: 'stealthWing', chaos: 'stealthWing'
            };
            const model = planeByShape[bossConfig.shape] || 'aceFighter';
            
            // ä¼°ç®—å‘½ä¸­æ¡†æ¯”ä¾‹ï¼ˆç›¸å¯¹äºsizeï¼‰ã€‚è¯´æ˜ï¼šæ­¤å‰ç»˜åˆ¶æ—¶æœºç¿¼å¤–å±•è¿œè¶…widthï¼Œå¯¼è‡´ç¿¼å°–å‘½ä¸­æ— æ•ˆ
            let hitW = size, hitH = size * 0.85;
            switch (model) {
                case 'stealthWing':
                    hitW = size * 1.85; hitH = size * 0.95; break;
                case 'bomberX':
                    hitW = size * 2.20; hitH = size * 1.00; break;
                case 'interceptorX':
                    hitW = size * 1.60; hitH = size * 0.95; break;
                case 'heavyFighter':
                    hitW = size * 1.30; hitH = size * 1.00; break;
                case 'gunship':
                    hitW = size * 2.00; hitH = size * 1.00; break;
                case 'aceFighter':
                default:
                    hitW = size * 1.50; hitH = size * 0.95; break;
            }
            
            const bossObj = {
                x: CONFIG.CANVAS_WIDTH / 2,
                y: -150,
                width: size,
                height: size * 0.85,
                hitW: hitW,
                hitH: hitH,
                type: 'boss',
                hp: hp,
                maxHp: hp,
                speed: 2.0,
                shootRate: 0.01,
                movePattern: 10,
                moveDir: 1,
                bossLevel: bossLevel,
                bossConfig: bossConfig,
                shootTimer: 0,
                animTimer: 0,
                isSecretBoss: isSecretBoss,
                rewardMultiplier: rewardMultiplier,
                // ä¸‰é˜¶æ®µBossç‰¹æœ‰å±æ€§
                isMultiPhase: isMultiPhaseBoss,
                multiPhaseConfig: multiPhaseConfig,
                currentPhase: 1,
                phaseTransitioning: false
            };
            enemies.push(bossObj);
            
            // æ˜¾ç¤ºBossè­¦å‘Š
            const warningText = isMultiPhaseBoss ? `âš ï¸ ${multiPhaseConfig.name} â… ` : `âš ï¸ ${bossConfig.name}`;
            const waveDisplay = document.getElementById('waveDisplay');
            waveDisplay.textContent = warningText;
            waveDisplay.classList.remove('show');
            void waveDisplay.offsetWidth;
            waveDisplay.classList.add('show');
            
            // å»¶è¿Ÿæ˜¾ç¤ºBossè¡€æ¡ï¼ˆç­‰Bossè¿›å…¥ç”»é¢ï¼‰
            setTimeout(() => {
                showBossHpBar(bossObj);
            }, 1500);
        }

        // ä¸‰é˜¶æ®µBossé˜¶æ®µè½¬æ¢
        function triggerPhaseTransition(boss, newPhase) {
            if (boss.phaseTransitioning) return;
            boss.phaseTransitioning = true;
            
            const config = boss.multiPhaseConfig;
            const phaseData = config.phases[newPhase - 1];
            const phaseNames = ['â… ', 'â…¡', 'â…¢'];
            
            // æ¸…é™¤å±å¹•ä¸Šæ‰€æœ‰æ•Œäººå­å¼¹
            bullets = bullets.filter(b => b.type === 'player');
            
            // åˆ›å»ºå˜èº«çˆ†ç‚¸æ•ˆæœ
            createExplosion(boss.x, boss.y, 2);
            
            // æ˜¾ç¤ºé˜¶æ®µè½¬æ¢æç¤º
            const waveDisplay = document.getElementById('waveDisplay');
            waveDisplay.textContent = `ğŸ”¥ ${config.name} ${phaseNames[newPhase - 1]}`;
            waveDisplay.classList.remove('show');
            void waveDisplay.offsetWidth;
            waveDisplay.classList.add('show');
            
            // å»¶è¿Ÿåæ›´æ–°Bossé…ç½®
            setTimeout(() => {
                // æ›´æ–°Bosså¤–è§‚å’Œå¼¹é“
                boss.bossConfig = {
                    name: config.name + ' ' + phaseNames[newPhase - 1],
                    color: phaseData.color,
                    shape: phaseData.shape,
                    bulletPattern: phaseData.pattern
                };
                boss.currentPhase = newPhase;
                boss.shootTimer = 0; // é‡ç½®å°„å‡»è®¡æ—¶å™¨ï¼Œç»™ç©å®¶ååº”æ—¶é—´
                boss._hitPath = null; // é‡ç½®å‘½ä¸­è·¯å¾„
                
                // æ¯æ¬¡å˜èº«æ‰è½ä¸€ä¸ªé“å…·
                spawnBossPowerUp(boss.x, boss.y + 50);
                
                // ç¬¬ä¸‰é˜¶æ®µæé«˜ç§»åŠ¨é€Ÿåº¦
                if (newPhase === 3) {
                    boss.speed = 2.5;
                }
                
                boss.phaseTransitioning = false;
            }, 500);
        }
        
        // é“å…·ç±»å‹é…ç½®ï¼ˆå¸¦æƒé‡ï¼‰
        const POWERUP_TYPES = [
            { type: 'rapid', icon: 'âš¡', name: 'å¿«é€Ÿå°„å‡»', color: '#f1c40f', weight: 15 },
            { type: 'double', icon: 'â‡ï¸', name: 'åŒå‘', color: '#3498db', weight: 15 },
            { type: 'triple', icon: 'ğŸ”±', name: 'ä¸‰å‘', color: '#9b59b6', weight: 15 },
            { type: 'spread', icon: 'ğŸŒŸ', name: 'æ•£å°„', color: '#e74c3c', weight: 15 },
            { type: 'laser', icon: 'ğŸ’ ', name: 'æ¿€å…‰', color: '#00ff88', weight: 15 },
            { type: 'shield', icon: 'ğŸ›¡ï¸', name: 'æ— æ•ŒæŠ¤ç›¾', color: '#ffd700', weight: 10 },
            { type: 'drone', icon: 'ğŸŸ', name: 'èªä»”é±¼', color: '#00e5ff', weight: 10 },
            { type: 'heart', icon: 'â¤ï¸', name: 'ç”Ÿå‘½æ¢å¤', color: '#ff1493', weight: 10 }, // æ‰€æœ‰æ¨¡å¼éƒ½å¯æ‰è½
            { type: 'blackhole', icon: 'ğŸŒ€', name: 'é»‘æ´', color: '#4a0080', weight: 5 }
        ];
        
        // æ ¹æ®æƒé‡éšæœºé€‰æ‹©é“å…·
        function weightedRandomPowerup(available) {
            const totalWeight = available.reduce((sum, p) => sum + p.weight, 0);
            let random = Math.random() * totalWeight;
            for (const p of available) {
                random -= p.weight;
                if (random <= 0) return p;
            }
            return available[available.length - 1];
        }
        
        // ç”Ÿæˆé“å…·
        function spawnPowerUp(x, y) {
            if (Math.random() < CONFIG.POWERUP_DROP_RATE) {
                // è¿‡æ»¤é“å…·ï¼šé—¯å…³æ¨¡å¼ä¸æ‰çˆ±å¿ƒï¼›æ— å°½æ¨¡å¼ä»…åœ¨ç”Ÿå‘½æœªæ»¡æ—¶å¯æ‰çˆ±å¿ƒ
                let availableTypes = POWERUP_TYPES.filter(p => {
                    if (p.type === 'heart') {
                        if (gameState.gameMode === 'stage') return false;
                        return gameState.lives < CONFIG.ENDLESS_LIVES;
                    }
                    return true;
                });
                const powerType = weightedRandomPowerup(availableTypes);
                powerUps.push({
                    x: x,
                    y: y,
                    powerType: powerType.type,
                    icon: powerType.icon,
                    color: powerType.color,
                    speed: 2,
                    rotation: 0
                });
            }
        }
        
        // Bossæˆ˜æœŸé—´æ‰è½é“å…·ï¼ˆæ’é™¤é»‘æ´ï¼‰
        function spawnBossPowerUp(x, y) {
            // è¿‡æ»¤æ‰é»‘æ´ï¼›é—¯å…³æ¨¡å¼ä¸æ‰çˆ±å¿ƒï¼›æ— å°½æ¨¡å¼ä»…åœ¨ç”Ÿå‘½æœªæ»¡æ—¶å¯æ‰çˆ±å¿ƒ
            let availableTypes = POWERUP_TYPES.filter(p => {
                if (p.type === 'blackhole') return false; // æ’é™¤é»‘æ´
                if (p.type === 'heart') {
                    if (gameState.gameMode === 'stage') return false;
                    return gameState.lives < CONFIG.ENDLESS_LIVES;
                }
                return true;
            });
            const powerType = weightedRandomPowerup(availableTypes);
            powerUps.push({
                x: x,
                y: y,
                powerType: powerType.type,
                icon: powerType.icon,
                color: powerType.color,
                speed: 2,
                rotation: 0
            });
        }

        // æ•Œäººå°„å‡»
        function enemyShoot(enemy) {
            // ç»Ÿä¸€å­å¼¹é€Ÿåº¦
            const spd = 1;
            
            if (enemy.type === 'boss' && enemy.bossConfig) {
                // Bossç‰¹æ®Šå¼¹é“ - æ¯ç§å¼¹é“æœ‰å›ºå®šèŠ‚å¥ï¼Œæœ‰è§„å¾‹å¯èº²
                enemy.shootTimer = (enemy.shootTimer || 0) + 1;
                // Bossè¿›å…¥åç»Ÿä¸€å»¶è¿Ÿ120å¸§å¼€ç«
                if (enemy.shootTimer < 120) return;
                
                const pattern = enemy.bossConfig.bulletPattern;
                const cx = enemy.x;
                const cy = enemy.y + ((enemy.hitH || enemy.height) / 2);
                
                // è·å–Bossé¢œè‰²ç”¨äºå­å¼¹
                const bossColor = enemy.bossConfig.color || '#ff4757';
                
                switch(pattern) {
                    case 'spread3': // 3è·¯æ‰©æ•£ - æ¯45å¸§ä¸€æ³¢ï¼Œä¸‰å‘å­å¼¹å‘ä¸‹æ‰©æ•£
                        if (enemy.shootTimer % 45 === 0) {
                            for (let i = -1; i <= 1; i++) {
                                createBullet({ x: cx + i * 30, y: cy, vx: i * 2.5, vy: 5, type: 'enemy', bulletStyle: 'boss_spread', bossColor });
                            }
                        }
                        break;
                    case 'spiral': // èºæ—‹ - æ¯8å¸§ä¸€å‘ï¼Œæ—‹è½¬å‘å°„ï¼Œå½¢æˆå¯†é›†èºæ—‹
                        if (enemy.shootTimer % 8 === 0) {
                            const angle = enemy.shootTimer * 0.18;
                            createBullet({ x: cx, y: cy, vx: Math.cos(angle) * 4, vy: Math.sin(angle) * 2 + 4, type: 'enemy', bulletStyle: 'boss_spiral', bossColor });
                        }
                        break;
                    case 'wave': // æ³¢åŠ¨ - æ¯40å¸§ä¸€æ³¢5å‘æ³¢å½¢å­å¼¹
                        if (enemy.shootTimer % 40 === 0) {
                            for (let i = 0; i < 5; i++) {
                                createBullet({ x: cx - 80 + i * 40, y: cy, vx: 0, vy: 5, type: 'enemy', wave: true, waveOffset: i, bulletStyle: 'boss_wave', bossColor });
                            }
                        }
                        break;
                    case 'burst': // çˆ†è£‚ - æ¯60å¸§10å‘åœ†å½¢çˆ†å‘
                        if (enemy.shootTimer % 60 === 0) {
                            for (let i = 0; i < 10; i++) {
                                const a = (i / 10) * Math.PI * 2;
                                createBullet({ x: cx, y: cy, vx: Math.cos(a) * 3.5, vy: Math.sin(a) * 3.5 + 2, type: 'enemy', bulletStyle: 'boss_burst', bossColor });
                            }
                        }
                        break;
                    case 'ring': // åœ†ç¯ - æ¯55å¸§16å‘åœ†ç¯ï¼Œæ¯æ¬¡æ—‹è½¬åç§»
                        if (enemy.shootTimer % 55 === 0) {
                            const offset = (enemy.shootTimer / 55) * 0.15;
                            for (let i = 0; i < 16; i++) {
                                const a = (i / 16) * Math.PI * 2 + offset;
                                createBullet({ x: cx, y: cy, vx: Math.cos(a) * 3, vy: Math.sin(a) * 3 + 2, type: 'enemy', bulletStyle: 'boss_ring', bossColor });
                            }
                        }
                        break;
                    case 'zigzag': // ä¹‹å­—å½¢ - æ¯18å¸§ä¸€å‘ï¼Œå·¦å³äº¤æ›¿ï¼Œå½¢æˆå¯†é›†ä¹‹å­—
                        if (enemy.shootTimer % 18 === 0) {
                            const dir = (enemy.shootTimer / 18) % 2 === 0 ? -1 : 1;
                            createBullet({ x: cx, y: cy, vx: dir * 4, vy: 5, type: 'enemy', bulletStyle: 'boss_zigzag', bossColor });
                        }
                        break;
                    case 'tentacle': // è§¦æ‰‹ - æ¯20å¸§åŒå‘ï¼Œå·¦å³åŒæ—¶
                        if (enemy.shootTimer % 20 === 0) {
                            createBullet({ x: cx - 50, y: cy, vx: -2, vy: 5, type: 'enemy', bulletStyle: 'boss_tentacle', bossColor });
                            createBullet({ x: cx + 50, y: cy, vx: 2, vy: 5, type: 'enemy', bulletStyle: 'boss_tentacle', bossColor });
                        }
                        break;
                    case 'scatter': // æ•£å°„ - æ¯50å¸§7å‘æ‰©æ•£
                        if (enemy.shootTimer % 50 === 0) {
                            for (let i = -3; i <= 3; i++) {
                                createBullet({ x: cx + i * 20, y: cy, vx: i * 1.5, vy: 5, type: 'enemy', bulletStyle: 'boss_scatter', bossColor });
                            }
                        }
                        break;
                    case 'cross': // åå­— - æ¯40å¸§5å‘åå­—å½¢
                        if (enemy.shootTimer % 40 === 0) {
                            createBullet({ x: cx, y: cy, vx: 0, vy: 6, type: 'enemy', bulletStyle: 'boss_cross', bossColor });
                            createBullet({ x: cx, y: cy, vx: 4, vy: 4, type: 'enemy', bulletStyle: 'boss_cross', bossColor });
                            createBullet({ x: cx, y: cy, vx: -4, vy: 4, type: 'enemy', bulletStyle: 'boss_cross', bossColor });
                            createBullet({ x: cx, y: cy, vx: 2, vy: 5, type: 'enemy', bulletStyle: 'boss_cross', bossColor });
                            createBullet({ x: cx, y: cy, vx: -2, vy: 5, type: 'enemy', bulletStyle: 'boss_cross', bossColor });
                        }
                        break;
                    case 'homing': // è¿½è¸ª - æ¯70å¸§åŒå‘è¿½è¸ªå¼¹
                        if (enemy.shootTimer % 70 === 0) {
                            const dx = player.x - cx;
                            const dy = player.y - cy;
                            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                            createBullet({ x: cx - 30, y: cy, vx: (dx / dist) * 5, vy: (dy / dist) * 5, type: 'enemy', bulletStyle: 'boss_homing', bossColor });
                            createBullet({ x: cx + 30, y: cy, vx: (dx / dist) * 5, vy: (dy / dist) * 5, type: 'enemy', bulletStyle: 'boss_homing', bossColor });
                        }
                        break;
                    case 'breath': // é¾™æ¯ - æ¯70å¸§ä¸€æ³¢ï¼ŒæŒç»­35å¸§çš„å¯†é›†ç«ç„°
                        if (enemy.shootTimer % 70 < 35 && enemy.shootTimer % 4 === 0) {
                            const spread = (enemy.shootTimer % 70 - 17) * 5;
                            createBullet({ x: cx + spread, y: cy, vx: spread * 0.06, vy: 6, type: 'enemy', bulletStyle: 'boss_breath', bossColor });
                        }
                        break;
                    case 'petal': // èŠ±ç“£ - æ¯50å¸§6å‘æ—‹è½¬èŠ±ç“£
                        if (enemy.shootTimer % 50 === 0) {
                            const baseAngle = enemy.shootTimer * 0.05;
                            for (let i = 0; i < 6; i++) {
                                const a = baseAngle + (i / 6) * Math.PI * 2;
                                createBullet({ x: cx, y: cy, vx: Math.cos(a) * 3, vy: 4.5, type: 'enemy', bulletStyle: 'boss_petal', bossColor });
                            }
                        }
                        break;
                    case 'slash': // æ–©å‡» - æ¯55å¸§ä¸€æ³¢äº”è¿å‡»
                        if (enemy.shootTimer % 55 < 25 && enemy.shootTimer % 5 === 0) {
                            const phase = Math.floor((enemy.shootTimer % 55) / 5);
                            const offset = (phase - 2) * 35;
                            createBullet({ x: cx + offset, y: cy, vx: (phase - 2) * 2.5, vy: 7, type: 'enemy', bulletStyle: 'boss_slash', bossColor });
                        }
                        break;
                    case 'meteor': // æµæ˜Ÿ - æ¯70å¸§7å‘ä»ä¸Šæ–¹è½ä¸‹
                        if (enemy.shootTimer % 70 === 0) {
                            for (let i = 0; i < 7; i++) {
                                const startX = (i + 0.5) * (CONFIG.CANVAS_WIDTH / 7);
                                createBullet({ x: startX, y: cy, vx: (Math.random() - 0.5) * 2, vy: 6, type: 'enemy', bulletStyle: 'boss_meteor', bossColor });
                            }
                        }
                        break;
                    case 'thorn': // è†æ£˜ - æ¯30å¸§5å‘ï¼Œå·¦å³äº¤æ›¿
                        if (enemy.shootTimer % 30 === 0) {
                            const side = (enemy.shootTimer / 30) % 2 === 0 ? -1 : 1;
                            for (let i = -2; i <= 2; i++) {
                                createBullet({ x: cx + side * 50, y: cy, vx: side * 2.5 + i * 0.8, vy: 5, type: 'enemy', bulletStyle: 'boss_thorn', bossColor });
                            }
                        }
                        break;
                    case 'tornado': // é¾™å· - æ¯6å¸§åŒå‘æ—‹è½¬
                        if (enemy.shootTimer % 6 === 0) {
                            const a = enemy.shootTimer * 0.2;
                            createBullet({ x: cx + Math.cos(a) * 50, y: cy, vx: Math.cos(a) * 2.5, vy: 5, type: 'enemy', bulletStyle: 'boss_tornado', bossColor });
                            createBullet({ x: cx + Math.cos(a + Math.PI) * 50, y: cy, vx: Math.cos(a + Math.PI) * 2.5, vy: 5, type: 'enemy', bulletStyle: 'boss_tornado', bossColor });
                        }
                        break;
                    case 'inferno': // åœ°ç‹±ç« - æ¯80å¸§ä¸€æ³¢ï¼ŒæŒçº­45å¸§å¯†é›†ç«ç„°
                        if (enemy.shootTimer % 80 < 45 && enemy.shootTimer % 3 === 0) {
                            const spread = Math.sin(enemy.shootTimer * 0.2) * 80;
                            createBullet({ x: cx + spread, y: cy, vx: spread * 0.03, vy: 6, type: 'enemy', bulletStyle: 'boss_inferno', bossColor });
                        }
                        break;
                    case 'feather': // ç¾½æ¯› - æ¯45å¸§6å‘é£˜è½
                        if (enemy.shootTimer % 45 === 0) {
                            for (let i = 0; i < 6; i++) {
                                const x = cx - 75 + i * 30;
                                createBullet({ x: x, y: cy, vx: (i - 2.5) * 1, vy: 4.5, type: 'enemy', wave: true, waveOffset: i * 0.5, bulletStyle: 'boss_feather', bossColor });
                            }
                        }
                        break;
                    case 'random': // æ··æ²Œ - æ¯30å¸§éšæœºæ¨¡å¼ï¼Œæ›´å¯†é›†
                        if (enemy.shootTimer % 30 === 0) {
                            const mode = Math.floor(enemy.shootTimer / 30) % 4;
                            if (mode === 0) { // ä¸‰å‘ç›´çº¿
                                createBullet({ x: cx - 25, y: cy, vx: 0, vy: 6, type: 'enemy', bulletStyle: 'boss_random', bossColor });
                                createBullet({ x: cx, y: cy, vx: 0, vy: 6, type: 'enemy', bulletStyle: 'boss_random', bossColor });
                                createBullet({ x: cx + 25, y: cy, vx: 0, vy: 6, type: 'enemy', bulletStyle: 'boss_random', bossColor });
                            } else if (mode === 1) { // å››å‘æ‰©æ•£
                                for (let i = -2; i <= 1; i++) {
                                    createBullet({ x: cx + i * 20, y: cy, vx: i * 2, vy: 5, type: 'enemy', bulletStyle: 'boss_random', bossColor });
                                }
                            } else if (mode === 2) { // åŒè¿½è¸ª
                                const dx = player.x - cx, dy = player.y - cy;
                                const d = Math.sqrt(dx*dx + dy*dy) || 1;
                                createBullet({ x: cx - 20, y: cy, vx: (dx/d) * 5, vy: (dy/d) * 5, type: 'enemy', bulletStyle: 'boss_homing', bossColor });
                                createBullet({ x: cx + 20, y: cy, vx: (dx/d) * 5, vy: (dy/d) * 5, type: 'enemy', bulletStyle: 'boss_homing', bossColor });
                            } else { // äº”å‘æ‰‡å½¢
                                for (let i = -2; i <= 2; i++) {
                                    createBullet({ x: cx, y: cy, vx: i * 2.5, vy: 5, type: 'enemy', bulletStyle: 'boss_random', bossColor });
                                }
                            }
                        }
                        break;
                    case 'heart': // çˆ±å¿ƒ - æ¯70å¸§16å‘å¿ƒå½¢
                        if (enemy.shootTimer % 70 === 0) {
                            for (let i = 0; i < 16; i++) {
                                const t = (i / 16) * Math.PI * 2;
                                const hx = 16 * Math.pow(Math.sin(t), 3);
                                const hy = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                                createBullet({ x: cx, y: cy, vx: hx * 0.2, vy: -hy * 0.2 + 3, type: 'enemy', bulletStyle: 'boss_heart', bossColor });
                            }
                        }
                        break;
                    default: // é»˜è®¤ - æ¯35å¸§ä¸‰å‘æ‰©æ•£
                        if (enemy.shootTimer % 35 === 0) {
                            createBullet({ x: cx - 20, y: cy, vx: -1.5, vy: 5, type: 'enemy', bulletStyle: 'boss_spread', bossColor });
                            createBullet({ x: cx, y: cy, vx: 0, vy: 5, type: 'enemy', bulletStyle: 'boss_spread', bossColor });
                            createBullet({ x: cx + 20, y: cy, vx: 1.5, vy: 5, type: 'enemy', bulletStyle: 'boss_spread', bossColor });
                        }
                }
            } else if (Math.random() < enemy.shootRate) {
                // æ ¹æ®æ•Œé±¼ç±»å‹å‘å°„ä¸åŒå­å¼¹
                const ex = enemy.x;
                const ey = enemy.y + 20;
                const type = enemy.type || 'normal';
                
                switch(type) {
                    case 'fast': // å¿«é€Ÿé±¼ - åŒå‘å¿«é€Ÿå°å­å¼¹
                        createBullet({ x: ex - 8, y: ey, vx: -0.5, vy: 7, type: 'enemy', bulletStyle: 'fast' });
                        createBullet({ x: ex + 8, y: ey, vx: 0.5, vy: 7, type: 'enemy', bulletStyle: 'fast' });
                        break;
                    case 'tank': // å¦å…‹é±¼ - å•å‘å¤§å­å¼¹ï¼Œæ…¢ä½†ä¼¤å®³é«˜
                        createBullet({ x: ex, y: ey, vx: 0, vy: 3.5, type: 'enemy', bulletStyle: 'tank' });
                        break;
                    case 'sniper': // ç‹™å‡»é±¼ - ç²¾å‡†è¿½è¸ªå­å¼¹
                        const dx = player.x - ex;
                        const dy = player.y - ey;
                        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                        createBullet({ x: ex, y: ey, vx: (dx / dist) * 5, vy: (dy / dist) * 5, type: 'enemy', bulletStyle: 'sniper' });
                        break;
                    case 'splitter': // åˆ†è£‚é±¼ - ä¸‰å‘æ‰©æ•£
                        createBullet({ x: ex, y: ey, vx: -2, vy: 4, type: 'enemy', bulletStyle: 'splitter' });
                        createBullet({ x: ex, y: ey, vx: 0, vy: 5, type: 'enemy', bulletStyle: 'splitter' });
                        createBullet({ x: ex, y: ey, vx: 2, vy: 4, type: 'enemy', bulletStyle: 'splitter' });
                        break;
                    case 'mini': // è¿·ä½ é±¼ - å¾®å°å­å¼¹ï¼Œå¿«é€Ÿä½†å¼±
                        createBullet({ x: ex, y: ey, vx: (Math.random() - 0.5) * 2, vy: 6, type: 'enemy', bulletStyle: 'mini' });
                        break;
                    case 'bomber': // è½°ç‚¸é±¼ - æŠ•ä¸‹ç‚¸å¼¹ï¼Œçˆ†ç‚¸æ—¶åˆ†è£‚
                        createBullet({ x: ex, y: ey, vx: 0, vy: 2.5, type: 'enemy', bulletStyle: 'bomber', isBomb: true, bombTimer: 60 });
                        break;
                    case 'shield': // æŠ¤ç›¾é±¼ - ç”µå¼§æ”»å‡»ï¼ŒåŒå‘
                        createBullet({ x: ex - 10, y: ey, vx: -1, vy: 5, type: 'enemy', bulletStyle: 'shield' });
                        createBullet({ x: ex + 10, y: ey, vx: 1, vy: 5, type: 'enemy', bulletStyle: 'shield' });
                        break;
                    case 'healer': // æ²»æ„ˆé±¼ - æ²»æ„ˆæ³¢ï¼Œæ…¢é€Ÿä½†è¿½è¸ª
                        const hdx = player.x - ex;
                        const hdy = player.y - ey;
                        const hdist = Math.sqrt(hdx * hdx + hdy * hdy) || 1;
                        createBullet({ x: ex, y: ey, vx: (hdx / hdist) * 3, vy: (hdy / hdist) * 3, type: 'enemy', bulletStyle: 'healer' });
                        break;
                    case 'swarm': // èœ‚ç¾¤é±¼ - å¾®å°å¿«é€Ÿå­å¼¹
                        createBullet({ x: ex, y: ey, vx: (Math.random() - 0.5) * 3, vy: 7, type: 'enemy', bulletStyle: 'swarm' });
                        break;
                    default: // æ™®é€šé±¼ - æ ‡å‡†å­å¼¹
                        createBullet({ x: ex, y: ey, vx: 0, vy: 5, type: 'enemy', bulletStyle: 'normal' });
                }
            }
        }

        // ç¢°æ’æ£€æµ‹
        function checkCollision(a, b) {
            return Math.abs(a.x - b.x) < (a.width + b.width) / 2 &&
                   Math.abs(a.y - b.y) < (a.height + b.height) / 2;
        }

        // æ›´æ–°æ¸¸æˆçŠ¶æ€
        function update() {
            if (!gameState.isRunning || gameState.isPaused) return;

            // å¸§è®¡æ•°ï¼ˆç”¨äºBossæœ€æ—©å‡ºç°æ—¶é—´æ§åˆ¶ï¼‰
            gameState.elapsedFrames = (gameState.elapsedFrames || 0) + 1;

            // æ›´æ–°ç©å®¶ä½ç½® - é”®ç›˜æ§åˆ¶
            if (keys['ArrowLeft'] || keys['KeyA']) player.x -= player.speed;
            if (keys['ArrowRight'] || keys['KeyD']) player.x += player.speed;
            if (keys['ArrowUp'] || keys['KeyW']) player.y -= player.speed;
            if (keys['ArrowDown'] || keys['KeyS']) player.y += player.speed;
            
            // æ›´æ–°ç©å®¶ä½ç½® - è§¦æ‘¸è·Ÿéšæ§åˆ¶
            if (isTouching) {
                // å¹³æ»‘ç§»åŠ¨åˆ°è§¦æ‘¸ä½ç½®
                const dx = touchTarget.x - player.x;
                const dy = touchTarget.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 5) {
                    const moveSpeed = Math.min(player.speed * 1.5, dist);
                    player.x += (dx / dist) * moveSpeed;
                    player.y += (dy / dist) * moveSpeed;
                }
            }
            
            // è¾¹ç•Œé™åˆ¶
            player.x = Math.max(30, Math.min(CONFIG.CANVAS_WIDTH - 30, player.x));
            player.y = Math.max(30, Math.min(CONFIG.CANVAS_HEIGHT - 30, player.y));
            
            // è‡ªåŠ¨å°„å‡»
            playerShoot();
            if (player.shootCooldown > 0) player.shootCooldown--;
            
            // å—ä¼¤æ— æ•Œæ—¶é—´é€’å‡
            if (player.invincible > 0) player.invincible--;
            
            // é“å…·æ—¶é—´
            if (gameState.powerUpTime > 0) {
                gameState.powerUpTime--;
                if (gameState.powerUpTime === 0) {
                    gameState.powerUpType = 'none';
                    gameState.powerUpLevel = 0;
                }
            }
            
            // æ— æ•Œæ—¶é—´
            if (gameState.invincibleTime > 0) {
                gameState.invincibleTime--;
                if (gameState.invincibleTime === 0) {
                    gameState.isInvincible = false;
                }
            }
            
            // èªä»”æœºæ—¶é—´ä¸è¡Œä¸º
            if (gameState.droneActive) {
                if (gameState.droneTime > 0) {
                    gameState.droneTime--;
                } else {
                    gameState.droneActive = false;
                    drones = [];
                }
            }
            // å½©è›‹ Bosså¼ºåŒ–æ—¶é—´
            if (gameState.secretBuff && gameState.secretBuffTime > 0) {
                gameState.secretBuffTime--;
                if (gameState.secretBuffTime === 0) {
                    gameState.secretBuff = false;
                }
            }
            
            // æ›´æ–°é»‘æ´
            updateBlackholes();

            // èªä»”æœºè·Ÿéšä¸å¼€ç«
            if (gameState.droneActive && drones.length) {
                for (let di = 0; di < drones.length; di++) {
                    const d = drones[di];
                    // è‡ªåŠ¨å¼€ç«
                    if (d.shootCooldown > 0) d.shootCooldown--;
                    if (d.shootCooldown <= 0) {
                        createBullet({ x: player.x + d.offsetX, y: player.y + d.offsetY - 10, vx: 0, vy: -CONFIG.BULLET_SPEED, type: 'player' });
                        d.shootCooldown = CONFIG.DRONE_FIRE_COOLDOWN;
                    }
                }
            }

            // æ›´æ–°å­å¼¹ï¼ˆä»åå‘å‰éå†ä»¥é¿å…spliceç´¢å¼•é—®é¢˜ï¼‰
            for (let index = bullets.length - 1; index >= 0; index--) {
                const bullet = bullets[index];
                bullet.y += (bullet.vy || 0);
                bullet.x += (bullet.vx || 0);
                // æ³¢åŠ¨å­å¼¹ç‰¹æ®Šå¤„ç†
                if (bullet.wave) {
                    bullet.x += Math.sin(bullet.y * 0.05 + bullet.waveOffset) * 2;
                }
                // ç‚¸å¼¹è®¡æ—¶å™¨
                if (bullet.isBomb) {
                    bullet.bombTimer--;
                    if (bullet.bombTimer <= 0) {
                        // ç‚¸å¼¹çˆ†ç‚¸ï¼Œç”Ÿæˆå¤šä¸ªåˆ†è£‚å­å¼¹
                        for (let i = 0; i < 8; i++) {
                            const angle = (i / 8) * Math.PI * 2;
                            createBullet({
                                x: bullet.x,
                                y: bullet.y,
                                vx: Math.cos(angle) * 3.5,
                                vy: Math.sin(angle) * 3.5 + 2,
                                type: 'enemy',
                                bulletStyle: 'mini'
                            });
                        }
                        createExplosion(bullet.x, bullet.y, 0.5);
                        ObjectPool.releaseBullet(bullet); // å›æ”¶åˆ°å¯¹è±¡æ± 
                        bullets.splice(index, 1);
                        continue;
                    }
                }
                if (bullet.y < -20 || bullet.y > CONFIG.CANVAS_HEIGHT + 20 || 
                    bullet.x < -20 || bullet.x > CONFIG.CANVAS_WIDTH + 20) {
                    ObjectPool.releaseBullet(bullet); // å›æ”¶åˆ°å¯¹è±¡æ± 
                    bullets.splice(index, 1);
                }
            }

            // æ›´æ–°æ•Œäººï¼ˆä»åå‘å‰éå†ä»¥é¿å…spliceç´¢å¼•é—®é¢˜ï¼‰
            for (let eIndex = enemies.length - 1; eIndex >= 0; eIndex--) {
                const enemy = enemies[eIndex];
                // è¢«é»‘æ´å¸å¼•çš„æ•Œäººä¸æ‰§è¡Œæ­£å¸¸ç§»åŠ¨
                if (enemy.beingSucked) continue;
                
                enemy.moveTime = (enemy.moveTime || 0) + 1;
                const t = enemy.moveTime;
                
                if (enemy.movePattern === 10) {
                    // Bossç‰¹æ®Šç§»åŠ¨
                    if (enemy.y < 80) {
                        enemy.y += enemy.speed;
                    } else {
                        enemy.x += enemy.speed * 2 * enemy.moveDir;
                        if (enemy.x > CONFIG.CANVAS_WIDTH - 80) enemy.moveDir = -1;
                        if (enemy.x < 80) enemy.moveDir = 1;
                    }
                } else {
                    // æ™®é€šæ•Œäºº - åŠ¨æ€ç»„åˆè½¨è¿¹
                    enemy.y += enemy.speed;
                    
                    // åŸºç¡€æ¨ªå‘ç§»åŠ¨ï¼šæ­£å¼¦æ³¢
                    let dx = Math.sin(t * enemy.waveFreq + enemy.phase1) * enemy.waveAmp;
                    
                    // å åŠ ç¬¬äºŒå±‚æ³¢åŠ¨ï¼ˆä¸åŒé¢‘ç‡ï¼‰
                    dx += Math.sin(t * enemy.waveFreq2 + enemy.phase2) * enemy.waveAmp2;
                    
                    // éšæœºæ¼‚ç§»ï¼ˆæ…¢æ…¢å‘ä¸€ä¸ªæ–¹å‘ç§»åŠ¨ï¼‰
                    dx += enemy.driftDir * enemy.driftSpeed * 0.5;
                    
                    // éšæœºçªå˜ï¼šæ¯éš”ä¸€æ®µæ—¶é—´å¯èƒ½æ”¹å˜æ–¹å‘
                    if (t % enemy.switchInterval === 0) {
                        enemy.driftDir *= -1;
                    }
                    
                    // è¿½è¸ªç©å®¶ï¼ˆè½»å¾®ï¼‰
                    if (enemy.chaseStrength > 0) {
                        if (enemy.x < player.x - 20) dx += enemy.chaseStrength;
                        if (enemy.x > player.x + 20) dx -= enemy.chaseStrength;
                    }
                    
                    enemy.x += dx;
                }
                
                // è¾¹ç•Œ
                enemy.x = Math.max(30, Math.min(CONFIG.CANVAS_WIDTH - 30, enemy.x));
                
                // å°„å‡»
                enemyShoot(enemy);
                
                // æ²»æ„ˆé±¼ç‰¹æ®Šèƒ½åŠ›ï¼šæ²»æ„ˆå‘¨å›´æ•Œäºº
                if (enemy.type === 'healer') {
                    enemy.healCooldown = (enemy.healCooldown || 0) - 1;
                    if (enemy.healCooldown <= 0) {
                        // æ¯120å¸§æ²»æ„ˆä¸€æ¬¡
                        enemies.forEach(other => {
                            if (other === enemy || other.type === 'boss') return;
                            const hdx = other.x - enemy.x;
                            const hdy = other.y - enemy.y;
                            const dist = Math.sqrt(hdx * hdx + hdy * hdy);
                            if (dist < enemy.healRange && other.hp < other.maxHp) {
                                other.hp = Math.min(other.maxHp, other.hp + 1);
                                other.healFlash = 15; // æ²»æ„ˆç‰¹æ•ˆ
                            }
                        });
                        enemy.healCooldown = 120;
                    }
                }
                
                // ç§»å‡ºå±å¹•
                if (enemy.y > CONFIG.CANVAS_HEIGHT + 50) {
                    ObjectPool.releaseEnemy(enemy); // å›æ”¶åˆ°å¯¹è±¡æ± 
                    enemies.splice(eIndex, 1);
                    gameState.combo = 0;
                }
            }

            // æ›´æ–°é“å…·ï¼ˆä»åå‘å‰éå†ä»¥é¿å…spliceç´¢å¼•é—®é¢˜ï¼‰
            for (let pIndex = powerUps.length - 1; pIndex >= 0; pIndex--) {
                const p = powerUps[pIndex];
                p.y += p.speed;
                if (p.y > CONFIG.CANVAS_HEIGHT + 20) {
                    ObjectPool.releasePowerUp(p); // å›æ”¶åˆ°å¯¹è±¡æ± 
                    powerUps.splice(pIndex, 1);
                }
            }

            // ç¢°æ’æ£€æµ‹ï¼šç©å®¶å­å¼¹ vs æ•Œäººï¼ˆä½¿ç”¨Yè½´åˆ†åŒºä¼˜åŒ–ï¼‰
            for (let bIndex = bullets.length - 1; bIndex >= 0; bIndex--) {
                const bullet = bullets[bIndex];
                if (bullet.type !== 'player') continue;
                
                // è·å–å­å¼¹Yåæ ‡é™„è¿‘çš„æ•Œäººï¼ˆä¼˜åŒ–ï¼‰
                const nearbyEnemies = getEnemiesInRange(bullet.y - 60, bullet.y + 60);
                
                for (let eIndex = nearbyEnemies.length - 1; eIndex >= 0; eIndex--) {
                    const enemy = nearbyEnemies[eIndex];
                    let hit = false;
                    if (enemy.type === 'boss') {
                        // åŸºäºBossç»˜åˆ¶è·¯å¾„çš„ç²¾ç¡®å‘½ä¸­
                        if (!enemy._hitPath || enemy._hitPathKey !== enemy.width) {
                            enemy._hitPath = buildBossHitPath(enemy);
                            enemy._hitPathKey = enemy.width;
                        }
                        // å°†å­å¼¹åæ ‡è½¬æ¢åˆ°Bossæœ¬åœ°åæ ‡ï¼ˆæ—‹è½¬äº†180åº¦ï¼‰
                        const lx = enemy.x - bullet.x;
                        const ly = enemy.y - bullet.y;
                        ctx.save();
                        ctx.setTransform(1,0,0,1,0,0); // ä¿è¯ä½¿ç”¨å•ä½å˜æ¢
                        hit = ctx.isPointInPath(enemy._hitPath, lx, ly, 'nonzero');
                        ctx.restore();
                    } else {
                        const hbW = (enemy.hitW || enemy.width);
                        const hbH = (enemy.hitH || enemy.height);
                        hit = Math.abs(bullet.x - enemy.x) < hbW / 2 && Math.abs(bullet.y - enemy.y) < hbH / 2;
                    }
                    if (hit) {
                        ObjectPool.releaseBullet(bullet); // å›æ”¶å­å¼¹åˆ°å¯¹è±¡æ± 
                        bullets.splice(bIndex, 1);
                        
                        // æŠ¤ç›¾é±¼çš„æŠ¤ç›¾å¸æ”¶ä¼¤å®³
                        if (enemy.type === 'shield' && enemy.shieldHp > 0) {
                            enemy.shieldHp--;
                            enemy.hitFlash = 8;
                            // æŠ¤ç›¾ç ´ç¢æ—¶æ˜¾ç¤ºç‰¹æ•ˆ
                            if (enemy.shieldHp <= 0) {
                                createExplosion(enemy.x, enemy.y, 0.3);
                            }
                            break; // æŠ¤ç›¾å¸æ”¶äº†ä¼¤å®³ï¼Œè·³å‡ºæ•Œäººå¾ªç¯
                        }
                        
                        enemy.hp--;
                        enemy.hitFlash = 8;
                        
                        // Bossè¢«å‡»ä¸­æ—¶æœ‰æ¦‚ç‡æ‰è½é“å…·
                        if (enemy.type === 'boss' && Math.random() < 0.03) {
                            spawnBossPowerUp(enemy.x + (Math.random() - 0.5) * 60, enemy.y + 50);
                        }
                        
                        // æ›´æ–°Bossè¡€æ¡
                        if (enemy.type === 'boss') {
                            updateBossHpBar(enemy);
                        }
                        
                        // ä¸‰é˜¶æ®µBossé˜¶æ®µè½¬æ¢æ£€æŸ¥
                        if (enemy.type === 'boss' && enemy.isMultiPhase && !enemy.phaseTransitioning) {
                            const config = enemy.multiPhaseConfig;
                            const hpPercent = enemy.hp / enemy.maxHp;
                            const phase1Threshold = 1 - config.phases[0].hpRatio;
                            const phase2Threshold = config.phases[2].hpRatio;
                            
                            if (enemy.currentPhase === 1 && hpPercent <= phase1Threshold) {
                                // è¿›å…¥ç¬¬äºŒé˜¶æ®µ
                                triggerPhaseTransition(enemy, 2);
                            } else if (enemy.currentPhase === 2 && hpPercent <= phase2Threshold) {
                                // è¿›å…¥ç¬¬ä¸‰é˜¶æ®µ
                                triggerPhaseTransition(enemy, 3);
                            }
                        }
                        
                        if (enemy.hp <= 0) {
                            createExplosion(enemy.x, enemy.y, enemy.type === 'boss' ? 3 : 1);
                            
                            // Bossè¢«å‡»è´¥
                            if (enemy.type === 'boss') {
                                gameState.bossActive = false;
                                hideBossHpBar(); // éšè—Bossè¡€æ¡
                                updateStats('bossKill', 1); // æˆå°±: Bosså‡»æ€
                                
                                // Bossæ‰è½å¤šä¸ªé“å…·ï¼ˆä¸‰é˜¶æ®µBosså’Œå½©è›‹Bossæ‰è½æ›´å¤šï¼‰
                                const dropCount = enemy.isMultiPhase ? 5 : (enemy.isSecretBoss ? 6 : 3);
                                for (let i = 0; i < dropCount; i++) {
                                    setTimeout(() => {
                                        spawnPowerUp(enemy.x + (Math.random() - 0.5) * 80, enemy.y);
                                    }, i * 100);
                                }
                                
                                if (gameState.gameMode === 'stage') {
                                    // é—¯å…³æ¨¡å¼ï¼šä¿å­˜å½“å‰å…³å¡åˆ†æ•°
                                    const recordInfo = saveStageScore(gameState.currentStage, gameState.score);
                                    
                                    // è§£é”ä¸‹ä¸€å…³
                                    saveUnlockedStage(gameState.currentStage + 1);
                                    updateStats('stage', gameState.currentStage); // æˆå°±: é€šå…³
                                    
                                    // æ˜¾ç¤ºå…³å¡ç»“ç®—ç•Œé¢
                                    setTimeout(() => {
                                        showStageClear(
                                            gameState.currentStage,
                                            gameState.score,
                                            gameState.elapsedFrames,
                                            gameState.maxCombo,
                                            recordInfo
                                        );
                                    }, 800);
                                } else {
                                    // æ— å°½æ¨¡å¼ - æ— é™ç»§ç»­
                                    gameState.endlessBossCount++;
                                    gameState.nextBossScore += CONFIG.ENDLESS_NEXT_BOSS_ADD; // æé«˜ä¸‹ä¸€æ¬¡Bossåˆ†æ•°é˜ˆå€¼
                                    gameState.lastBossEndFrame = gameState.elapsedFrames;     // è®°å½•Bossç»“æŸæ—¶é—´
                                    
                                    // å½©è›‹Bosså¥–åŠ±ï¼šæ¿€æ´»æ”»é€Ÿå¼ºåŒ–
                                    if (enemy.isSecretBoss) {
                                        gameState.secretBuff = true;
                                        gameState.secretBuffTime = CONFIG.SECRET_BUFF_DURATION;
                                        // æ˜¾ç¤ºå¼ºåŒ–æç¤º
                                        const waveDisplay = document.getElementById('waveDisplay');
                                        waveDisplay.textContent = 'ğŸ”¥ æ”»é€Ÿå¼ºåŒ– 30ç§’!';
                                        waveDisplay.classList.remove('show');
                                        void waveDisplay.offsetWidth;
                                        waveDisplay.classList.add('show');
                                    }
                                }
                            } else {
                                spawnPowerUp(enemy.x, enemy.y);
                                // é—¯å…³æ¨¡å¼è®¡æ•°
                                if (gameState.gameMode === 'stage') {
                                    gameState.stageEnemyCount++;
                                }
                            }
                            // ä»åŸå§‹enemiesæ•°ç»„ä¸­åˆ é™¤ï¼ˆè€Œä¸æ˜¯nearbyEnemiesï¼‰
                            const realIndex = enemies.indexOf(enemy);
                            if (realIndex !== -1) {
                                ObjectPool.releaseEnemy(enemy); // å›æ”¶åˆ°å¯¹è±¡æ± 
                                enemies.splice(realIndex, 1);
                            }
                            updateStats('kill', 1); // æˆå°±: å‡»æ€æ•Œäºº
                            
                            // è®¡åˆ†ï¼ˆé™åˆ† + è¿å‡»å°é¡¶ï¼‰
                            let points;
                            switch(enemy.type) {
                                case 'boss': points = 300 * (enemy.rewardMultiplier || 1); break;
                                case 'tank': points = 40; break;
                                case 'sniper': points = 35; break;
                                case 'splitter': points = 25; break;
                                case 'bomber': points = 45; break;  // è½°ç‚¸é±¼
                                case 'shield': points = 50; break;  // æŠ¤ç›¾é±¼ï¼ˆéš¾æ‰“ï¼‰
                                case 'healer': points = 55; break;  // æ²»æ„ˆé±¼ï¼ˆä¼˜å…ˆå‡»æ€ï¼‰
                                case 'fast': points = 20; break;
                                case 'swarm': points = 8; break;    // èœ‚ç¾¤é±¼ï¼ˆå¼±ï¼‰
                                case 'mini': points = 10; break;
                                default: points = 15;
                            }
                            gameState.combo++;
                            if (gameState.combo > gameState.maxCombo) {
                                gameState.maxCombo = gameState.combo;
                                updateStats('combo', gameState.combo); // æˆå°±: è¿å‡»
                            }
                            const comboMult = 1 + Math.min(gameState.combo, 10) * 0.05; // æœ€é«˜1.5x
                            gameState.score += Math.floor(points * comboMult);
                            updateStats('score', gameState.score); // æˆå°±: åˆ†æ•°
                        }
                        break; // å­å¼¹å·²å¤„ç†ï¼Œè·³å‡ºæ•Œäººå¾ªç¯
                    }
                }
            }

            // ç¢°æ’æ£€æµ‹ï¼šæ•Œäººå­å¼¹ vs ç©å®¶ï¼ˆæ— æ•Œæ—¶å…ç–«ï¼‰
            if (!gameState.isInvincible && player.invincible <= 0) {
                let playerWasHit = false;
                for (let bIndex = bullets.length - 1; bIndex >= 0; bIndex--) {
                    const bullet = bullets[bIndex];
                    if (bullet.type !== 'enemy') continue;
                    if (playerWasHit) continue; // å·²è¢«å‡»ä¸­åä¸å†æ£€æµ‹
                    
                    if (Math.abs(bullet.x - player.x) < 20 &&
                        Math.abs(bullet.y - player.y) < 20) {
                        ObjectPool.releaseBullet(bullet); // å›æ”¶åˆ°å¯¹è±¡æ± 
                        bullets.splice(bIndex, 1);
                        playerWasHit = true;
                        playerHit();
                    }
                }
                
                // ç¢°æ’æ£€æµ‹ï¼šæ•Œäºº vs ç©å®¶ï¼ˆä»åå‘å‰éå†ï¼‰
                if (!playerWasHit && player.invincible <= 0) {
                    for (let eIndex = enemies.length - 1; eIndex >= 0; eIndex--) {
                        const enemy = enemies[eIndex];
                        if (checkCollision(
                            { x: player.x, y: player.y, width: 30, height: 30 },
                            { x: enemy.x, y: enemy.y, width: (enemy.hitW || enemy.width), height: (enemy.hitH || enemy.height) }
                        )) {
                            createExplosion(enemy.x, enemy.y);
                            ObjectPool.releaseEnemy(enemy); // å›æ”¶åˆ°å¯¹è±¡æ± 
                            enemies.splice(eIndex, 1);
                            playerHit();
                            break; // åªå¤„ç†ä¸€æ¬¡ç¢°æ’
                        }
                    }
                }
            }

            // ç¢°æ’æ£€æµ‹ï¼šé“å…· vs ç©å®¶ï¼ˆä»åå‘å‰éå†ï¼‰
            for (let pIndex = powerUps.length - 1; pIndex >= 0; pIndex--) {
                const p = powerUps[pIndex];
                if (Math.abs(p.x - player.x) < 25 && Math.abs(p.y - player.y) < 25) {
                    if (p.powerType === 'shield') {
                        // æ— æ•ŒæŠ¤ç›¾
                        gameState.isInvincible = true;
                        gameState.invincibleTime = CONFIG.SHIELD_DURATION;
                    } else if (p.powerType === 'drone') {
                        // èªä»”é±¼ - å¯å åŠ ï¼Œæœ€å¤š2åªï¼Œæ—¶é—´é‡ç½®
                        gameState.droneActive = true;
                        gameState.droneTime = CONFIG.DRONE_DURATION; // é‡ç½®æ—¶é—´
                        addDrone();
                    } else if (p.powerType === 'heart') {
                        // çˆ±å¿ƒ - æ¢å¤ç”Ÿå‘½ï¼ˆæ‰€æœ‰æ¨¡å¼ï¼‰
                        if (gameState.lives < CONFIG.ENDLESS_LIVES) {
                            gameState.lives++;
                            showLivesHint();
                        }
                    } else if (p.powerType === 'blackhole') {
                        // é»‘æ´ - åœ¨é¡¶éƒ¨ä¸­å¤®ç”Ÿæˆé»‘æ´
                        spawnBlackhole(CONFIG.CANVAS_WIDTH / 2, 150);
                    } else {
                        // æ­¦å™¨é“å…· - åŒç±»å åŠ å‡çº§ï¼ˆæœ€å¤š3çº§ï¼‰ï¼Œæ—¶é—´é‡ç½®
                        if (gameState.powerUpType === p.powerType) {
                            gameState.powerUpLevel = Math.min(3, (gameState.powerUpLevel || 0) + 1);
                        } else {
                            gameState.powerUpType = p.powerType;
                            gameState.powerUpLevel = 1;
                        }
                        gameState.powerUpTime = CONFIG.POWERUP_DURATION; // é‡ç½®æ—¶é—´
                    }
                    ObjectPool.releasePowerUp(p); // å›æ”¶åˆ°å¯¹è±¡æ± 
                    powerUps.splice(pIndex, 1);
                    updateStats('powerup', 1); // æˆå°±: æ‹¾å–é“å…·
                }
            }

            // æ ¹æ®æ¸¸æˆæ¨¡å¼å¤„ç†è¿›åº¦
            if (gameState.gameMode === 'stage') {
            // é—¯å…³æ¨¡å¼ï¼šå‡»è´¥è¶³å¤Ÿæ•Œäººåå‡ºç°Bossï¼ˆä¸”è¾¾åˆ°æœ€çŸ­æ—¶é—´ï¼‰
                const enemiesNeeded = CONFIG.STAGE_BOSS_BASE + gameState.currentStage * CONFIG.STAGE_BOSS_PER_STAGE;
                if (
                    gameState.stageEnemyCount >= enemiesNeeded &&
                    !gameState.bossActive &&
                    !gameState.stageBossSpawned &&
                    gameState.elapsedFrames >= CONFIG.BOSS_MIN_TIME_STAGE
                ) {
                    gameState.stageBossSpawned = true;
                    spawnBoss();
                }
            } else {
                // æ— å°½æ¨¡å¼ï¼šæ³¢æ¬¡å‡çº§
                if (gameState.score > gameState.wave * 1000) {
                    gameState.wave++;
                    showWave();
                }
                
                // æ£€æŸ¥æ˜¯å¦è¦ç”ŸæˆBossï¼ˆè¾¾åˆ°åˆ†æ•°ä¸”ä¸ä¸Šæ¬¡Bossé—´éš”è¶³å¤Ÿé•¿ï¼‰
                if (
                    gameState.score >= gameState.nextBossScore &&
                    !gameState.bossActive &&
                    gameState.elapsedFrames >= (gameState.lastBossEndFrame + CONFIG.BOSS_MIN_TIME_ENDLESS)
                ) {
                    spawnBoss();
                }
            }

            // ç”Ÿæˆæ•Œäºº - Bosså‡ºç°æ—¶ä¸ç”Ÿæˆæ™®é€šæ•Œäºº
            if (gameState.bossActive) {
                // Bossæˆ˜æœŸé—´ä¸ç”Ÿæˆæ–°æ•Œäºº
            } else {
                let spawnRate, maxEnemies;
                if (gameState.gameMode === 'stage') {
                    // ç¬¬1å…³: spawnRate=0.025, maxEnemies=4; ç¬¬10å…³: spawnRate=0.04, maxEnemies=6; ç¬¬20å…³: spawnRate=0.055, maxEnemies=8
                    spawnRate = 0.025 + gameState.currentStage * 0.0015; // é™ä½ç”Ÿæˆç‡å¢é•¿
                    maxEnemies = 4 + Math.floor(gameState.currentStage * 0.2); // é™ä½æœ€å¤§æ•°é‡
                } else {
                    // æ— å°½æ¨¡å¼ï¼šåŸºç¡€ä¸é—¯å…³æ¨¡å¼ä¸€è‡´ï¼Œä½†è¶…è¿‡20æ³¢åç¼“æ…¢å¢åŠ ï¼Œæœ‰å°é¡¶
                    const wave = gameState.wave;
                    const baseWave = Math.min(wave, 20);
                    const extraWave = wave > 20 ? (wave - 20) * 0.25 : 0;
                    spawnRate = Math.min(0.10, 0.025 + (baseWave + extraWave) * 0.003);  // å°é¡¶ 0.10
                    maxEnemies = Math.min(15, 5 + Math.floor((baseWave + extraWave) * 0.5)); // å°é¡¶ 15ä¸ª
                }
                
                if (Math.random() < spawnRate && enemies.length < maxEnemies) {
                    // æ£€æŸ¥æ˜¯å¦ç”Ÿæˆèœ‚ç¾¤é±¼
                    const stage = gameState.gameMode === 'stage' ? gameState.currentStage : gameState.wave;
                    const theme = STAGE_THEMES[(stage - 1) % STAGE_THEMES.length];
                    if (theme.types.includes('swarm') && Math.random() < 0.3) {
                        // 30%æ¦‚ç‡ç”Ÿæˆèœ‚ç¾¤ï¼ˆ3-5åªï¼‰
                        const swarmCount = 3 + Math.floor(Math.random() * 3);
                        const baseX = Math.random() * (CONFIG.CANVAS_WIDTH - 150) + 75;
                        for (let i = 0; i < swarmCount && enemies.length < maxEnemies + 3; i++) {
                            spawnSwarmEnemy(baseX + (i - swarmCount/2) * 35, theme);
                        }
                    } else {
                        spawnEnemy();
                    }
                }
            }

            updateUI();
        }

        // ç©å®¶å—å‡»
        function playerHit() {
            createExplosion(player.x, player.y, 1.5);
            
            // æ‰€æœ‰æ¨¡å¼éƒ½æœ‰å¤šæ¡å‘½
            if (gameState.lives > 1) {
                gameState.lives--;
                // ç»™äºˆçŸ­æš‚æ— æ•Œæ—¶é—´
                player.invincible = CONFIG.RESPAWN_INVINCIBLE;
                // é‡ç½®è¿å‡»
                gameState.combo = 0;
                // æ˜¾ç¤ºå‰©ä½™ç”Ÿå‘½æç¤º
                showLivesHint();
            } else {
                gameOver();
            }
        }
        
        // æ˜¾ç¤ºå‰©ä½™ç”Ÿå‘½æç¤º
        function showLivesHint() {
            const waveDisplay = document.getElementById('waveDisplay');
            waveDisplay.textContent = 'â¤ï¸'.repeat(gameState.lives);
            waveDisplay.classList.remove('show');
            void waveDisplay.offsetWidth;
            waveDisplay.classList.add('show');
        }

        // æ¸¸æˆç»“æŸ
        function gameOver() {
            gameState.isRunning = false;
            document.getElementById('pauseBtn').classList.add('hidden');
            hideBossHpBar(); // éšè—Bossè¡€æ¡
            updateStats('game', 1); // æˆå°±: æ¸¸æˆæ¬¡æ•°
            document.getElementById('finalScore').textContent = gameState.score;
            
            // è®°å½•å¤±è´¥å…³å¡ç”¨äº"å†æ¬¡å®ˆæŠ¤"
            if (gameState.gameMode === 'stage') {
                localStorage.setItem('resumeStage', String(gameState.currentStage));
            }
            
            // æ˜¾ç¤ºå…³å¡ä¿¡æ¯å’Œæœ€é«˜åˆ†
            const stageInfo = document.getElementById('stageInfo');
            if (gameState.gameMode === 'stage') {
                const highScore = getStageHighScore(gameState.currentStage);
                stageInfo.innerHTML = `ç¬¬ ${gameState.currentStage} å…³ | æœ€é«˜åˆ†: <span style="color:#ffd700">${highScore}</span>`;
            } else {
                const enteredLeaderboard = saveEndlessScore(gameState.score);
                const highScore = getEndlessHighScore();
                const leaderboard = getLeaderboard();
                const rank = leaderboard.findIndex(item => item.score === gameState.score) + 1;
                
                if (gameState.score === highScore && gameState.score > 0) {
                    stageInfo.innerHTML = `ğŸ‰ æ–°çºªå½•! æ’è¡Œæ¦œç¬¬${rank}å!`;
                } else if (enteredLeaderboard && rank > 0) {
                    stageInfo.innerHTML = `ğŸ… è¿›å…¥æ’è¡Œæ¦œç¬¬${rank}å! æœ€é«˜åˆ†: <span style="color:#ffd700">${highScore}</span>`;
                } else {
                    stageInfo.innerHTML = `æœ€é«˜åˆ†: <span style="color:#ffd700">${highScore}</span>`;
                }
            }
            
            document.getElementById('gameOverScreen').classList.remove('hidden');
        }
        
        // æ¸¸æˆé€šå…³
        function gameWin() {
            gameState.isRunning = false;
            document.getElementById('pauseBtn').classList.add('hidden');
            hideBossHpBar(); // éšè—Bossè¡€æ¡
            // ä¿å­˜æœ€åä¸€å…³åˆ†æ•°
            saveStageScore(gameState.currentStage, gameState.score);
            document.getElementById('winScore').textContent = gameState.score;
            document.getElementById('winScreen').classList.remove('hidden');
        }

        // ç»˜åˆ¶
        function draw() {
            // ç»˜åˆ¶èƒŒæ™¯
            if (bgImageReady) {
                // ä½¿ç”¨èƒŒæ™¯å›¾ï¼ŒæŒ‰æ¯”ä¾‹ç¼©æ”¾è¦†ç›–æ•´ä¸ªç”»å¸ƒ
                const imgRatio = bgImage.width / bgImage.height;
                const canvasRatio = CONFIG.CANVAS_WIDTH / CONFIG.CANVAS_HEIGHT;
                let drawWidth, drawHeight, offsetX, offsetY;
                
                if (canvasRatio > imgRatio) {
                    // ç”»å¸ƒæ›´å®½ï¼Œä»¥å®½åº¦ä¸ºå‡†
                    drawWidth = CONFIG.CANVAS_WIDTH;
                    drawHeight = CONFIG.CANVAS_WIDTH / imgRatio;
                    offsetX = 0;
                    offsetY = (CONFIG.CANVAS_HEIGHT - drawHeight) / 2;
                } else {
                    // ç”»å¸ƒæ›´é«˜ï¼Œä»¥é«˜åº¦ä¸ºå‡†
                    drawHeight = CONFIG.CANVAS_HEIGHT;
                    drawWidth = CONFIG.CANVAS_HEIGHT * imgRatio;
                    offsetX = (CONFIG.CANVAS_WIDTH - drawWidth) / 2;
                    offsetY = 0;
                }
                
                ctx.drawImage(bgImage, offsetX, offsetY, drawWidth, drawHeight);
            } else {
                // å¤‡ç”¨ï¼šæµ·åº•æ¸å˜èƒŒæ™¯
                const gradient = ctx.createLinearGradient(0, 0, 0, CONFIG.CANVAS_HEIGHT);
                gradient.addColorStop(0, '#001a33');
                gradient.addColorStop(0.3, '#003366');
                gradient.addColorStop(0.6, '#004080');
                gradient.addColorStop(1, '#001a4d');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
            }
            
            // ç»˜åˆ¶å„å…ƒç´ 
            drawStars();
            drawBlackholes();
            drawPowerUps();
            drawDrones();
            drawBullets();
            drawEnemies();
            drawPlayer();
            drawExplosions();
        }

        // æ·»åŠ èªä»”é±¼ - æœ€å¤š2åª
        function addDrone() {
            const maxDrones = 2;
            if (!drones) drones = [];
            
            if (drones.length < maxDrones) {
                // æ·»åŠ æ–°çš„èªä»”é±¼
                if (drones.length === 0) {
                    // ç¬¬ä¸€åªï¼šå·¦ä¾§
                    drones.push({ offsetX: -45, offsetY: -10, shootCooldown: 0 });
                } else if (drones.length === 1) {
                    // ç¬¬äºŒåªï¼šå³ä¾§
                    drones.push({ offsetX: 45, offsetY: -10, shootCooldown: 0 });
                }
            }
            // å·²æ»¡2åªæ—¶ï¼Œåªåˆ·æ–°æ—¶é—´
        }
        
        // ç”Ÿæˆé»‘æ´
        function spawnBlackhole(x, y) {
            blackholes.push({
                x: x,
                y: y,
                radius: CONFIG.BLACKHOLE_RADIUS,
                duration: CONFIG.BLACKHOLE_DURATION,
                rotation: 0
            });
            // æ˜¾ç¤ºé»‘æ´æç¤º
            const waveDisplay = document.getElementById('waveDisplay');
            waveDisplay.textContent = 'ğŸŒ€ é»‘æ´å¯åŠ¨!';
            waveDisplay.classList.remove('show');
            void waveDisplay.offsetWidth;
            waveDisplay.classList.add('show');
        }
        
        // æ›´æ–°é»‘æ´
        function updateBlackholes() {
            for (let i = blackholes.length - 1; i >= 0; i--) {
                const bh = blackholes[i];
                bh.duration--;
                bh.rotation += 0.15;
                
                // å¸å¼•æ•Œäºº - å…ˆå¸åˆ°ä¸­å¿ƒå†æ¶ˆç­ï¼ˆè¶…å¤§èŒƒå›´å¸å¼•ï¼‰
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    if (enemy.type === 'boss') continue; // Bossä¸è¢«å¸å¼•
                    
                    const dx = bh.x - enemy.x;
                    const dy = bh.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    // æ‰©å¤§å¸å¼•èŒƒå›´ï¼šåªè¦æ•Œäººåœ¨å±å¹•ä¸ŠåŠéƒ¨åˆ†ä¸”åœ¨æ°´å¹³èŒƒå›´å†…å°±å¸å¼•
                    const inVerticalRange = enemy.y < CONFIG.CANVAS_HEIGHT * 0.6;
                    const effectiveRadius = Math.max(bh.radius, CONFIG.CANVAS_WIDTH * 0.6);
                    
                    if (dist < effectiveRadius || inVerticalRange) {
                        // æ ‡è®°ä¸ºè¢«å¸å¼•çŠ¶æ€ï¼Œç¦ç”¨æ­£å¸¸ç§»åŠ¨
                        enemy.beingSucked = true;
                        
                        // å¸å¼•åŠ›ï¼šè·ç¦»è¶Šè¿œå¸åŠ›è¶Šå¼ºï¼ˆç¡®ä¿èƒ½æ‹‰è¿‡æ¥ï¼‰
                        const basePull = CONFIG.BLACKHOLE_PULL_FORCE;
                        const pullStrength = basePull + (dist / 100) * 3 + (1 - dist / effectiveRadius) * 6;
                        const clampedPull = Math.min(pullStrength, 15); // æœ€å¤§é€Ÿåº¦é™åˆ¶
                        
                        if (dist > 1) {
                            enemy.x += (dx / dist) * clampedPull;
                            enemy.y += (dy / dist) * clampedPull;
                        }
                        
                        // åˆ°è¾¾ä¸­å¿ƒåˆ™æ¶ˆç­
                        if (dist < 30) {
                            createExplosion(bh.x, bh.y, 0.8);
                            ObjectPool.releaseEnemy(enemy); // å›æ”¶åˆ°å¯¹è±¡æ± 
                            enemies.splice(j, 1);
                            gameState.score += 15;
                            gameState.combo++;
                            updateStats('kill', 1);
                        }
                    }
                }
                
                // å¸å¼•æ•Œäººå­å¼¹
                for (let j = bullets.length - 1; j >= 0; j--) {
                    const bullet = bullets[j];
                    if (bullet.type !== 'enemy') continue;
                    
                    const dx = bh.x - bullet.x;
                    const dy = bh.y - bullet.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < bh.radius) {
                        // å¼ºåŠ›å¸å¼•å­å¼¹
                        const pullStrength = 3 + (1 - dist / bh.radius) * 6;
                        bullet.vx = (dx / dist) * pullStrength;
                        bullet.vy = (dy / dist) * pullStrength;
                        
                        // åˆ°è¾¾ä¸­å¿ƒåˆ™æ¶ˆç­
                        if (dist < 20) {
                            bullets.splice(j, 1);
                        }
                    }
                }
                
                // æ—¶é—´åˆ°åˆ™ç§»é™¤é»‘æ´
                if (bh.duration <= 0) {
                    blackholes.splice(i, 1);
                }
            }
        }
        
        // ç»˜åˆ¶é»‘æ´
        function drawBlackholes() {
            blackholes.forEach(bh => {
                ctx.save();
                ctx.translate(bh.x, bh.y);
                ctx.rotate(bh.rotation);
                
                // å¤–åœˆå¸å¼•èŒƒå›´æŒ‡ç¤º
                const fadeRatio = Math.min(1, bh.duration / 30); // æœ€å0.5ç§’æ·¡å‡º
                ctx.globalAlpha = 0.2 * fadeRatio;
                ctx.beginPath();
                ctx.arc(0, 0, bh.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#4a0080';
                ctx.fill();
                
                // æ—‹æ¶¡çº¿æ¡
                ctx.globalAlpha = 0.6 * fadeRatio;
                for (let i = 0; i < 4; i++) {
                    ctx.beginPath();
                    ctx.strokeStyle = `hsl(${270 + i * 20}, 80%, ${50 + i * 10}%)`;
                    ctx.lineWidth = 3;
                    const startAngle = (i / 4) * Math.PI * 2;
                    for (let j = 0; j < 50; j++) {
                        const angle = startAngle + j * 0.15;
                        const r = 10 + j * 1.8;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        if (j === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                
                // ä¸­å¿ƒé»‘æ´
                ctx.globalAlpha = 1 * fadeRatio;
                const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 25);
                coreGrad.addColorStop(0, '#000000');
                coreGrad.addColorStop(0.5, '#1a0033');
                coreGrad.addColorStop(1, '#4a0080');
                ctx.beginPath();
                ctx.arc(0, 0, 25, 0, Math.PI * 2);
                ctx.fillStyle = coreGrad;
                ctx.fill();
                
                // ä¸­å¿ƒå…‰æ™•
                ctx.shadowColor = '#9932cc';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(0, 0, 8, 0, Math.PI * 2);
                ctx.fillStyle = '#9932cc';
                ctx.fill();
                
                ctx.restore();
            });
        }

        // æ¸¸æˆä¸»å¾ªç¯
        function gameLoop() {
            update();
            draw();
            
            if (gameState.isRunning) {
                requestAnimationFrame(gameLoop);
            }
        }

        // é”®ç›˜äº‹ä»¶
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.code === 'Space') e.preventDefault();
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // ============ ç§»åŠ¨ç«¯è§¦æ‘¸æ§åˆ¶ ============
        let touchTarget = { x: 0, y: 0 };
        let isTouching = false;
        
        // è·å–canvasç›¸å¯¹ä½ç½®
        function getTouchPos(touch) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = CONFIG.CANVAS_WIDTH / rect.width;
            const scaleY = CONFIG.CANVAS_HEIGHT / rect.height;
            return {
                x: (touch.clientX - rect.left) * scaleX,
                y: (touch.clientY - rect.top) * scaleY
            };
        }
        
        // è§¦æ‘¸å¼€å§‹
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const pos = getTouchPos(touch);
            touchTarget.x = pos.x;
            touchTarget.y = pos.y;
            isTouching = true;
        }, { passive: false });
        
        // è§¦æ‘¸ç§»åŠ¨ - é±¼è·Ÿéšæ‰‹æŒ‡
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!isTouching) return;
            const touch = e.touches[0];
            const pos = getTouchPos(touch);
            touchTarget.x = pos.x;
            touchTarget.y = pos.y;
        }, { passive: false });
        
        // è§¦æ‘¸ç»“æŸ
        canvas.addEventListener('touchend', (e) => {
            isTouching = false;
        });
        
        canvas.addEventListener('touchcancel', (e) => {
            isTouching = false;
        });
        
        // é˜²æ­¢é¡µé¢æ»šåŠ¨
        document.addEventListener('touchmove', (e) => {
            if (gameState.isRunning) {
                e.preventDefault();
            }
        }, { passive: false });

        // åˆå§‹åŒ–
        initGame();
        draw();
        
        // ============ é¦–é¡µ Canvas åŠ¨ç”»ç³»ç»Ÿ ============
        const hpCanvas = document.getElementById('homepageCanvas');
        const hpCtx = hpCanvas.getContext('2d');
        let hpFrame = 0;
        let homepageBubbles = [];
        let homepageFish = [];
        let lightRays = [];
        let hpAnimationId = null;
        
        // æ°”æ³¡ç±»
        class HomepageBubble {
            constructor(w, h) {
                this.w = w;
                this.h = h;
                this.reset();
            }
            reset() {
                this.x = Math.random() * this.w;
                this.y = this.h + Math.random() * 50;
                this.r = Math.random() * 10 + 4;
                this.speed = Math.random() * 1.5 + 0.8;
                this.opacity = Math.random() * 0.5 + 0.3;
                this.drift = (Math.random() - 0.5) * 0.8;
            }
            update() {
                this.y -= this.speed;
                this.x += this.drift + Math.sin(hpFrame * 0.03 + this.x * 0.01) * 0.3;
                this.r += 0.01;
                this.opacity = Math.max(0.1, this.opacity - 0.001);
                if (this.y < -30 || this.opacity <= 0.1) this.reset();
            }
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                // æ°”æ³¡å¤–åœˆ
                ctx.beginPath();
                ctx.fillStyle = 'rgba(72, 202, 228, 0.2)';
                ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                ctx.fill();
                // æ°”æ³¡é«˜å…‰
                ctx.beginPath();
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.arc(this.x - this.r * 0.3, this.y - this.r * 0.3, this.r * 0.4, 0, Math.PI * 2);
                ctx.fill();
                // æ°”æ³¡è¾¹æ¡†
                ctx.strokeStyle = 'rgba(72, 202, 228, 0.4)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }
        }
        
        // å…‰æ–‘ç±»
        class LightRay {
            constructor(w, h) {
                this.w = w;
                this.h = h;
                this.reset();
            }
            reset() {
                this.x = Math.random() * this.w;
                this.y = Math.random() * this.h;
                this.size = Math.random() * 120 + 60;
                this.opacity = Math.random() * 0.25 + 0.08;
                this.speed = Math.random() * 0.4 + 0.15;
                this.angle = Math.random() * Math.PI * 2;
            }
            update() {
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                this.opacity += Math.sin(hpFrame * 0.03 + this.x * 0.01) * 0.03;
                this.opacity = Math.max(0.05, Math.min(0.35, this.opacity));
                if (this.x < -this.size || this.x > this.w + this.size ||
                    this.y < -this.size || this.y > this.h + this.size) {
                    this.reset();
                }
            }
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                const grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
                grad.addColorStop(0, 'rgba(72, 202, 228, 0.5)');
                grad.addColorStop(0.5, 'rgba(0, 119, 182, 0.2)');
                grad.addColorStop(1, 'rgba(0, 119, 182, 0)');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        
        // é¦–é¡µé±¼ç±»
        class HomepageFish {
            constructor(w, h) {
                this.w = w;
                this.h = h;
                this.reset();
            }
            reset() {
                this.direction = Math.random() > 0.5 ? 1 : -1;
                this.x = this.direction > 0 ? -50 : this.w + 50;
                this.y = Math.random() * this.h * 0.8 + this.h * 0.1;
                this.r = Math.random() * 15 + 10;
                this.speed = (Math.random() * 1.5 + 0.8) * this.direction;
                this.opacity = Math.random() * 0.4 + 0.4;
                // éšæœºé±¼ç±»å‹ï¼šçƒ­å¸¦é±¼ã€å°ä¸‘é±¼ã€é‡‘é±¼ã€æµ·è±šã€æµ·é¾Ÿã€æ°´æ¯ã€ç« é±¼ã€é²¸é±¼
                const types = ['tropical', 'clownfish', 'goldfish', 'dolphin', 'turtle', 'jellyfish', 'octopus', 'whale'];
                this.type = types[Math.floor(Math.random() * types.length)];
                this.yOffset = 0;
                // åœ¨resetæ—¶å›ºå®šé¢œè‰²ï¼Œé¿å…æ¯å¸§é—ªçƒ
                this.assignColors();
            }
            assignColors() {
                switch(this.type) {
                    case 'tropical':
                        this.bodyColor = `hsl(${180 + Math.random() * 60}, 70%, 60%)`;
                        this.finColor = `hsl(${200 + Math.random() * 40}, 80%, 70%)`;
                        break;
                    case 'clownfish':
                        this.bodyColor = '#ff7f50';
                        this.finColor = '#fff';
                        break;
                    case 'goldfish':
                        this.bodyColor = '#ffd700';
                        this.finColor = '#ffb347';
                        break;
                    case 'dolphin':
                        this.bodyColor = '#4a90d9';
                        this.finColor = '#6bb3e0';
                        break;
                    case 'turtle':
                        this.bodyColor = '#228b22';
                        this.finColor = '#32cd32';
                        break;
                    case 'jellyfish':
                        this.bodyColor = `hsla(${280 + Math.random() * 40}, 60%, 75%, 0.7)`;
                        this.finColor = `hsla(${300 + Math.random() * 30}, 50%, 80%, 0.5)`;
                        break;
                    case 'octopus':
                        this.bodyColor = `hsl(${340 + Math.random() * 30}, 50%, 55%)`;
                        this.finColor = `hsl(${350 + Math.random() * 20}, 60%, 65%)`;
                        break;
                    case 'whale':
                        this.bodyColor = '#36648b';
                        this.finColor = '#5cacee';
                        break;
                    default:
                        this.bodyColor = '#48cae4';
                        this.finColor = '#90e0ef';
                }
            }
            update() {
                this.x += this.speed;
                this.yOffset = Math.sin(hpFrame * 0.04 + this.x * 0.02) * 3;
                if ((this.direction > 0 && this.x > this.w + 60) ||
                    (this.direction < 0 && this.x < -60)) {
                    this.reset();
                }
            }
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.translate(this.x, this.y + this.yOffset);
                if (this.direction < 0) ctx.scale(-1, 1);
                this.drawFishShape(ctx);
                ctx.restore();
            }
            drawFishShape(ctx) {
                const r = this.r;
                const bodyColor = this.bodyColor;
                const finColor = this.finColor;
                const eyeColor = '#fff';
                
                // æ ¹æ®é±¼ç±»å‹ç»˜åˆ¶ä¸åŒå½¢çŠ¶
                if (this.type === 'jellyfish') {
                    this.drawJellyfish(ctx, r, bodyColor, finColor);
                    return;
                }
                if (this.type === 'octopus') {
                    this.drawOctopus(ctx, r, bodyColor, finColor);
                    return;
                }
                if (this.type === 'whale') {
                    this.drawWhale(ctx, r, bodyColor, finColor);
                    return;
                }
                
                // å°¾å·´
                ctx.beginPath();
                ctx.fillStyle = finColor;
                ctx.moveTo(-r * 1.2, 0);
                ctx.lineTo(-r * 2, -r * 0.6);
                ctx.lineTo(-r * 2, r * 0.6);
                ctx.closePath();
                ctx.fill();
                
                // èº«ä½“
                ctx.beginPath();
                ctx.fillStyle = bodyColor;
                ctx.ellipse(0, 0, r * 1.2, r * 0.8, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // èƒŒé³
                ctx.beginPath();
                ctx.fillStyle = finColor;
                ctx.moveTo(-r * 0.3, -r * 0.7);
                ctx.quadraticCurveTo(0, -r * 1.3, r * 0.5, -r * 0.7);
                ctx.lineTo(r * 0.3, -r * 0.7);
                ctx.closePath();
                ctx.fill();
                
                // çœ¼ç›
                ctx.beginPath();
                ctx.fillStyle = eyeColor;
                ctx.arc(r * 0.5, -r * 0.1, r * 0.25, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.fillStyle = '#000';
                ctx.arc(r * 0.55, -r * 0.1, r * 0.12, 0, Math.PI * 2);
                ctx.fill();
                
                // å°ä¸‘é±¼ç‰¹æœ‰æ¡çº¹
                if (this.type === 'clownfish') {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = r * 0.15;
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.3, -r * 0.7);
                    ctx.lineTo(-r * 0.3, r * 0.7);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(r * 0.3, -r * 0.6);
                    ctx.lineTo(r * 0.3, r * 0.6);
                    ctx.stroke();
                }
            }
            // ç»˜åˆ¶æ°´æ¯
            drawJellyfish(ctx, r, bodyColor, finColor) {
                // ä¼ç›–
                ctx.beginPath();
                ctx.fillStyle = bodyColor;
                ctx.arc(0, 0, r, Math.PI, 0, false);
                ctx.closePath();
                ctx.fill();
                // è§¦é¡»ï¼ˆé£˜åŠ¨ï¼‰
                ctx.strokeStyle = finColor;
                ctx.lineWidth = r * 0.1;
                for (let i = 0; i < 5; i++) {
                    const x = (i - 2) * r * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    const wave = Math.sin(hpFrame * 0.08 + i) * r * 0.3;
                    ctx.quadraticCurveTo(x + wave, r * 0.8, x, r * 1.5);
                    ctx.stroke();
                }
            }
            // ç»˜åˆ¶ç« é±¼
            drawOctopus(ctx, r, bodyColor, finColor) {
                // å¤´éƒ¨
                ctx.beginPath();
                ctx.fillStyle = bodyColor;
                ctx.ellipse(0, -r * 0.3, r * 0.9, r * 0.7, 0, 0, Math.PI * 2);
                ctx.fill();
                // è§¦æ‰‹
                ctx.fillStyle = finColor;
                for (let i = 0; i < 6; i++) {
                    const angle = (i - 2.5) * 0.4;
                    const baseX = Math.sin(angle) * r * 0.6;
                    ctx.beginPath();
                    ctx.moveTo(baseX, r * 0.2);
                    const wave = Math.sin(hpFrame * 0.06 + i) * r * 0.2;
                    ctx.quadraticCurveTo(baseX + wave, r * 0.8, baseX * 0.5, r * 1.3);
                    ctx.lineWidth = r * 0.2;
                    ctx.strokeStyle = finColor;
                    ctx.stroke();
                }
                // çœ¼ç›
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(-r * 0.3, -r * 0.4, r * 0.2, 0, Math.PI * 2);
                ctx.arc(r * 0.3, -r * 0.4, r * 0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(-r * 0.25, -r * 0.4, r * 0.1, 0, Math.PI * 2);
                ctx.arc(r * 0.35, -r * 0.4, r * 0.1, 0, Math.PI * 2);
                ctx.fill();
            }
            // ç»˜åˆ¶é²¸é±¼
            drawWhale(ctx, r, bodyColor, finColor) {
                // èº«ä½“
                ctx.beginPath();
                ctx.fillStyle = bodyColor;
                ctx.ellipse(0, 0, r * 1.5, r * 0.9, 0, 0, Math.PI * 2);
                ctx.fill();
                // å°¾å·´
                ctx.beginPath();
                ctx.fillStyle = finColor;
                ctx.moveTo(-r * 1.4, 0);
                ctx.lineTo(-r * 2.2, -r * 0.7);
                ctx.quadraticCurveTo(-r * 1.8, 0, -r * 2.2, r * 0.7);
                ctx.closePath();
                ctx.fill();
                // èƒŒé³
                ctx.beginPath();
                ctx.fillStyle = finColor;
                ctx.moveTo(-r * 0.2, -r * 0.85);
                ctx.quadraticCurveTo(r * 0.3, -r * 1.4, r * 0.8, -r * 0.85);
                ctx.closePath();
                ctx.fill();
                // çœ¼ç›
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(r * 0.8, -r * 0.2, r * 0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(r * 0.85, -r * 0.2, r * 0.1, 0, Math.PI * 2);
                ctx.fill();
                // è‚Œè…¹
                ctx.beginPath();
                ctx.fillStyle = '#b0d4e8';
                ctx.ellipse(r * 0.2, r * 0.3, r * 0.9, r * 0.4, 0, 0, Math.PI);
                ctx.fill();
            }
        }
        
        // åˆå§‹åŒ–é¦–é¡µåŠ¨ç”»
        function initHomepageAnimation() {
            hpCanvas.width = window.innerWidth;
            hpCanvas.height = window.innerHeight;
            const w = hpCanvas.width;
            const h = hpCanvas.height;
            
            homepageBubbles = [];
            for (let i = 0; i < 35; i++) {
                homepageBubbles.push(new HomepageBubble(w, h));
            }
            
            lightRays = [];
            for (let i = 0; i < 6; i++) {
                lightRays.push(new LightRay(w, h));
            }
            
            homepageFish = [];
            for (let i = 0; i < 12; i++) {
                homepageFish.push(new HomepageFish(w, h));
            }
            
            startHomepageAnimation();
        }
        
        // é¦–é¡µåŠ¨ç”»å¾ªç¯
        function homepageAnimationLoop() {
            hpFrame++;
            hpCtx.clearRect(0, 0, hpCanvas.width, hpCanvas.height);
            
            // ç»˜åˆ¶èƒŒæ™¯å›¾
            if (bgImageReady) {
                const scale = Math.max(hpCanvas.width / bgImage.width, hpCanvas.height / bgImage.height);
                const w = bgImage.width * scale;
                const h = bgImage.height * scale;
                const x = (hpCanvas.width - w) / 2;
                const y = (hpCanvas.height - h) / 2;
                hpCtx.drawImage(bgImage, x, y, w, h);
            }
            
            // ç»˜åˆ¶å…‰æ–‘
            for (let ray of lightRays) {
                ray.update();
                ray.draw(hpCtx);
            }
            
            // ç»˜åˆ¶æ°”æ³¡
            for (let bubble of homepageBubbles) {
                bubble.update();
                bubble.draw(hpCtx);
            }
            
            // ç»˜åˆ¶é±¼
            for (let fish of homepageFish) {
                fish.update();
                fish.draw(hpCtx);
            }
            
            hpAnimationId = requestAnimationFrame(homepageAnimationLoop);
        }
        
        function startHomepageAnimation() {
            if (!hpAnimationId) {
                homepageAnimationLoop();
            }
        }
        
        function stopHomepageAnimation() {
            if (hpAnimationId) {
                cancelAnimationFrame(hpAnimationId);
                hpAnimationId = null;
            }
        }
        
        // ç›‘å¬çª—å£å¤§å°å˜åŒ–
        window.addEventListener('resize', () => {
            if (!gameState.isRunning) {
                hpCanvas.width = window.innerWidth;
                hpCanvas.height = window.innerHeight;
                const w = hpCanvas.width;
                const h = hpCanvas.height;
                // é‡ç½®æ‰€æœ‰å…ƒç´ çš„å°ºå¯¸å¼•ç”¨
                homepageBubbles.forEach(b => { b.w = w; b.h = h; });
                lightRays.forEach(r => { r.w = w; r.h = h; });
                homepageFish.forEach(f => { f.w = w; f.h = h; });
            } else {
                // æ¸¸æˆè¿è¡Œä¸­æ—¶ï¼ŒåŒæ­¥æ›´æ–°ç”»å¸ƒå°ºå¯¸å’ŒCONFIG
                const container = document.getElementById('game-container');
                CONFIG.CANVAS_WIDTH = container.clientWidth;
                CONFIG.CANVAS_HEIGHT = container.clientHeight;
                canvas.width = CONFIG.CANVAS_WIDTH;
                canvas.height = CONFIG.CANVAS_HEIGHT;
                // æ¸…é™¤æ¸å˜ç¼“å­˜ï¼ˆæ¸å˜ä¾èµ–å°ºå¯¸ï¼‰
                GradientCache.clear();
                GradientCache.init(ctx);
                // ä¿®æ­£ç©å®¶ä½ç½®ï¼ˆé¿å…è¶Šç•Œï¼‰
                player.x = Math.min(Math.max(player.x, 30), CONFIG.CANVAS_WIDTH - 30);
                player.y = Math.min(Math.max(player.y, 30), CONFIG.CANVAS_HEIGHT - 30);
            }
        });
        
        // æ£€æµ‹æ˜¯å¦ä¸ºå¹³æ¿æ¨ªå±
        function isTabletLandscape() {
            const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            const isLandscape = window.innerWidth > window.innerHeight;
            const isTabletSize = window.innerWidth >= 600;
            return isTouchDevice && isLandscape && isTabletSize;
        }
        
        // å±å¹•æ–¹å‘å˜åŒ–æ—¶æ£€æŸ¥
        function checkOrientation() {
            if (isTabletLandscape()) {
                // æ¨ªå±æ—¶æš‚åœæ¸¸æˆ
                if (gameState.isRunning && !gameState.isPaused) {
                    gameState.isPaused = true;
                }
            } else {
                // ç«–å±æ—¶æ¢å¤æ¸¸æˆ
                if (gameState.isPaused) {
                    gameState.isPaused = false;
                }
            }
        }
        
        // ç›‘å¬å±å¹•æ–¹å‘å˜åŒ–
        window.addEventListener('orientationchange', () => {
            setTimeout(checkOrientation, 100);
        });
        window.addEventListener('resize', checkOrientation);
        
        // å¯åŠ¨é¦–é¡µåŠ¨ç”»
        initHomepageAnimation();
    </script>
</body>
</html>
