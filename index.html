<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ’˜ çˆ±çš„å®ˆæŠ¤è€… - Love Guardian</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'PingFang SC', sans-serif;
            background: linear-gradient(180deg, #001a33 0%, #003366 50%, #004080 100%);
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        .game-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .game-hud {
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px;
            display: flex;
            justify-content: flex-start;
            pointer-events: none;
            z-index: 5;
        }

        .hud-score {
            color: #ff69b4;
            font-size: 24px;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(255, 105, 180, 0.8), 0 2px 4px rgba(0,0,0,0.5);
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10;
        }

        .overlay.hidden {
            display: none;
        }

        /* é¦–é¡µç¾åŒ– - æµ·æ´‹ä¸»é¢˜ */
        #startScreen {
            background: transparent;
        }
        #startScreen::before {
            content: '';
            position: absolute;
            inset: 0;
            background:
                radial-gradient(1200px 600px at 80% -10%, rgba(0,180,216,0.25), transparent 60%),
                radial-gradient(900px 500px at -10% 110%, rgba(0,119,182,0.20), transparent 60%),
                radial-gradient(800px 500px at 50% 50%, rgba(72,202,228,0.08), transparent 60%),
                linear-gradient(180deg, rgba(0,26,51,0.95), rgba(0,51,102,0.95));
            z-index: -1;
        }
        /* é¦–é¡µ Canvas èƒŒæ™¯å±‚ */
        #homepageCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 14px;
            width: min(80vw, 360px);
            z-index: 1;
        }
        .menu-btn {
            padding: 14px 26px;
            font-size: 18px;
            font-weight: 700;
            color: #fff;
            border-radius: 14px;
            border: 1px solid rgba(255,255,255,0.25);
            background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02));
            box-shadow: 0 10px 30px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.25);
            backdrop-filter: blur(6px);
            cursor: pointer;
            transition: transform .15s ease, box-shadow .2s ease;
        }
        .menu-btn:hover { transform: translateY(-2px); box-shadow: 0 14px 34px rgba(0,0,0,0.45); }
        .menu-btn:active { transform: translateY(0); }
        .menu-btn.secondary {
            border-color: rgba(0,180,216,0.5);
            background: linear-gradient(180deg, rgba(0,180,216,0.25), rgba(0,119,182,0.15));
        }
        
        /* é¦–é¡µæè¿°ï¼šå±…ä¸­ + é™å®½ + ä¸¤ä¾§å†…è¾¹è· */
        .start-desc {
            color: rgba(255,255,255,0.65);
            font-size: 13px;
            text-align: center;
            width: min(90vw, 420px);
            margin: 6px auto 0;
            line-height: 1.6;
            padding: 0 12px;
            z-index: 1;
        }

        .game-title {
            font-size: 48px;
            font-weight: 800;
            background: linear-gradient(135deg, #ff69b4, #ff1493, #ff6b9d, #da70d6);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradient-shift 3s ease infinite;
            margin-bottom: 10px;
            text-shadow: 0 0 30px rgba(255, 105, 180, 0.5);
        }

        @keyframes gradient-shift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .game-subtitle {
            color: rgba(255, 255, 255, 0.7);
            font-size: 16px;
            margin-bottom: 40px;
            letter-spacing: 3px;
        }

        .btn {
            padding: 15px 50px;
            font-size: 20px;
            font-weight: 600;
            color: #fff;
            background: linear-gradient(135deg, #ff69b4 0%, #ff1493 100%);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 10px 30px rgba(255, 20, 147, 0.4);
            margin: 10px;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 40px rgba(255, 20, 147, 0.6);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-restart {
            background: linear-gradient(135deg, #da70d6 0%, #ff69b4 100%);
            box-shadow: 0 10px 30px rgba(218, 112, 214, 0.4);
        }

        .btn-restart:hover {
            box-shadow: 0 15px 40px rgba(218, 112, 214, 0.6);
        }

        .final-score {
            font-size: 28px;
            color: #fff;
            margin: 20px 0;
        }

        .final-score span {
            color: #ff69b4;
            font-size: 42px;
            font-weight: 700;
        }

        .game-over-title {
            font-size: 48px;
            color: #ff69b4;
            font-weight: 800;
            text-shadow: 0 0 30px rgba(255, 105, 180, 0.8);
            margin-bottom: 20px;
        }

        .instructions {
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            margin-top: 30px;
            text-align: center;
            line-height: 1.8;
        }

        .instructions kbd {
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 12px;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin: 0 3px;
        }

        .power-up-indicator {
            position: absolute;
            top: 80px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 5;
        }

        .power-up-badge {
            padding: 5px 10px;
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
            border-radius: 5px;
            color: #00ff88;
            font-size: 12px;
            font-weight: 600;
        }

        .powerup-status {
            position: absolute;
            top: 45px;
            left: 15px;
            display: flex;
            gap: 8px;
            z-index: 5;
        }
        .powerup-icon {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            background: rgba(0,0,0,0.4);
            border: 2px solid rgba(255,255,255,0.3);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            position: relative;
        }
        .powerup-icon .timer-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background: #ffd700;
            border-radius: 0 0 6px 6px;
            transition: width 0.1s linear;
        }

        .wave-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 36px;
            font-weight: 800;
            color: #fff;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.8);
            opacity: 0;
            z-index: 5;
            pointer-events: none;
        }

        .wave-display.show {
            animation: wave-announce 2s ease-out forwards;
        }

        @keyframes wave-announce {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }

        /* ç§»åŠ¨ç«¯é€‚é… */
        @media (max-width: 520px) {
            .game-title {
                font-size: 36px;
            }
            
            .btn {
                padding: 12px 40px;
                font-size: 18px;
            }
        }

        /* ç§»åŠ¨ç«¯æç¤º */
        .mobile-controls-hint {
            display: none;
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            margin-top: 20px;
            text-align: center;
        }

        @media (pointer: coarse) {
            .instructions {
                display: none;
            }
            
            .mobile-controls-hint {
                display: block;
            }
        }
    </style>
    <script src="static/bg-base64.js"></script>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="480" height="640"></canvas>
        
        <div class="game-hud">
            <div class="hud-score" id="scoreDisplay">0</div>
        </div>
        
        <div class="powerup-status" id="powerupStatus"></div>
        <div class="wave-display" id="waveDisplay"></div>
        
        <!-- å¼€å§‹ç•Œé¢ -->
        <div class="overlay" id="startScreen">
            <canvas id="homepageCanvas"></canvas>
            <div style="font-size: 60px; margin-bottom: 6px; text-shadow:0 10px 30px rgba(255,105,180,.5); z-index: 1;">ğŸ’–</div>
            <div class="game-title" style="z-index: 1;">çˆ±çš„å®ˆæŠ¤è€…</div>
            <div class="game-subtitle" style="z-index: 1;">LOVE GUARDIAN</div>
            <div class="menu-buttons" style="margin: 24px 0;">
                <button class="menu-btn" onclick="showStageSelect()">ğŸ¯ é—¯å…³æ¨¡å¼</button>
                <button class="menu-btn secondary" onclick="startGame('endless')">â™¾ï¸ æ— å°½æ¨¡å¼</button>
            </div>
            <div class="start-desc">
                ğŸŸ è§¦æ‘¸å±å¹•æ§åˆ¶å°é±¼ Â· ğŸ’§ è‡ªåŠ¨å‘å°„æ°”æ³¡ Â· âœ¨ æ”¶é›†é“å…·å¢å¼ºç«åŠ›
            </div>
        </div>
        
        <!-- å…³å¡é€‰æ‹©ç•Œé¢ -->
        <div class="overlay hidden" id="stageSelectScreen">
            <div style="font-size: 40px; margin-bottom: 10px;">ğŸ®</div>
            <div class="game-title" style="font-size: 32px; margin-bottom: 5px;">é€‰æ‹©å…³å¡</div>
            <div style="color: rgba(255,255,255,0.5); font-size: 13px; margin-bottom: 15px;">é€šå…³å‰ä¸€å…³è§£é”ä¸‹ä¸€å…³</div>
            <div id="stageGrid" style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 12px; margin: 15px; max-width: 320px;"></div>
            <button class="btn" onclick="hideStageSelect()" style="background: linear-gradient(135deg, #666 0%, #444 100%); padding: 12px 40px; font-size: 16px; margin-top: 10px;">ğŸ”™ è¿”å›</button>
        </div>
        
        <!-- æ¸¸æˆç»“æŸç•Œé¢ -->
        <div class="overlay hidden" id="gameOverScreen">
            <div class="game-over-title" id="gameOverTitle">ğŸ’” çˆ±æƒ…ç ´ç¢äº†</div>
            <div class="final-score">å¾—åˆ†: <span id="finalScore">0</span></div>
            <div id="stageInfo" style="color: #ff69b4; font-size: 18px; margin: 10px 0;"></div>
            <button class="btn btn-restart" onclick="restartGame()">ğŸ’• å†æ¬¡å®ˆæŠ¤</button>
            <button class="btn" onclick="backToMenu()" style="background: linear-gradient(135deg, #666 0%, #444 100%); box-shadow: 0 10px 30px rgba(0,0,0,0.3);">ğŸ  è¿”å›èœå•</button>
        </div>
        
        <!-- é€šå…³ç•Œé¢ -->
        <div class="overlay hidden" id="winScreen">
            <div class="game-over-title" style="color: #ffd700;">ğŸ‰ æ­å–œé€šå…³! ğŸ‰</div>
            <div class="final-score">æœ€ç»ˆå¾—åˆ†: <span id="winScore">0</span></div>
            <div style="color: #ff69b4; font-size: 20px; margin: 15px 0;">ä½ æˆåŠŸå®ˆæŠ¤äº†çˆ±æƒ…!</div>
            <button class="btn btn-restart" onclick="restartGame()">ğŸ’• å†ç©ä¸€æ¬¡</button>
            <button class="btn" onclick="backToMenu()" style="background: linear-gradient(135deg, #666 0%, #444 100%);">ğŸ  è¿”å›èœå•</button>
        </div>
        
    </div>

    <script>
        // Canvas
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // ä¸ä½¿ç”¨å¤–éƒ¨å›¾ç‰‡ï¼Œå…¨éƒ¨ä½¿ç”¨çŸ¢é‡ç»˜åˆ¶é±¼ç±»
        
        // åŠ è½½èƒŒæ™¯å›¾
        let bgImage = new Image();
        let bgImageReady = false;
        if (typeof BG_IMAGE_BASE64 !== 'undefined') {
            bgImage.onload = function() {
                bgImageReady = true;
            };
            bgImage.src = BG_IMAGE_BASE64;
        }
        
        // æ¸¸æˆé…ç½®
        const CONFIG = {
            CANVAS_WIDTH: window.innerWidth,
            CANVAS_HEIGHT: window.innerHeight,
            PLAYER_SPEED: 8,
            BULLET_SPEED: 12,
            ENEMY_BASE_SPEED: 3,
            STAR_COUNT: 150,
            // === æ–¹æ¡ˆAï¼šé“å…·æŒç»­æ—¶é•¿ï¼ˆå¸§ @60fpsï¼‰===
            POWERUP_DURATION: 480,      // æ­¦å™¨é“å…·æŒç»­8ç§’
            SHIELD_DURATION: 180,       // æŠ¤ç›¾æŒç»­3ç§’
            DRONE_DURATION: 600,        // èªä»”æœºæŒç»­10ç§’
            // === é“å…·æ‰è½ç‡ ===
            POWERUP_DROP_RATE: 0.20,    // 20%æ‰è½å‡ ç‡
            // === å°é±¼å°„é€Ÿ ===
            DRONE_FIRE_COOLDOWN: 14,    // å°é±¼å¼€ç«é—´éš”ï¼ˆå¸§ï¼‰
            
            // === Bosså‡ºç°èŠ‚å¥é…ç½® ===
            // å…³å¡æ¨¡å¼ï¼šè‡³å°‘å‡»è´¥å¤šå°‘æ•Œäººåæ‰å¯å‡ºç°Bossï¼ˆåŸºç¡€+æŒ‰å…³å¡é€’å¢ï¼‰
            STAGE_BOSS_BASE: 24,
            STAGE_BOSS_PER_STAGE: 6,
            // å…³å¡æ¨¡å¼ï¼šæ¯å…³Bossæœ€æ—©å‡ºç°æ—¶é—´ï¼ˆå¸§ï¼Œ60fpsï¼‰
            BOSS_MIN_TIME_STAGE: 30 * 60,   // 30ç§’
            
            // æ— å°½æ¨¡å¼ï¼šé¦–æ¬¡Bossåˆ†æ•°é˜ˆå€¼ä¸åç»­å¢é‡
            ENDLESS_FIRST_BOSS_SCORE: 2200,
            ENDLESS_NEXT_BOSS_ADD: 2500,
            // æ— å°½æ¨¡å¼ï¼šç›¸é‚»ä¸¤æ¬¡Bossä¹‹é—´è‡³å°‘é—´éš”çš„æ—¶é—´ï¼ˆå¸§ï¼‰
            BOSS_MIN_TIME_ENDLESS: 35 * 60   // 35ç§’
        };
        
        // === æ­¦å™¨å†·å´/å‘æ•°/é—´è·é…ç½®ï¼ˆæ–¹æ¡ˆAï¼‰===
        const WEAPON_CONFIG = {
            rapid:  { cd: [10, 8, 6],   desc: 'å¿«é€Ÿå•å‘' },
            double: { cd: [18, 16, 14], offset: [12, 12, 18], extraBullet: [false, true, true], desc: 'åŒ/ä¸‰å‘' },
            triple: { cd: [20, 18, 16], lines: [3, 5, 7], gap: 12, desc: 'å¤šçº¿' },
            spread: { cd: [22, 20, 18], angles: [[-3,0,3], [-3,-1.5,0,1.5,3], [-4,-2.5,-1,0,1,2.5,4]], desc: 'æ‰‡å½¢' },
            laser:  { cd: [12, 10, 8],  width: [6, 10, 14], desc: 'æ¿€å…‰' },
            none:   { cd: [25], desc: 'æ™®é€š' }
        };
        
        // === æ•ŒæœºåŸºç¡€å°„å‡»ç‡ï¼ˆæ¯å¸§æ¦‚ç‡ï¼Œç¬¬ä¸€å…³é€‚åº¦å¼€ç«ï¼‰===
        const ENEMY_SHOOT_BASE = {
            fast: 0.012,
            tank: 0.015,
            sniper: 0.018,
            splitter: 0.010,
            mini: 0.008,
            normal: 0.015
        };
        // æ•Œæœºå°„é€Ÿéšå…³å¡é€’å¢çš„æœ€å¤§å€ç‡
        const ENEMY_SHOOT_MAX_MULT = 3;
        
        // è®¾ç½®canvaså®é™…å°ºå¯¸
        canvas.width = CONFIG.CANVAS_WIDTH;
        canvas.height = CONFIG.CANVAS_HEIGHT;

        // æ¸¸æˆçŠ¶æ€
        let gameState = {
            score: 0,
            wave: 1,
            combo: 0,
            maxCombo: 0,
            isRunning: false,
            isPaused: false,
            powerUpType: 'none',    // å½“å‰é“å…·ç±»å‹
            powerUpTime: 0,         // é“å…·å‰©ä½™æ—¶é—´
            isInvincible: false,    // æ˜¯å¦æ— æ•Œ
            invincibleTime: 0,      // æ— æ•Œå‰©ä½™æ—¶é—´
            powerUpLevel: 0,        // æ­¦å™¨é“å…·ç­‰çº§ï¼ˆ0-3ï¼‰
            droneActive: false,      // èªä»”æœºæ˜¯å¦æ¿€æ´»
            droneTime: 0,            // èªä»”æœºå‰©ä½™æ—¶é—´
            nextBossScore: CONFIG.ENDLESS_FIRST_BOSS_SCORE,
            bossActive: false,
            gameMode: 'endless',
            currentStage: 1,
            maxStage: 20,
            endlessBossCount: 0,
            stageEnemyCount: 0,
            stageBossSpawned: false,
            elapsedFrames: 0,
            lastBossEndFrame: -99999
        };

        // æ¸¸æˆå¯¹è±¡
        let player, bullets, enemies, powerUps, explosions, stars, drones;

        // æŒ‰é”®çŠ¶æ€
        const keys = {};

        // åˆå§‹åŒ–æ°”æ³¡èƒŒæ™¯ï¼ˆæµ·åº•é£æ ¼ï¼‰
        function initStars() {
            stars = [];
            for (let i = 0; i < CONFIG.STAR_COUNT; i++) {
                stars.push({
                    x: Math.random() * CONFIG.CANVAS_WIDTH,
                    y: Math.random() * CONFIG.CANVAS_HEIGHT,
                    size: Math.random() * 4 + 2,
                    speed: Math.random() * 1.5 + 0.5,
                    brightness: Math.random(),
                    wobble: Math.random() * Math.PI * 2
                });
            }
        }

        // åˆå§‹åŒ–ç©å®¶
        function initPlayer() {
            player = {
                x: CONFIG.CANVAS_WIDTH / 2,
                y: CONFIG.CANVAS_HEIGHT - 80,
                width: 50,
                height: 50,
                speed: CONFIG.PLAYER_SPEED,
                shootCooldown: 0,
                invincible: 0,
                trail: []
            };
        }

        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame(mode = 'endless') {
            gameState = {
                score: 0,
                wave: 1,
                combo: 0,
                maxCombo: 0,
                isRunning: false,
                isPaused: false,
                powerUpType: 'none',
                powerUpTime: 0,
                isInvincible: false,
                invincibleTime: 0,
                powerUpLevel: 0,
                droneActive: false,
                droneTime: 0,
                nextBossScore: CONFIG.ENDLESS_FIRST_BOSS_SCORE,
                bossActive: false,
                gameMode: mode,
                currentStage: 1,
                maxStage: 20,
                stageEnemyCount: 0,
                stageBossSpawned: false,
                elapsedFrames: 0,
                lastBossEndFrame: -99999
            };
            
            initStars();
            initPlayer();
            bullets = [];
            enemies = [];
            powerUps = [];
            explosions = [];
            drones = [];
            
            updateUI();
        }

        // å¼€å§‹æ¸¸æˆ
        function startGame(mode = 'endless') {
            document.getElementById('startScreen').classList.add('hidden');
            stopHomepageAnimation(); // åœæ­¢é¦–é¡µåŠ¨ç”»
            initGame(mode);
            gameState.isRunning = true;
            
            if (mode === 'stage') {
                showStage();
            } else {
                showWave();
            }
            gameLoop();
        }

        // é‡æ–°å¼€å§‹
        function restartGame() {
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('winScreen').classList.add('hidden');
            
            if (gameState.gameMode === 'stage') {
                // ä»å¤±è´¥çš„å…³å¡ç»§ç»­
                const resume = parseInt(localStorage.getItem('resumeStage') || `${gameState.currentStage || 1}`);
                initGame('stage');
                gameState.currentStage = Math.max(1, Math.min(resume, gameState.maxStage));
                gameState.isRunning = true;
                showStage();
                gameLoop();
            } else {
                startGame('endless');
            }
        }
        
        // è¿”å›èœå•
        function backToMenu() {
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('winScreen').classList.add('hidden');
            document.getElementById('startScreen').classList.remove('hidden');
            initHomepageAnimation(); // é‡æ–°å¯åŠ¨é¦–é¡µåŠ¨ç”»
        }
        
        // æ˜¾ç¤ºå…³å¡
        function showStage() {
            const waveDisplay = document.getElementById('waveDisplay');
            waveDisplay.textContent = `ç¬¬ ${gameState.currentStage} å…³`;
            waveDisplay.classList.remove('show');
            void waveDisplay.offsetWidth;
            waveDisplay.classList.add('show');
        }
        
        // è·å–å·²è§£é”å…³å¡
        function getUnlockedStage() {
            return parseInt(localStorage.getItem('unlockedStage') || '1');
        }
        
        // ä¿å­˜è§£é”å…³å¡
        function saveUnlockedStage(stage) {
            const current = getUnlockedStage();
            if (stage > current) {
                localStorage.setItem('unlockedStage', stage.toString());
            }
        }
        
        // è·å–å…³å¡æœ€é«˜åˆ†
        function getStageHighScore(stage) {
            const scores = JSON.parse(localStorage.getItem('stageHighScores') || '{}');
            return scores[stage] || 0;
        }
        
        // ä¿å­˜å…³å¡åˆ†æ•°ï¼ˆåªä¿å­˜æ›´é«˜åˆ†ï¼‰
        function saveStageScore(stage, score) {
            const scores = JSON.parse(localStorage.getItem('stageHighScores') || '{}');
            if (!scores[stage] || score > scores[stage]) {
                scores[stage] = score;
                localStorage.setItem('stageHighScores', JSON.stringify(scores));
                return true; // æ–°çºªå½•
            }
            return false;
        }
        
        // è·å–æ— å°½æ¨¡å¼æœ€é«˜åˆ†
        function getEndlessHighScore() {
            return parseInt(localStorage.getItem('endlessHighScore') || '0');
        }
        
        // ä¿å­˜æ— å°½æ¨¡å¼åˆ†æ•°
        function saveEndlessScore(score) {
            const current = getEndlessHighScore();
            if (score > current) {
                localStorage.setItem('endlessHighScore', score.toString());
                return true;
            }
            return false;
        }
        
        // æ˜¾ç¤ºå…³å¡é€‰æ‹©ç•Œé¢
        function showStageSelect() {
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('stageSelectScreen').classList.remove('hidden');
            
            const unlockedStage = getUnlockedStage();
            const grid = document.getElementById('stageGrid');
            grid.innerHTML = '';
            
            for (let i = 1; i <= 20; i++) {
                const btn = document.createElement('button');
                const isUnlocked = i <= unlockedStage;
                const highScore = getStageHighScore(i);
                
                // æ˜¾ç¤ºå…³å¡å·å’Œæœ€é«˜åˆ†
                if (isUnlocked) {
                    btn.innerHTML = highScore > 0 
                        ? `<div style="font-size:16px;line-height:1.1">${i}</div><div style="font-size:9px;color:#ffd700">${highScore}</div>` 
                        : `<div style="font-size:20px">${i}</div>`;
                } else {
                    btn.innerHTML = 'ğŸ”’';
                }
                
                btn.style.cssText = `
                    width: 56px; height: 56px; border-radius: 12px; border: 2px solid ${isUnlocked ? '#ffd700' : '#555'};
                    background: ${isUnlocked ? 'linear-gradient(135deg, #ff69b4 0%, #ff1493 100%)' : 'linear-gradient(135deg, #444 0%, #333 100%)'};
                    color: ${isUnlocked ? 'white' : '#666'}; font-weight: bold;
                    cursor: ${isUnlocked ? 'pointer' : 'not-allowed'}; transition: all 0.2s;
                    box-shadow: ${isUnlocked ? '0 4px 15px rgba(255,105,180,0.4)' : 'none'};
                    display: flex; flex-direction: column; justify-content: center; align-items: center;
                    padding: 2px;
                `;
                
                if (isUnlocked) {
                    btn.onclick = () => startStage(i);
                    btn.onmouseenter = () => btn.style.transform = 'scale(1.1)';
                    btn.onmouseleave = () => btn.style.transform = 'scale(1)';
                }
                
                grid.appendChild(btn);
            }
        }
        
        // éšè—å…³å¡é€‰æ‹©
        function hideStageSelect() {
            document.getElementById('stageSelectScreen').classList.add('hidden');
            document.getElementById('startScreen').classList.remove('hidden');
        }
        
        // å¼€å§‹æŒ‡å®šå…³å¡
        function startStage(stageNum) {
            document.getElementById('stageSelectScreen').classList.add('hidden');
            stopHomepageAnimation(); // åœæ­¢é¦–é¡µåŠ¨ç”»
            initGame('stage');
            gameState.currentStage = stageNum;
            gameState.isRunning = true;
            gameState.elapsedFrames = 0; // æ–°å…³å¡è®¡æ—¶å½’é›¶
            gameState.lastBossEndFrame = -99999;
            showStage();
            gameLoop();
        }

        // æ˜¾ç¤ºæ³¢æ¬¡
        function showWave() {
            const waveDisplay = document.getElementById('waveDisplay');
            waveDisplay.textContent = `WAVE ${gameState.wave}`;
            waveDisplay.classList.remove('show');
            void waveDisplay.offsetWidth;
            waveDisplay.classList.add('show');
        }

        // æ›´æ–°UI
        function updateUI() {
            document.getElementById('scoreDisplay').textContent = gameState.score;
            
            // æ›´æ–°é“å…·çŠ¶æ€æ˜¾ç¤º
            updatePowerupStatus();
        }
        
        // æ›´æ–°é“å…·çŠ¶æ€å›¾æ ‡
        function updatePowerupStatus() {
            const container = document.getElementById('powerupStatus');
            let html = '';
            
            // æ­¦å™¨é“å…·
            if (gameState.powerUpType !== 'none' && gameState.powerUpTime > 0) {
                const icons = { rapid: 'âš¡', double: 'â‡ï¸', triple: 'ğŸ”±', spread: 'ğŸŒŸ', laser: 'ğŸ’' };
                const icon = icons[gameState.powerUpType] || 'âœ¨';
                const percent = (gameState.powerUpTime / CONFIG.POWERUP_DURATION) * 100;
                html += `<div class="powerup-icon" style="border-color: #ffd700;">
                    ${icon}
                    <div class="timer-bar" style="width: ${percent}%;"></div>
                </div>`;
            }
            
            // æŠ¤ç›¾
            if (gameState.isInvincible && gameState.invincibleTime > 0) {
                const percent = (gameState.invincibleTime / CONFIG.SHIELD_DURATION) * 100;
                html += `<div class="powerup-icon" style="border-color: #64c8ff;">
                    ğŸ›¡ï¸
                    <div class="timer-bar" style="width: ${percent}%; background: #64c8ff;"></div>
                </div>`;
            }
            
            // èªä»”æœº
            if (gameState.droneActive && gameState.droneTime > 0) {
                const percent = (gameState.droneTime / CONFIG.DRONE_DURATION) * 100;
                html += `<div class="powerup-icon" style="border-color: #00e5ff;">
                    ğŸ›°ï¸
                    <div class="timer-bar" style="width: ${percent}%; background: #00e5ff;"></div>
                </div>`;
            }
            
            container.innerHTML = html;
        }

        // ç»˜åˆ¶æ°”æ³¡èƒŒæ™¯ï¼ˆæµ·åº•é£æ ¼ï¼‰
        function drawStars() {
            stars.forEach(star => {
                // æ°”æ³¡å‘ä¸Šæ¼‚æµ®
                star.y -= star.speed;
                star.wobble += 0.02;
                star.x += Math.sin(star.wobble) * 0.3;
                
                if (star.y < -10) {
                    star.y = CONFIG.CANVAS_HEIGHT + 10;
                    star.x = Math.random() * CONFIG.CANVAS_WIDTH;
                }
                
                const alpha = 0.2 + star.brightness * 0.3;
                // æ°”æ³¡æ•ˆæœ
                ctx.save();
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(200, 230, 255, ${alpha * 0.3})`;
                ctx.fill();
                ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.lineWidth = 1;
                ctx.stroke();
                // æ°”æ³¡é«˜å…‰
                ctx.beginPath();
                ctx.arc(star.x - star.size * 0.3, star.y - star.size * 0.3, star.size * 0.25, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;
                ctx.fill();
                ctx.restore();
            });
        }

        // ç»˜åˆ¶ç©å®¶é±¼ï¼ˆçŸ¢é‡ç»˜åˆ¶ - ç¾åŒ–ç‰ˆï¼‰
        let playerAnimTime = 0;
        function drawPlayer() {
            if (player.invincible > 0 && Math.floor(player.invincible / 5) % 2 === 0) {
                return;
            }
            
            // åŠ¨ç”»è®¡æ—¶
            playerAnimTime += 0.12;
            const swimWave = Math.sin(playerAnimTime) * 0.08; // æ‘†å°¾
            const breathe = 1 + Math.sin(playerAnimTime * 0.6) * 0.025; // å‘¼å¸
            const finWave = Math.sin(playerAnimTime * 1.8) * 0.25; // é³æ‘†åŠ¨
            
            // æ ¹æ®æ­¦å™¨ç­‰çº§ç¡®å®šç¼©æ”¾/å‘å…‰
            const lvl = gameState.powerUpLevel || 0;
            const type = gameState.powerUpType;
            const LEVEL_STYLES = [
                { glow: null, scale: 1 },
                { glow: '#00ffcc', scale: 1.05 },
                { glow: '#ff69b4', scale: 1.1 },
                { glow: '#ffd700', scale: 1.15 }
            ];
            const style = (type !== 'none' && lvl >= 1) ? LEVEL_STYLES[Math.min(lvl, 3)] : LEVEL_STYLES[0];
            const sc = style.scale * 0.75; // ç¼©å°ç©å®¶é±¼ä½“å‹

            // æ°”æ³¡å°¾è¿¹
            player.trail.push({ x: player.x, y: player.y + 22 * sc, alpha: 1 });
            if (player.trail.length > 10) player.trail.shift();
            player.trail.forEach((t, i) => {
                const alpha = (i / player.trail.length) * 0.5;
                const size = 2 + (i / player.trail.length) * 6;
                ctx.beginPath();
                ctx.arc(t.x + (Math.random() - 0.5) * 5, t.y + (Math.random() - 0.5) * 3, size * sc, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 200, 230, ${alpha})`;
                ctx.fill();
            });

            // ç»˜åˆ¶ç©å®¶é±¼
            ctx.save();
            ctx.translate(player.x, player.y);
            
            // å¤–å±‚å…‰æ™•
            ctx.shadowColor = '#ff69b4';
            ctx.shadowBlur = 15;
            
            // é±¼èº«ä¸»ä½“æ¸å˜ï¼ˆç²‰è‰²å°é±¼ï¼‰
            const bodyGrad = ctx.createRadialGradient(0, -8 * sc, 0, 0, 0, 28 * sc);
            bodyGrad.addColorStop(0, '#ffb6d9');
            bodyGrad.addColorStop(0.3, '#ff69b4');
            bodyGrad.addColorStop(0.7, '#ff1493');
            bodyGrad.addColorStop(1, '#c71585');
            
            // é±¼å°¾ï¼ˆå¸¦æ‘†åŠ¨ï¼‰
            ctx.save();
            ctx.rotate(swimWave);
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.moveTo(0, 20 * sc);
            ctx.quadraticCurveTo(-10 * sc, 28 * sc, -15 * sc, 40 * sc);
            ctx.quadraticCurveTo(0, 34 * sc, 15 * sc, 40 * sc);
            ctx.quadraticCurveTo(10 * sc, 28 * sc, 0, 20 * sc);
            ctx.fill();
            ctx.restore();
            
            // é±¼èº«æ¤­åœ†ï¼ˆå¸¦å‘¼å¸ï¼‰
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.ellipse(0, 0, 18 * sc * breathe, 26 * sc, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // è…¹éƒ¨é«˜å…‰
            ctx.fillStyle = 'rgba(255,220,240,0.5)';
            ctx.beginPath();
            ctx.ellipse(3 * sc, 8 * sc, 10 * sc, 14 * sc, 0.15, 0, Math.PI * 2);
            ctx.fill();
            
            // ä¾§é³ï¼ˆå¸¦æ‘†åŠ¨ï¼‰
            ctx.fillStyle = bodyGrad;
            // å·¦ä¾§é³
            ctx.save();
            ctx.translate(-16 * sc, 3 * sc);
            ctx.rotate(-0.4 + finWave);
            ctx.beginPath();
            ctx.ellipse(0, 0, 14 * sc, 5 * sc, -0.6, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            // å³ä¾§é³
            ctx.save();
            ctx.translate(16 * sc, 3 * sc);
            ctx.rotate(0.4 - finWave);
            ctx.beginPath();
            ctx.ellipse(0, 0, 14 * sc, 5 * sc, 0.6, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            // å°ä¸‘é±¼æ¡çº¹ï¼ˆç™½è‰²ï¼‰
            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            ctx.beginPath();
            ctx.ellipse(-6 * sc, -2 * sc, 2.5 * sc, 18 * sc, -0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(6 * sc, -2 * sc, 2.5 * sc, 18 * sc, 0.1, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.shadowBlur = 0;
            
            // çœ¼ç›å¤–æ¡†
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.ellipse(-7 * sc, -10 * sc, 7 * sc, 6 * sc, 0, 0, Math.PI * 2);
            ctx.ellipse(7 * sc, -10 * sc, 7 * sc, 6 * sc, 0, 0, Math.PI * 2);
            ctx.fill();
            // çœ¼çƒ
            ctx.fillStyle = '#1a1a2e';
            ctx.beginPath();
            ctx.arc(-7 * sc, -9 * sc, 3.5 * sc, 0, Math.PI * 2);
            ctx.arc(7 * sc, -9 * sc, 3.5 * sc, 0, Math.PI * 2);
            ctx.fill();
            // çœ¼ç›é«˜å…‰
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-8.5 * sc, -11 * sc, 2 * sc, 0, Math.PI * 2);
            ctx.arc(5.5 * sc, -11 * sc, 2 * sc, 0, Math.PI * 2);
            ctx.fill();
            // ç¬¬äºŒå±‚é«˜å…‰
            ctx.beginPath();
            ctx.arc(-5.5 * sc, -8 * sc, 1 * sc, 0, Math.PI * 2);
            ctx.arc(8.5 * sc, -8 * sc, 1 * sc, 0, Math.PI * 2);
            ctx.fill();
            
            // å˜´å·´ï¼ˆå¾®ç¬‘ï¼‰
            ctx.strokeStyle = '#c71585';
            ctx.lineWidth = 2 * sc;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.arc(0, -16 * sc, 4 * sc, 0.15 * Math.PI, 0.85 * Math.PI);
            ctx.stroke();
            
            // è„¸é¢šçº¢æ™•
            ctx.fillStyle = 'rgba(255,100,150,0.3)';
            ctx.beginPath();
            ctx.ellipse(-14 * sc, -6 * sc, 4 * sc, 2.5 * sc, 0, 0, Math.PI * 2);
            ctx.ellipse(14 * sc, -6 * sc, 4 * sc, 2.5 * sc, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // é³ç‰‡çº¹ç†
            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.lineWidth = 0.8 * sc;
            for (let i = 0; i < 4; i++) {
                ctx.beginPath();
                ctx.arc(0, (2 + i * 5) * sc, (12 - i * 2) * sc, 0.65 * Math.PI, 0.35 * Math.PI, true);
                ctx.stroke();
            }
            
            ctx.restore();

            // å‡çº§å‘å…‰è½®å»“
            if (style.glow) {
                ctx.save();
                ctx.shadowColor = style.glow;
                ctx.shadowBlur = 20 + lvl * 5;
                ctx.strokeStyle = style.glow;
                ctx.lineWidth = 2.5 + lvl * 0.5;
                ctx.beginPath();
                ctx.arc(player.x, player.y, 35 * sc, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }

            // æ— æ•ŒæŠ¤ç›¾ï¼ˆæ°”æ³¡ç›¾ï¼‰
            if (gameState.isInvincible) {
                ctx.save();
                const shieldGlow = ctx.createRadialGradient(player.x, player.y, 28, player.x, player.y, 50);
                shieldGlow.addColorStop(0, 'rgba(100, 200, 255, 0)');
                shieldGlow.addColorStop(0.5, 'rgba(100, 200, 255, 0.35)');
                shieldGlow.addColorStop(1, 'rgba(100, 200, 255, 0)');
                ctx.fillStyle = shieldGlow;
                ctx.beginPath();
                ctx.arc(player.x, player.y, 50, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#64c8ff';
                ctx.lineWidth = 2.5;
                ctx.shadowColor = '#64c8ff';
                ctx.shadowBlur = 18;
                ctx.beginPath();
                ctx.arc(player.x, player.y, 42, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }
        }

        // ç»˜åˆ¶å­å¼¹ï¼ˆæ°´æ³¡å½¢çŠ¶ï¼‰
        function drawBullets() {
            bullets.forEach(bullet => {
                ctx.save();
                ctx.translate(bullet.x, bullet.y);
                
                if (bullet.type === 'player') {
                    if (bullet.isLaser) {
                        // æ°´æŸ±æ”»å‡»
                        const w = bullet.laserWidth || 8;
                        const grad = ctx.createLinearGradient(0, -30, 0, 10);
                        grad.addColorStop(0, 'rgba(100,200,255,0.9)');
                        grad.addColorStop(1, 'rgba(50,150,255,0.7)');
                        ctx.fillStyle = grad;
                        ctx.fillRect(-w/2, -30, w, 30);
                    } else {
                        // æ°´æ³¡å­å¼¹
                        const r = 8;
                        ctx.beginPath();
                        ctx.arc(0, 0, r, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(100, 200, 255, 0.6)';
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(200, 240, 255, 0.9)';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        // é«˜å…‰
                        ctx.beginPath();
                        ctx.arc(-2, -2, r * 0.3, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.fill();
                    }
                } else {
                    // æ•Œäººå­å¼¹ - çº¢è‰²æ°´æ³¡
                    const r = 6;
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 100, 100, 0.7)';
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 150, 150, 0.9)';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                    // é«˜å…‰
                    ctx.beginPath();
                    ctx.arc(-1.5, -1.5, r * 0.25, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.fill();
                }
                
                ctx.shadowBlur = 0;
                ctx.restore();
            });
        }

        // ç»˜åˆ¶å°é±¼åŠ©æ‰‹
        function drawDrones() {
            if (!gameState.droneActive || !drones.length) return;
            drones.forEach(d => {
                const x = player.x + d.offsetX;
                const y = player.y + d.offsetY;
                ctx.save();
                
                // å°é±¼åŠ©æ‰‹ï¼ˆçŸ¢é‡ç»˜åˆ¶ï¼‰
                d.t = (d.t || 0) + 0.1;
                const floatY = Math.sin(d.t) * 3;
                ctx.translate(x, y + floatY);
                
                const sc = 0.7;
                // é±¼èº«ï¼ˆè“è‰²å°é±¼ï¼‰
                const bodyGrad = ctx.createLinearGradient(0, -15 * sc, 0, 15 * sc);
                bodyGrad.addColorStop(0, '#4fc3f7');
                bodyGrad.addColorStop(0.5, '#03a9f4');
                bodyGrad.addColorStop(1, '#0288d1');
                ctx.fillStyle = bodyGrad;
                ctx.beginPath();
                ctx.ellipse(0, 0, 14 * sc, 20 * sc, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // é±¼å°¾
                ctx.beginPath();
                ctx.moveTo(0, 16 * sc);
                ctx.lineTo(-9 * sc, 26 * sc);
                ctx.lineTo(0, 20 * sc);
                ctx.lineTo(9 * sc, 26 * sc);
                ctx.closePath();
                ctx.fill();
                
                // èƒŒé³•
                ctx.beginPath();
                ctx.moveTo(0, -18 * sc);
                ctx.lineTo(-6 * sc, -24 * sc);
                ctx.lineTo(6 * sc, -24 * sc);
                ctx.closePath();
                ctx.fill();
                
                // ä¾§é³•
                ctx.beginPath();
                ctx.moveTo(-12 * sc, 0);
                ctx.lineTo(-20 * sc, 5 * sc);
                ctx.lineTo(-12 * sc, 3 * sc);
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(12 * sc, 0);
                ctx.lineTo(20 * sc, 5 * sc);
                ctx.lineTo(12 * sc, 3 * sc);
                ctx.closePath();
                ctx.fill();
                
                // çœ¼ç›
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(-5 * sc, -7 * sc, 4 * sc, 0, Math.PI * 2);
                ctx.arc(5 * sc, -7 * sc, 4 * sc, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#222';
                ctx.beginPath();
                ctx.arc(-5 * sc, -7 * sc, 2 * sc, 0, Math.PI * 2);
                ctx.arc(5 * sc, -7 * sc, 2 * sc, 0, Math.PI * 2);
                ctx.fill();
                
                // â€œèªä»”â€æ–‡å­—
                ctx.fillStyle = '#fff';
                ctx.font = `bold ${8 * sc}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('èªä»”', 0, 3 * sc);
                
                ctx.restore();
            });
        }

        // ç»˜åˆ¶æ•Œäººé±¼ï¼ˆçŸ¢é‡ç»˜åˆ¶ - ç¾åŒ–ç‰ˆï¼‰
        function drawEnemySmall(enemy) {
            const s = Math.max(0.9, (enemy.width || 40) / 40);
            const colors = enemy.colors || ['#70a1ff', '#1e90ff', '#3742fa'];
            const isHit = enemy.hitFlash && enemy.hitFlash > 0;
            
            // åŠ¨ç”»è®¡æ—¶å™¨
            enemy.animTime = (enemy.animTime || Math.random() * 100) + 0.15;
            const swimWave = Math.sin(enemy.animTime) * 0.1; // æ‘†å°¾åŠ¨ç”»
            const breathe = 1 + Math.sin(enemy.animTime * 0.5) * 0.03; // å‘¼å¸æ•ˆæœ
            
            ctx.shadowColor = colors[0];
            ctx.shadowBlur = 10;
            
            // é±¼èº«ä¸»è‰²æ¸å˜
            const bodyGrad = ctx.createRadialGradient(0, -5 * s, 0, 0, 0, 22 * s);
            if (isHit) {
                bodyGrad.addColorStop(0, '#ffffff');
                bodyGrad.addColorStop(0.5, '#ffeeee');
                bodyGrad.addColorStop(1, '#ffcccc');
            } else {
                bodyGrad.addColorStop(0, colors[0]);
                bodyGrad.addColorStop(0.4, colors[1]);
                bodyGrad.addColorStop(1, colors[2]);
            }
            
            // é±¼å°¾ï¼ˆå¸¦æ‘†åŠ¨ï¼‰
            ctx.save();
            ctx.rotate(swimWave);
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.moveTo(0, 16 * s);
            ctx.quadraticCurveTo(-8 * s, 22 * s, -12 * s, 30 * s);
            ctx.quadraticCurveTo(0, 26 * s, 12 * s, 30 * s);
            ctx.quadraticCurveTo(8 * s, 22 * s, 0, 16 * s);
            ctx.fill();
            ctx.restore();
            
            // é±¼èº«ï¼ˆå¸¦å‘¼å¸ï¼‰
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.ellipse(0, 0, 14 * s * breathe, 20 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // è…¹éƒ¨é«˜å…‰
            ctx.fillStyle = isHit ? 'rgba(255,255,255,0.8)' : 'rgba(255,255,255,0.35)';
            ctx.beginPath();
            ctx.ellipse(2 * s, 5 * s, 8 * s, 12 * s, 0.2, 0, Math.PI * 2);
            ctx.fill();
            
            // ä¾§é³ï¼ˆå¸¦æ‘†åŠ¨ï¼‰
            const finWave = Math.sin(enemy.animTime * 1.5) * 0.2;
            ctx.save();
            ctx.fillStyle = bodyGrad;
            // å·¦ä¾§é³
            ctx.save();
            ctx.translate(-12 * s, 2 * s);
            ctx.rotate(-0.3 + finWave);
            ctx.beginPath();
            ctx.ellipse(0, 0, 10 * s, 4 * s, -0.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            // å³ä¾§é³
            ctx.save();
            ctx.translate(12 * s, 2 * s);
            ctx.rotate(0.3 - finWave);
            ctx.beginPath();
            ctx.ellipse(0, 0, 10 * s, 4 * s, 0.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            ctx.restore();
            
            // çœ¼ç›å¤–æ¡†
            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 0;
            ctx.beginPath();
            ctx.ellipse(-5 * s, -8 * s, 5 * s, 4.5 * s, 0, 0, Math.PI * 2);
            ctx.ellipse(5 * s, -8 * s, 5 * s, 4.5 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            // çœ¼çƒ
            ctx.fillStyle = '#1a1a2e';
            ctx.beginPath();
            ctx.arc(-5 * s, -7.5 * s, 2.5 * s, 0, Math.PI * 2);
            ctx.arc(5 * s, -7.5 * s, 2.5 * s, 0, Math.PI * 2);
            ctx.fill();
            // çœ¼ç›é«˜å…‰
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-6 * s, -9 * s, 1.2 * s, 0, Math.PI * 2);
            ctx.arc(4 * s, -9 * s, 1.2 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // å˜´å·´
            ctx.strokeStyle = isHit ? '#faa' : colors[2];
            ctx.lineWidth = 1.5 * s;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.arc(0, -14 * s, 3 * s, 0.2 * Math.PI, 0.8 * Math.PI);
            ctx.stroke();
            
            // é³ç‰‡çº¹ç†ï¼ˆå¾®å¦™ï¼‰
            ctx.strokeStyle = `rgba(255,255,255,${isHit ? 0.4 : 0.15})`;
            ctx.lineWidth = 0.5 * s;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.arc(0, (-2 + i * 6) * s, (10 - i * 2) * s, 0.7 * Math.PI, 0.3 * Math.PI, true);
                ctx.stroke();
            }
        }

        // ç»˜åˆ¶BOSSï¼ˆå¤§å‹é±¼ç±»ï¼‰- å¤´æœä¸‹ç»˜åˆ¶
        function drawBossLarge(enemy) {
            const cfg = enemy.bossConfig || { shape: 'shark', colors: ['#ff4757', '#c0392b', '#8e0000'] };
            const colors = cfg.colors || enemy.colors || ['#ff4757', '#c0392b', '#8e0000'];
            const s = (enemy.width || 100) / 80;
            const isHit = enemy.hitFlash && enemy.hitFlash > 0;
            
            ctx.shadowColor = colors[0];
            ctx.shadowBlur = 15;
            
            // Bossé±¼èº«ä¸»è‰²
            const bodyGrad = ctx.createLinearGradient(0, -50 * s, 0, 50 * s);
            if (isHit) {
                bodyGrad.addColorStop(0, '#ffffff');
                bodyGrad.addColorStop(0.5, '#ffdddd');
                bodyGrad.addColorStop(1, '#ffffff');
            } else {
                bodyGrad.addColorStop(0, colors[0]);
                bodyGrad.addColorStop(0.5, colors[1]);
                bodyGrad.addColorStop(1, colors[2]);
            }
            
            // å¤§é±¼èº«ä½“
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.ellipse(0, 0, 35 * s, 50 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // é±¼å°¾ï¼ˆåœ¨ä¸Šæ–¹ï¼Œyè´Ÿæ–¹å‘ï¼‰
            ctx.beginPath();
            ctx.moveTo(0, -40 * s);
            ctx.lineTo(-25 * s, -70 * s);
            ctx.lineTo(0, -55 * s);
            ctx.lineTo(25 * s, -70 * s);
            ctx.closePath();
            ctx.fill();
            
            // èƒŒé³ï¼ˆé±¼å¤´æœä¸‹æ—¶ä¸æ˜¾ç¤ºï¼Œå› ä¸ºèƒŒé³åœ¨èƒŒéƒ¨ï¼‰
            
            // ä¾§é³ï¼ˆå·¦å³ï¼‰
            ctx.beginPath();
            ctx.moveTo(-30 * s, 0);
            ctx.lineTo(-55 * s, -10 * s);
            ctx.lineTo(-30 * s, -5 * s);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(30 * s, 0);
            ctx.lineTo(55 * s, -10 * s);
            ctx.lineTo(30 * s, -5 * s);
            ctx.closePath();
            ctx.fill();
            
            // è…¹éƒ¨ç™½è‰²ï¼ˆåœ¨ä¸‹æ–¹ï¼‰
            ctx.fillStyle = isHit ? '#fff' : 'rgba(255,255,255,0.4)';
            ctx.beginPath();
            ctx.ellipse(0, 15 * s, 25 * s, 28 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // å¤§çœ¼ç›ï¼ˆåœ¨ä¸‹æ–¹ï¼Œæœå‘ç©å®¶ï¼‰
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-15 * s, 25 * s, 12 * s, 0, Math.PI * 2);
            ctx.arc(15 * s, 25 * s, 12 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#880000';
            ctx.beginPath();
            ctx.arc(-15 * s, 25 * s, 6 * s, 0, Math.PI * 2);
            ctx.arc(15 * s, 25 * s, 6 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-13 * s, 23 * s, 3 * s, 0, Math.PI * 2);
            ctx.arc(17 * s, 23 * s, 3 * s, 0, Math.PI * 2);
            ctx.fill();
            
            // å˜´å·´ï¼ˆåœ¨æœ€ä¸‹æ–¹ï¼‰
            ctx.strokeStyle = isHit ? '#faa' : colors[2];
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 40 * s, 10 * s, 1.2 * Math.PI, 1.8 * Math.PI);
            ctx.stroke();
            
            ctx.shadowBlur = 0;
        }

        // === Bosså‘½ä¸­è·¯å¾„ï¼ˆç®€åŒ–ä¸ºæ¤­åœ†å½¢ï¼‰===
        function buildBossHitPath(enemy) {
            const s = (enemy.width || 100) / 80;
            const p = new Path2D();
            // ç®€åŒ–ä¸ºæ¤­åœ†å½¢é±¼èº«
            p.ellipse(0, 0, 35 * s, 50 * s, 0, 0, Math.PI * 2);
            return p;
        }

        // ç»˜åˆ¶æ•Œäºº
        function drawEnemies() {
            enemies.forEach(enemy => {
                ctx.save();
                ctx.translate(enemy.x, enemy.y);
                if (enemy.type === 'boss') {
                    // Bossä¸æ—‹è½¬ï¼Œç»˜åˆ¶å‡½æ•°å†…éƒ¨å·²è°ƒæ•´ä¸ºå¤´æœä¸‹
                    drawBossLarge(enemy);
                } else {
                    // æ™®é€šæ•Œäººæ—‹è½¬180åº¦ï¼Œä½¿å¤´æœä¸‹
                    ctx.rotate(Math.PI);
                    drawEnemySmall(enemy);
                }
                if (enemy.hitFlash > 0) enemy.hitFlash--;
                ctx.restore();
            });
        }

        // ç»˜åˆ¶èªä»”æœº
        function drawPowerUps() {
            powerUps.forEach(p => {
                ctx.save();
                ctx.translate(p.x, p.y);
                
                // åŠ¨ç”»è®¡æ—¶
                p.animTime = (p.animTime || 0) + 0.08;
                const pulse = 1 + Math.sin(p.animTime) * 0.1; // å‘¼å¸æ•ˆæœ
                const floatY = Math.sin(p.animTime * 0.8) * 3; // æ¼‚æµ®æ•ˆæœ
                
                ctx.translate(0, floatY);
                ctx.scale(pulse, pulse);
                
                // å¤–å±‚å…‰æ™•
                const outerGlow = ctx.createRadialGradient(0, 0, 15, 0, 0, 40);
                outerGlow.addColorStop(0, p.color + '60');
                outerGlow.addColorStop(0.6, p.color + '20');
                outerGlow.addColorStop(1, 'transparent');
                ctx.fillStyle = outerGlow;
                ctx.beginPath();
                ctx.arc(0, 0, 40, 0, Math.PI * 2);
                ctx.fill();
                
                // å†…å±‚åœ†å½¢èƒŒæ™¯
                const innerGrad = ctx.createRadialGradient(0, -8, 0, 0, 5, 25);
                innerGrad.addColorStop(0, '#ffffff');
                innerGrad.addColorStop(0.3, p.color);
                innerGrad.addColorStop(1, p.color + '88');
                ctx.fillStyle = innerGrad;
                ctx.shadowColor = p.color;
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(0, 0, 22, 0, Math.PI * 2);
                ctx.fill();
                
                // é‡‘è‰²è¾¹æ¡†
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 8;
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                // é“å…·å›¾æ ‡
                ctx.font = 'bold 22px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#fff';
                ctx.fillText(p.icon, 0, 1);
                
                // é—ªå…‰ç‚¹
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                ctx.beginPath();
                ctx.arc(-8, -8, 4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            });
        }

        // ç»˜åˆ¶çˆ†ç‚¸æ•ˆæœ
        function drawExplosions() {
            explosions.forEach((exp, index) => {
                const progress = exp.frame / exp.maxFrame;
                const radius = exp.maxRadius * progress;
                const alpha = 1 - progress;
                
                // å¤šå±‚çˆ†ç‚¸æ•ˆæœ
                for (let i = 3; i >= 0; i--) {
                    const layerRadius = radius * (1 - i * 0.2);
                    const layerAlpha = alpha * (1 - i * 0.2);
                    
                    const gradient = ctx.createRadialGradient(
                        exp.x, exp.y, 0,
                        exp.x, exp.y, layerRadius
                    );
                    gradient.addColorStop(0, `rgba(255, 255, 200, ${layerAlpha})`);
                    gradient.addColorStop(0.3, `rgba(255, 150, 50, ${layerAlpha * 0.8})`);
                    gradient.addColorStop(0.6, `rgba(255, 50, 0, ${layerAlpha * 0.5})`);
                    gradient.addColorStop(1, 'rgba(100, 0, 0, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(exp.x, exp.y, layerRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // ç²’å­æ•ˆæœ
                exp.particles.forEach(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.alpha -= 0.03;
                    
                    if (particle.alpha > 0) {
                        ctx.fillStyle = `rgba(255, ${150 + Math.random() * 100}, 50, ${particle.alpha})`;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                
                exp.frame++;
                if (exp.frame >= exp.maxFrame) {
                    explosions.splice(index, 1);
                }
            });
        }

        // åˆ›å»ºçˆ†ç‚¸
        function createExplosion(x, y, size = 1) {
            const particles = [];
            for (let i = 0; i < 15 * size; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 4 + 2;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: Math.random() * 3 + 1,
                    alpha: 1
                });
            }
            
            explosions.push({
                x: x,
                y: y,
                frame: 0,
                maxFrame: 30,
                maxRadius: 40 * size,
                particles: particles
            });
        }

        // ç©å®¶å°„å‡» - æ”¯æŒæ­¦å™¨é“å…·å‡çº§ï¼ˆæœ€å¤š3çº§ï¼‰ï¼Œä½¿ç”¨WEAPON_CONFIG
        function playerShoot() {
            if (player.shootCooldown > 0) return;
            
            const type = gameState.powerUpType;
            const lvl = Math.max(1, Math.min(3, gameState.powerUpLevel));
            const idx = lvl - 1;
            const speed = CONFIG.BULLET_SPEED;
            const cfg = WEAPON_CONFIG[type] || WEAPON_CONFIG.none;
            let cooldown = cfg.cd[idx] ?? cfg.cd[0];
            
            function shoot(x, y, vx, vy, extra = {}) {
                bullets.push(Object.assign({ x, y, vx, vy, type: 'player' }, extra));
            }
            
            if (type === 'rapid') {
                shoot(player.x, player.y - 25, 0, -speed);
            } else if (type === 'double') {
                const o = cfg.offset[idx];
                shoot(player.x - o, player.y - 20, 0, -speed);
                shoot(player.x + o, player.y - 20, 0, -speed);
                if (cfg.extraBullet[idx]) shoot(player.x, player.y - 25, 0, -speed);
            } else if (type === 'triple') {
                const lines = cfg.lines[idx];
                const gap = cfg.gap;
                const half = (lines - 1) / 2;
                for (let i = 0; i < lines; i++) {
                    shoot(player.x + (i - half) * gap, player.y - 20, 0, -speed);
                }
            } else if (type === 'spread') {
                cfg.angles[idx].forEach(a => shoot(player.x, player.y - 22, a, -speed * 0.95));
            } else if (type === 'laser') {
                const w = cfg.width[idx];
                shoot(player.x, player.y - 25, 0, -speed * 1.6, { isLaser: true, laserWidth: w });
            } else {
                // æ— é“å…·ï¼šæ™®é€šå•å‘
                shoot(player.x, player.y - 25, 0, -speed);
            }
            
            player.shootCooldown = cooldown;
        }

        // ç”Ÿæˆæ•Œäººï¼ˆæŒ‰å…³å¡ä¸»é¢˜æŒ‘é€‰æ•Œæœº+é…è‰²ï¼‰
        function spawnEnemy() {
            let type, hp, speed, shootRate, width, height;
            
            // éš¾åº¦ä¸ä¸»é¢˜
            const stage = gameState.gameMode === 'stage' ? gameState.currentStage : gameState.wave;
            const diffMult = (stage - 1) / 19; // çº¿æ€§é€’å¢
            const theme = STAGE_THEMES[(stage - 1) % STAGE_THEMES.length];
            const pool = theme.types;
            type = pool[Math.floor(Math.random() * pool.length)];
            const defaultByType = { normal:'fighter', fast:'interceptor', tank:'bomber', sniper:'sniperJet', splitter:'splitterJet', mini:'droneJet' };
            const shape = (theme.shapesByType && theme.shapesByType[type]) || defaultByType[type] || 'triangle';
            
            // æŒ‰ç±»å‹è®¾å®šå±æ€§ - å°„é€Ÿå’Œé€Ÿåº¦éšå…³å¡é€’å¢
            const shootMult = 1 + diffMult * ENEMY_SHOOT_MAX_MULT; // ç¬¬1å…³Ã—1, ç¬¬20å…³Ã—11
            // é€Ÿåº¦å€ç‡ï¼šç¬¬1å…³åŸºç¡€é€Ÿåº¦0.4å€ï¼Œç¬¬20å…³è¾¾åˆ°1.0å€
            const speedMult = 0.4 + diffMult * 0.6; // 0.4 ~ 1.0
            switch(type) {
                case 'fast':
                    hp = 1;
                    speed = (1.5 + diffMult * 2.5) * speedMult;
                    shootRate = ENEMY_SHOOT_BASE.fast * shootMult;
                    width = 35; height = 30; break;
                case 'tank':
                    hp = 1 + Math.floor(stage / 4);
                    speed = (1 + diffMult * 1.3) * speedMult;
                    shootRate = ENEMY_SHOOT_BASE.tank * shootMult;
                    width = 50; height = 45; break;
                case 'sniper':
                    hp = 1;
                    speed = (1 + diffMult * 1.4) * speedMult;
                    shootRate = ENEMY_SHOOT_BASE.sniper * shootMult;
                    width = 40; height = 35; break;
                case 'splitter':
                    hp = 1 + Math.floor(stage / 6);
                    speed = (1.2 + diffMult * 1.8) * speedMult;
                    shootRate = ENEMY_SHOOT_BASE.splitter * shootMult;
                    width = 45; height = 40; break;
                case 'mini':
                    hp = 1;
                    speed = (1.8 + diffMult * 2.0) * speedMult;
                    shootRate = ENEMY_SHOOT_BASE.mini * shootMult;
                    width = 25; height = 22; break;
                default: // normal
                    hp = 1 + Math.floor(stage / 8);
                    speed = (1.3 + diffMult * 1.5) * speedMult;
                    shootRate = ENEMY_SHOOT_BASE.normal * shootMult;
                    width = 40; height = 35; break;
            }
            
            enemies.push({
                x: Math.random() * (CONFIG.CANVAS_WIDTH - 60) + 30,
                y: -50,
                width,
                height,
                type,
                hp,
                maxHp: hp,
                speed,
                shootRate,
                movePattern: Math.floor(Math.random() * 4),
                colors: theme.palette,
                shape: shape
            });
        }
        
        // å…³å¡ä¸»é¢˜ï¼šæ¯å…³ä¸åŒæ•Œæœºç»„åˆä¸é…è‰²ï¼ˆ20å…³å¾ªç¯ï¼‰- é¿å…ä½¿ç”¨ç²‰è‰²ï¼ˆç©å®¶é±¼é¢œè‰²ï¼‰
        const STAGE_THEMES = [
            { name: 'æ·±æµ·æš—æµ',  types: ['normal','mini'], palette: ['#5c6bc0','#3949ab','#283593'], shapesByType: {normal:'fighter', mini:'droneJet'} },
            { name: 'æ¹›è“ä¹‹æµ·',  types: ['fast','normal'], palette: ['#74c0ff','#4dabf7','#228be6'], shapesByType: {fast:'interceptor', normal:'fighter'} },
            { name: 'ç¥ç€è’åŸ',  types: ['tank','normal'], palette: ['#ffb74d','#fb8c00','#ef6c00'], shapesByType: {tank:'bomber', normal:'fighter'} },
            { name: 'ç´«æ™¶ç§˜åŸŸ',  types: ['sniper','mini'], palette: ['#b388ff','#7c4dff','#651fff'], shapesByType: {sniper:'sniperJet', mini:'droneJet'} },
            { name: 'ç¿¡ç¿ æ—åœ°',  types: ['splitter','normal'], palette: ['#66e6a8','#2ecc71','#1abc9c'], shapesByType: {splitter:'splitterJet', normal:'fighter'} },
            { name: 'æå¤œæ˜Ÿç©º',  types: ['fast','sniper'], palette: ['#a29bfe','#6c5ce7','#341f97'], shapesByType: {fast:'interceptor', sniper:'sniperJet'} },
            { name: 'ç†”ç«ä¹‹éƒ½',  types: ['tank','splitter'], palette: ['#ff6b6b','#ff3d3d','#c71f1f'], shapesByType: {tank:'bomber', splitter:'splitterJet'} },
            { name: 'é£æš´ç¾¤å²›',  types: ['fast','splitter'], palette: ['#00e5ff','#00b3ff','#0088ff'], shapesByType: {fast:'interceptor', splitter:'splitterJet'} },
            { name: 'é›ªåŸæ™¨å…‰',  types: ['mini','sniper'], palette: ['#e3f2fd','#bbdefb','#90caf9'], shapesByType: {mini:'droneJet', sniper:'sniperJet'} },
            { name: 'æ²™æµ·é—è¿¹',  types: ['tank','sniper'], palette: ['#ffd166','#f8b400','#e09f3e'], shapesByType: {tank:'bomber', sniper:'sniperJet'} },
            { name: 'å¹½å†¥æ·±æ¸Š',  types: ['splitter','mini'], palette: ['#00d1b2','#00a896','#05668d'], shapesByType: {splitter:'splitterJet', mini:'droneJet'} },
            { name: 'é›·éœ†é«˜åŸ',  types: ['fast','tank'], palette: ['#ffd54f','#ffca28','#ffa000'], shapesByType: {fast:'interceptor', tank:'bomber'} },
            { name: 'çŠç‘šç¤å²©',  types: ['normal','sniper'], palette: ['#ff8a65','#ff7043','#f4511e'], shapesByType: {normal:'fighter', sniper:'sniperJet'} },
            { name: 'ç£æš´åŸå¢™',  types: ['splitter','sniper'], palette: ['#8fd3fe','#69bff8','#4098d7'], shapesByType: {splitter:'splitterJet', sniper:'sniperJet'} },
            { name: 'æš®è‰²æµ·æ¹¾',  types: ['mini','normal'], palette: ['#98c1d9','#6ea8d6','#3d5a80'], shapesByType: {mini:'droneJet', normal:'fighter'} },
            { name: 'é»‘æ›œå³¡è°·',  types: ['tank','mini'], palette: ['#95a5a6','#7f8c8d','#566573'], shapesByType: {tank:'bomber', mini:'droneJet'} },
            { name: 'ç–¾é£è’å²­',  types: ['fast','splitter'], palette: ['#a8e6cf','#56c7c2','#2fb7b0'], shapesByType: {fast:'interceptor', splitter:'splitterJet'} },
            { name: 'ç´«ç”µç å¤´',  types: ['fast','sniper','mini'], palette: ['#9575cd','#7e57c2','#5e35b1'], shapesByType: {fast:'interceptor', sniper:'sniperJet', mini:'droneJet'} },
            { name: 'é’é›·ç«¹æµ·',  types: ['tank','normal','splitter'], palette: ['#a7ff83','#17b978','#086972'], shapesByType: {tank:'bomber', normal:'fighter', splitter:'splitterJet'} },
            { name: 'æœˆå…‰å¤©ç©¹',  types: ['normal','fast','sniper'], palette: ['#c5b3ff','#9d7dff','#6b4eff'], shapesByType: {normal:'fighter', fast:'interceptor', sniper:'sniperJet'} }
        ];

        // Bossé…ç½® - 20ç§ç‹¬ç‰¹Boss
        const BOSS_CONFIGS = [
            { name: 'çŠç‘šå®ˆå«', color: '#ff6b9d', shape: 'fighter', bulletPattern: 'spread3' },
            { name: 'ç„æœˆ', color: '#9b59b6', shape: 'crescent', bulletPattern: 'spiral' },
            { name: 'æš—å¤œç„é¸¿', color: '#2c3e50', shape: 'bird', bulletPattern: 'wave' },
            { name: 'çƒˆç„°å‡¤å‡°', color: '#e74c3c', shape: 'phoenix', bulletPattern: 'burst' },
            { name: 'å†°éœœå¥³ç‹', color: '#74b9ff', shape: 'crystal', bulletPattern: 'ring' },
            { name: 'é›·ç”µä¹‹ä¸»', color: '#f39c12', shape: 'thunder', bulletPattern: 'zigzag' },
            { name: 'æ·±æµ·å·¨å…½', color: '#0984e3', shape: 'octopus', bulletPattern: 'tentacle' },
            { name: 'æ¯’åˆºç„è¶', color: '#00b894', shape: 'butterfly', bulletPattern: 'scatter' },
            { name: 'è¡€æœˆé­”å›', color: '#c0392b', shape: 'vampire', bulletPattern: 'cross' },
            { name: 'å¹»å½±é­”å¥³', color: '#8e44ad', shape: 'witch', bulletPattern: 'homing' },
            { name: 'é»„é‡‘å¸é¾™', color: '#f1c40f', shape: 'dragon', bulletPattern: 'breath' },
            { name: 'æ¨±èŠ±ç²¾çµ', color: '#fd79a8', shape: 'sakura', bulletPattern: 'petal' },
            { name: 'æš—å½±åˆƒ', color: '#636e72', shape: 'blade', bulletPattern: 'slash' },
            { name: 'æ˜Ÿç©ºå·¨äºº', color: '#6c5ce7', shape: 'giant', bulletPattern: 'meteor' },
            { name: 'èŠ±å›­å®ˆæŠ¤è€…', color: '#e056fd', shape: 'rose', bulletPattern: 'thorn' },
            { name: 'é£æš´ä¹‹çœ¼', color: '#00cec9', shape: 'eye', bulletPattern: 'tornado' },
            { name: 'åœ°ç‹±ç«ç„°', color: '#d63031', shape: 'demon', bulletPattern: 'inferno' },
            { name: 'å¤©ä½¿ä¹‹ç¿¼', color: '#ffeaa7', shape: 'angel', bulletPattern: 'feather' },
            { name: 'æ··æ²Œä¹‹å¿ƒ', color: '#2d3436', shape: 'chaos', bulletPattern: 'random' },
            { name: 'çˆ±ç¥ä¸˜æ¯”ç‰¹', color: '#ff69b4', shape: 'cupid', bulletPattern: 'heart' }
        ];
        
        // ç”ŸæˆBoss
        function spawnBoss() {
            if (gameState.bossActive) return;
            
            gameState.bossActive = true;
            
            // æ ¹æ®æ¨¡å¼è®¡ç®—Bossç­‰çº§
            let bossLevel;
            if (gameState.gameMode === 'stage') {
                bossLevel = gameState.currentStage;
            } else {
                bossLevel = Math.floor(gameState.nextBossScore / 1000);
                if (bossLevel > 20) bossLevel = ((bossLevel - 1) % 20) + 1;
            }
            
            const bossConfig = BOSS_CONFIGS[(bossLevel - 1) % 20];
            
            // Bosså±æ€§éšå…³å¡é€’å¢ - æé«˜è€ä¹…
            const hp = 150 + bossLevel * 50; // ç¬¬1å…³:200HP, ç¬¬20å…³:1150HP
            const size = 220 + bossLevel * 8; // æ›´å¤§å°ºå¯¸ï¼šç¬¬1å…³â‰ˆ228ï¼Œç¬¬20å…³â‰ˆ380
            
            // æ ¹æ®Bossé€ å‹æ˜ å°„åˆ°é£æœºæ¨¡å‹ï¼ˆä¸ç»˜åˆ¶ä¿æŒä¸€è‡´ï¼‰ï¼Œç”¨äºä¼°ç®—æ›´è´´åˆçš„åˆ¤å®šæ¡†
            const planeByShape = {
                heart: 'aceFighter', cupid: 'aceFighter',
                crescent: 'stealthWing',
                butterfly: 'interceptorX', bird: 'interceptorX', thunder: 'interceptorX', blade: 'interceptorX',
                dragon: 'heavyFighter', phoenix: 'heavyFighter', angel: 'heavyFighter', vampire: 'heavyFighter', demon: 'heavyFighter',
                crystal: 'bomberX', witch: 'bomberX',
                octopus: 'gunship', giant: 'gunship', eye: 'gunship',
                sakura: 'stealthWing', rose: 'stealthWing', chaos: 'stealthWing'
            };
            const model = planeByShape[bossConfig.shape] || 'aceFighter';
            
            // ä¼°ç®—å‘½ä¸­æ¡†æ¯”ä¾‹ï¼ˆç›¸å¯¹äºsizeï¼‰ã€‚è¯´æ˜ï¼šæ­¤å‰ç»˜åˆ¶æ—¶æœºç¿¼å¤–å±•è¿œè¶…widthï¼Œå¯¼è‡´ç¿¼å°–å‘½ä¸­æ— æ•ˆ
            let hitW = size, hitH = size * 0.85;
            switch (model) {
                case 'stealthWing':
                    hitW = size * 1.85; hitH = size * 0.95; break;
                case 'bomberX':
                    hitW = size * 2.20; hitH = size * 1.00; break;
                case 'interceptorX':
                    hitW = size * 1.60; hitH = size * 0.95; break;
                case 'heavyFighter':
                    hitW = size * 1.30; hitH = size * 1.00; break;
                case 'gunship':
                    hitW = size * 2.00; hitH = size * 1.00; break;
                case 'aceFighter':
                default:
                    hitW = size * 1.50; hitH = size * 0.95; break;
            }
            
            const bossObj = {
                x: CONFIG.CANVAS_WIDTH / 2,
                y: -150,
                width: size,
                height: size * 0.85,
                hitW: hitW,
                hitH: hitH,
                type: 'boss',
                hp: hp,
                maxHp: hp,
                speed: 0.8 + bossLevel * 0.04, // ç¬¬1å…³æ…¢ï¼Œç¬¬20å…³å¿«
                shootRate: 0.005 + bossLevel * 0.003, // ç¬¬1å…³å¾ˆå°‘å°„å‡»
                movePattern: 10,
                moveDir: 1,
                bossLevel: bossLevel,
                bossConfig: bossConfig,
                shootTimer: 0,
                animTimer: 0
            };
            enemies.push(bossObj);
            
            // æ˜¾ç¤ºBossè­¦å‘Š
            const waveDisplay = document.getElementById('waveDisplay');
            if (gameState.gameMode === 'stage') {
                waveDisplay.textContent = `âš ï¸ ${bossConfig.name} æ¥è¢­! âš ï¸`;
            } else {
                waveDisplay.textContent = `âš ï¸ ${bossConfig.name} Lv.${bossLevel} âš ï¸`;
            }
            waveDisplay.classList.remove('show');
            void waveDisplay.offsetWidth;
            waveDisplay.classList.add('show');
        }

        // é“å…·ç±»å‹é…ç½®
        const POWERUP_TYPES = [
            { type: 'rapid', icon: 'âš¡', name: 'å¿«é€Ÿå°„å‡»', color: '#f1c40f' },
            { type: 'double', icon: 'â‡ï¸', name: 'åŒå‘', color: '#3498db' },
            { type: 'triple', icon: 'ğŸ”±', name: 'ä¸‰å‘', color: '#9b59b6' },
            { type: 'spread', icon: 'ğŸŒŸ', name: 'æ•£å°„', color: '#e74c3c' },
            { type: 'laser', icon: 'ğŸ’ ', name: 'æ¿€å…‰', color: '#00ff88' },
            { type: 'shield', icon: 'ğŸ›¡ï¸', name: 'æ— æ•ŒæŠ¤ç›¾', color: '#ffd700' },
            { type: 'drone', icon: 'ğŸ›°ï¸', name: 'èªä»”æœº', color: '#00e5ff' }
        ];
        
        // ç”Ÿæˆé“å…·
        function spawnPowerUp(x, y) {
            if (Math.random() < CONFIG.POWERUP_DROP_RATE) {
                const powerType = POWERUP_TYPES[Math.floor(Math.random() * POWERUP_TYPES.length)];
                powerUps.push({
                    x: x,
                    y: y,
                    powerType: powerType.type,
                    icon: powerType.icon,
                    color: powerType.color,
                    speed: 2,
                    rotation: 0
                });
            }
        }

        // æ•Œäººå°„å‡» - å­å¼¹é€Ÿåº¦éšå…³å¡é€’å¢
        function enemyShoot(enemy) {
            // è®¡ç®—å­å¼¹é€Ÿåº¦å€ç‡ï¼šç¬¬1å…³åŸºç¡€é€Ÿåº¦0.4å€ï¼Œç¬¬20å…³è¾¾åˆ°1.0å€
            const stage = gameState.gameMode === 'stage' ? gameState.currentStage : gameState.wave;
            const bulletSpeedMult = 0.4 + (Math.min(stage, 20) - 1) * 0.032; // 0.4 ~ 1.0
            
            if (enemy.type === 'boss' && enemy.bossConfig) {
                // Bossç‰¹æ®Šå¼¹é“
                enemy.shootTimer = (enemy.shootTimer || 0) + 1;
                // Bossè¿›å…¥åå»¶è¿Ÿå¼€ç«ï¼Œä½ç­‰çº§å»¶è¿Ÿæ›´é•¿
                const delay = 180 - (enemy.bossLevel || 1) * 6;
                if (enemy.shootTimer < delay) return;
                
                const pattern = enemy.bossConfig.bulletPattern;
                const cx = enemy.x;
                const cy = enemy.y + ((enemy.hitH || enemy.height) / 2);
                const spd = bulletSpeedMult; // Bosså­å¼¹é€Ÿåº¦å€ç‡
                
                switch(pattern) {
                    case 'spread3': // 3è·¯æ‰©æ•£
                        if (enemy.shootTimer % 30 === 0) {
                            for (let i = -1; i <= 1; i++) {
                                bullets.push({ x: cx + i * 30, y: cy, vx: i * 2 * spd, vy: 6 * spd, type: 'enemy' });
                            }
                        }
                        break;
                    case 'spiral': // èŸ‚æ—‹
                        if (enemy.shootTimer % 10 === 0) {
                            const angle = enemy.shootTimer * 0.15;
                            bullets.push({ x: cx, y: cy, vx: Math.cos(angle) * 4 * spd, vy: (Math.sin(angle) * 2 + 4) * spd, type: 'enemy' });
                        }
                        break;
                    case 'wave': // æ³¢åŠ¨
                        if (enemy.shootTimer % 25 === 0) {
                            for (let i = 0; i < 5; i++) {
                                bullets.push({ x: cx - 80 + i * 40, y: cy, vx: 0, vy: 5 * spd, type: 'enemy', wave: true, waveOffset: i });
                            }
                        }
                        break;
                    case 'burst': // çˆ†è£‚
                        if (enemy.shootTimer % 80 === 0) {
                            for (let i = 0; i < 8; i++) {
                                const a = (i / 8) * Math.PI * 2;
                                bullets.push({ x: cx, y: cy, vx: Math.cos(a) * 4 * spd, vy: (Math.sin(a) * 4 + 2) * spd, type: 'enemy' });
                            }
                        }
                        break;
                    case 'ring': // åœ†ç¯
                        if (enemy.shootTimer % 60 === 0) {
                            for (let i = 0; i < 12; i++) {
                                const a = (i / 12) * Math.PI * 2;
                                bullets.push({ x: cx, y: cy, vx: Math.cos(a) * 3 * spd, vy: (Math.sin(a) * 3 + 1) * spd, type: 'enemy' });
                            }
                        }
                        break;
                    case 'zigzag': // ä¹‹å­—å½¢
                        if (enemy.shootTimer % 20 === 0) {
                            bullets.push({ x: cx, y: cy, vx: Math.sin(enemy.shootTimer * 0.1) * 5 * spd, vy: 5 * spd, type: 'enemy' });
                        }
                        break;
                    case 'tentacle': // è§¦æ‰‹
                        if (enemy.shootTimer % 15 === 0) {
                            const side = (enemy.shootTimer / 15) % 2 === 0 ? -1 : 1;
                            bullets.push({ x: cx + side * 50, y: cy, vx: side * 1 * spd, vy: 5 * spd, type: 'enemy' });
                        }
                        break;
                    case 'scatter': // æ•£å°„
                        if (enemy.shootTimer % 40 === 0) {
                            for (let i = 0; i < 6; i++) {
                                bullets.push({ x: cx + (Math.random() - 0.5) * 100, y: cy, vx: (Math.random() - 0.5) * 4 * spd, vy: (4 + Math.random() * 2) * spd, type: 'enemy' });
                            }
                        }
                        break;
                    case 'cross': // åå­—
                        if (enemy.shootTimer % 50 === 0) {
                            bullets.push({ x: cx, y: cy, vx: 0, vy: 6 * spd, type: 'enemy' });
                            bullets.push({ x: cx, y: cy, vx: 4 * spd, vy: 4 * spd, type: 'enemy' });
                            bullets.push({ x: cx, y: cy, vx: -4 * spd, vy: 4 * spd, type: 'enemy' });
                        }
                        break;
                    case 'homing': // è¿½è¸ª
                        if (enemy.shootTimer % 60 === 0) {
                            const dx = player.x - cx;
                            const dy = player.y - cy;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            bullets.push({ x: cx, y: cy, vx: (dx / dist) * 5 * spd, vy: (dy / dist) * 5 * spd, type: 'enemy' });
                        }
                        break;
                    case 'breath': // é¾™æ¯
                        if (enemy.shootTimer % 5 === 0 && enemy.shootTimer % 100 < 30) {
                            bullets.push({ x: cx + (Math.random() - 0.5) * 60, y: cy, vx: (Math.random() - 0.5) * 2 * spd, vy: 7 * spd, type: 'enemy' });
                        }
                        break;
                    case 'petal': // èŠ±ç“£
                        if (enemy.shootTimer % 45 === 0) {
                            for (let i = 0; i < 5; i++) {
                                const a = (i / 5) * Math.PI * 2 + enemy.shootTimer * 0.02;
                                bullets.push({ x: cx, y: cy, vx: Math.cos(a) * 3 * spd, vy: 4 * spd, type: 'enemy' });
                            }
                        }
                        break;
                    case 'slash': // æ–©å‡» - å¿«é€Ÿä¸‰è¿å‡»
                        if (enemy.shootTimer % 60 < 15 && enemy.shootTimer % 5 === 0) {
                            const offset = (enemy.shootTimer % 60) / 5 - 1;
                            bullets.push({ x: cx + offset * 40, y: cy, vx: offset * 3 * spd, vy: 8 * spd, type: 'enemy' });
                        }
                        break;
                    case 'meteor': // æµæ˜Ÿ - ä»å¤©è€Œé™çš„å¤§å¼¹å¹•
                        if (enemy.shootTimer % 70 === 0) {
                            for (let i = 0; i < 7; i++) {
                                const startX = Math.random() * CONFIG.CANVAS_WIDTH;
                                bullets.push({ x: startX, y: cy - 50, vx: (Math.random() - 0.5) * 2 * spd, vy: (5 + Math.random() * 3) * spd, type: 'enemy' });
                            }
                        }
                        break;
                    case 'thorn': // è†æ£˜ - ä¸¤ä¾§äº¤å‰å°„å‡»
                        if (enemy.shootTimer % 25 === 0) {
                            const side = (enemy.shootTimer / 25) % 2;
                            for (let i = 0; i < 3; i++) {
                                const angle = (side ? 0.3 : -0.3) + (i - 1) * 0.15;
                                bullets.push({ x: cx + (side ? 60 : -60), y: cy, vx: Math.sin(angle) * 4 * spd, vy: Math.cos(angle) * 5 * spd, type: 'enemy' });
                            }
                        }
                        break;
                    case 'tornado': // é¾™å· - æ—‹è½¬æ‰©æ•£
                        if (enemy.shootTimer % 8 === 0) {
                            const a = enemy.shootTimer * 0.2;
                            const r = 30 + (enemy.shootTimer % 80) * 0.5;
                            bullets.push({ x: cx + Math.cos(a) * r, y: cy + Math.sin(a) * r * 0.3, vx: Math.cos(a) * 2 * spd, vy: 5 * spd, type: 'enemy' });
                        }
                        break;
                    case 'inferno': // åœ°ç‹±ç« - å¯†é›†ç«ç„°å¼¹å¹•
                        if (enemy.shootTimer % 4 === 0 && enemy.shootTimer % 120 < 60) {
                            const spread = Math.sin(enemy.shootTimer * 0.1) * 80;
                            bullets.push({ x: cx + spread, y: cy, vx: (Math.random() - 0.5) * 3 * spd, vy: (6 + Math.random() * 2) * spd, type: 'enemy' });
                        }
                        break;
                    case 'feather': // ç¾½æ¯› - é£˜è½å¼å¼¹å¹•
                        if (enemy.shootTimer % 35 === 0) {
                            for (let i = 0; i < 4; i++) {
                                const x = cx - 60 + i * 40;
                                bullets.push({ x: x, y: cy, vx: Math.sin(i + enemy.shootTimer * 0.05) * 2 * spd, vy: 4 * spd, type: 'enemy', wave: true, waveOffset: i * 0.5 });
                            }
                        }
                        break;
                    case 'random': // æ··æ²Œ - éšæœºç»„åˆæ”»å‡»
                        if (enemy.shootTimer % 20 === 0) {
                            const mode = Math.floor(Math.random() * 4);
                            if (mode === 0) { // ç›´çº¿
                                bullets.push({ x: cx, y: cy, vx: 0, vy: 7 * spd, type: 'enemy' });
                            } else if (mode === 1) { // åŒå‘
                                bullets.push({ x: cx - 30, y: cy, vx: -1 * spd, vy: 6 * spd, type: 'enemy' });
                                bullets.push({ x: cx + 30, y: cy, vx: 1 * spd, vy: 6 * spd, type: 'enemy' });
                            } else if (mode === 2) { // è¿½è¸ª
                                const dx = player.x - cx, dy = player.y - cy;
                                const d = Math.sqrt(dx*dx + dy*dy) || 1;
                                bullets.push({ x: cx, y: cy, vx: (dx/d) * 5 * spd, vy: (dy/d) * 5 * spd, type: 'enemy' });
                            } else { // æ•£å°„
                                for (let i = 0; i < 3; i++) {
                                    bullets.push({ x: cx, y: cy, vx: (Math.random() - 0.5) * 6 * spd, vy: (4 + Math.random() * 3) * spd, type: 'enemy' });
                                }
                            }
                        }
                        break;
                    case 'heart': // çˆ±å¿ƒ - å¿ƒå½¢å¼¹å¹•
                        if (enemy.shootTimer % 50 === 0) {
                            // ç»˜åˆ¶å¿ƒå½¢è½®å»“çš„å­å¼¹
                            for (let i = 0; i < 16; i++) {
                                const t = (i / 16) * Math.PI * 2;
                                // å¿ƒå½¢å‚æ•°æ–¹ç¨‹
                                const hx = 16 * Math.pow(Math.sin(t), 3);
                                const hy = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                                bullets.push({ x: cx, y: cy, vx: hx * 0.2 * spd, vy: -hy * 0.2 * spd + 3 * spd, type: 'enemy' });
                            }
                        }
                        break;
                    default: // é»˜è®¤
                        if (enemy.shootTimer % 35 === 0) {
                            bullets.push({ x: cx, y: cy, vx: 0, vy: 6 * spd, type: 'enemy' });
                        }
                }
            } else if (Math.random() < enemy.shootRate) {
                bullets.push({
                    x: enemy.x,
                    y: enemy.y + 20,
                    vx: 0,
                    vy: 5 * bulletSpeedMult,
                    type: 'enemy'
                });
            }
        }

        // ç¢°æ’æ£€æµ‹
        function checkCollision(a, b) {
            return Math.abs(a.x - b.x) < (a.width + b.width) / 2 &&
                   Math.abs(a.y - b.y) < (a.height + b.height) / 2;
        }

        // æ›´æ–°æ¸¸æˆçŠ¶æ€
        function update() {
            if (!gameState.isRunning || gameState.isPaused) return;

            // å¸§è®¡æ•°ï¼ˆç”¨äºBossæœ€æ—©å‡ºç°æ—¶é—´æ§åˆ¶ï¼‰
            gameState.elapsedFrames = (gameState.elapsedFrames || 0) + 1;

            // æ›´æ–°ç©å®¶ä½ç½® - é”®ç›˜æ§åˆ¶
            if (keys['ArrowLeft'] || keys['KeyA']) player.x -= player.speed;
            if (keys['ArrowRight'] || keys['KeyD']) player.x += player.speed;
            if (keys['ArrowUp'] || keys['KeyW']) player.y -= player.speed;
            if (keys['ArrowDown'] || keys['KeyS']) player.y += player.speed;
            
            // æ›´æ–°ç©å®¶ä½ç½® - è§¦æ‘¸è·Ÿéšæ§åˆ¶
            if (isTouching) {
                // å¹³æ»‘ç§»åŠ¨åˆ°è§¦æ‘¸ä½ç½®
                const dx = touchTarget.x - player.x;
                const dy = touchTarget.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 5) {
                    const moveSpeed = Math.min(player.speed * 1.5, dist);
                    player.x += (dx / dist) * moveSpeed;
                    player.y += (dy / dist) * moveSpeed;
                }
            }
            
            // è¾¹ç•Œé™åˆ¶
            player.x = Math.max(30, Math.min(CONFIG.CANVAS_WIDTH - 30, player.x));
            player.y = Math.max(30, Math.min(CONFIG.CANVAS_HEIGHT - 30, player.y));
            
            // è‡ªåŠ¨å°„å‡»
            playerShoot();
            if (player.shootCooldown > 0) player.shootCooldown--;
            
            // é“å…·æ—¶é—´
            if (gameState.powerUpTime > 0) {
                gameState.powerUpTime--;
                if (gameState.powerUpTime === 0) {
                    gameState.powerUpType = 'none';
                    gameState.powerUpLevel = 0;
                }
            }
            
            // æ— æ•Œæ—¶é—´
            if (gameState.invincibleTime > 0) {
                gameState.invincibleTime--;
                if (gameState.invincibleTime === 0) {
                    gameState.isInvincible = false;
                }
            }
            
            // èªä»”æœºæ—¶é—´ä¸è¡Œä¸º
            if (gameState.droneActive) {
                if (gameState.droneTime > 0) {
                    gameState.droneTime--;
                } else {
                    gameState.droneActive = false;
                    drones = [];
                }
            }

            // èªä»”æœºè·Ÿéšä¸å¼€ç«
            if (gameState.droneActive && drones.length) {
                drones.forEach(d => {
                    // è‡ªåŠ¨å¼€ç«
                    if (d.shootCooldown > 0) d.shootCooldown--;
                    if (d.shootCooldown <= 0) {
                        bullets.push({ x: player.x + d.offsetX, y: player.y + d.offsetY - 10, vx: 0, vy: -CONFIG.BULLET_SPEED, type: 'player' });
                        d.shootCooldown = CONFIG.DRONE_FIRE_COOLDOWN;
                    }
                });
            }

            // æ›´æ–°å­å¼¹
            bullets.forEach((bullet, index) => {
                bullet.y += (bullet.vy || 0);
                bullet.x += (bullet.vx || 0);
                // æ³¢åŠ¨å­å¼¹ç‰¹æ®Šå¤„ç†
                if (bullet.wave) {
                    bullet.x += Math.sin(bullet.y * 0.05 + bullet.waveOffset) * 2;
                }
                if (bullet.y < -20 || bullet.y > CONFIG.CANVAS_HEIGHT + 20 || 
                    bullet.x < -20 || bullet.x > CONFIG.CANVAS_WIDTH + 20) {
                    bullets.splice(index, 1);
                }
            });

            // æ›´æ–°æ•Œäºº
            enemies.forEach((enemy, eIndex) => {
                // ç§»åŠ¨æ¨¡å¼
                switch(enemy.movePattern) {
                    case 0: // ç›´çº¿
                        enemy.y += enemy.speed;
                        break;
                    case 1: // æ­£å¼¦æ³¢
                        enemy.y += enemy.speed;
                        enemy.x += Math.sin(enemy.y * 0.05) * 3;
                        break;
                    case 2: // è¿½è¸ªç©å®¶
                        enemy.y += enemy.speed;
                        if (enemy.x < player.x) enemy.x += 1;
                        if (enemy.x > player.x) enemy.x -= 1;
                        break;
                    case 3: // ä¹‹å­—å½¢
                        enemy.y += enemy.speed;
                        enemy.x += Math.sin(enemy.y * 0.03) * 4;
                        break;
                    case 10: // Bossç‰¹æ®Šç§»åŠ¨
                        // Bosså…ˆè¿›å…¥å±å¹•
                        if (enemy.y < 80) {
                            enemy.y += enemy.speed;
                        } else {
                            // å·¦å³ç§»åŠ¨
                            enemy.x += enemy.speed * 2 * enemy.moveDir;
                            if (enemy.x > CONFIG.CANVAS_WIDTH - 80) enemy.moveDir = -1;
                            if (enemy.x < 80) enemy.moveDir = 1;
                        }
                        break;
                }
                
                // è¾¹ç•Œ
                enemy.x = Math.max(30, Math.min(CONFIG.CANVAS_WIDTH - 30, enemy.x));
                
                // å°„å‡»
                enemyShoot(enemy);
                
                // ç§»å‡ºå±å¹•
                if (enemy.y > CONFIG.CANVAS_HEIGHT + 50) {
                    enemies.splice(eIndex, 1);
                    gameState.combo = 0;
                }
            });

            // æ›´æ–°é“å…·
            powerUps.forEach((p, index) => {
                p.y += p.speed;
                if (p.y > CONFIG.CANVAS_HEIGHT + 20) {
                    powerUps.splice(index, 1);
                }
            });

            // ç¢°æ’æ£€æµ‹ï¼šç©å®¶å­å¼¹ vs æ•Œäºº
            bullets.forEach((bullet, bIndex) => {
                if (bullet.type !== 'player') return;
                
                enemies.forEach((enemy, eIndex) => {
                    let hit = false;
                    if (enemy.type === 'boss') {
                        // åŸºäºBossç»˜åˆ¶è·¯å¾„çš„ç²¾ç¡®å‘½ä¸­
                        if (!enemy._hitPath || enemy._hitPathKey !== enemy.width) {
                            enemy._hitPath = buildBossHitPath(enemy);
                            enemy._hitPathKey = enemy.width;
                        }
                        // å°†å­å¼¹åæ ‡è½¬æ¢åˆ°Bossæœ¬åœ°åæ ‡ï¼ˆæ—‹è½¬äº†180åº¦ï¼‰
                        const lx = enemy.x - bullet.x;
                        const ly = enemy.y - bullet.y;
                        ctx.save();
                        ctx.setTransform(1,0,0,1,0,0); // ä¿è¯ä½¿ç”¨å•ä½å˜æ¢
                        hit = ctx.isPointInPath(enemy._hitPath, lx, ly, 'nonzero');
                        ctx.restore();
                    } else {
                        const hbW = (enemy.hitW || enemy.width);
                        const hbH = (enemy.hitH || enemy.height);
                        hit = Math.abs(bullet.x - enemy.x) < hbW / 2 && Math.abs(bullet.y - enemy.y) < hbH / 2;
                    }
                    if (hit) {
                        bullets.splice(bIndex, 1);
                        enemy.hp--;
                        enemy.hitFlash = 8; // é—ªçƒå¸§æ•°
                        
                        if (enemy.hp <= 0) {
                            createExplosion(enemy.x, enemy.y, enemy.type === 'boss' ? 3 : 1);
                            
                            // Bossè¢«å‡»è´¥
                            if (enemy.type === 'boss') {
                                gameState.bossActive = false;
                                
                                // Bossæ‰è½å¤šä¸ªé“å…·
                                for (let i = 0; i < 3; i++) {
                                    setTimeout(() => {
                                        spawnPowerUp(enemy.x + (Math.random() - 0.5) * 60, enemy.y);
                                    }, i * 100);
                                }
                                
                                if (gameState.gameMode === 'stage') {
                                    // é—¯å…³æ¨¡å¼ï¼šä¿å­˜å½“å‰å…³å¡åˆ†æ•°
                                    const isNewRecord = saveStageScore(gameState.currentStage, gameState.score);
                                    
                                    // è§£é”ä¸‹ä¸€å…³
                                    saveUnlockedStage(gameState.currentStage + 1);
                                    
                                    if (gameState.currentStage >= gameState.maxStage) {
                                        // é€šå…³äº†!
                                        setTimeout(() => gameWin(), 500);
                                    } else {
                                        gameState.currentStage++;
                                        gameState.stageEnemyCount = 0;
                                        gameState.stageBossSpawned = false;
                                        gameState.elapsedFrames = 0;              // æ–°å…³å¡é‡æ–°è®¡æ—¶
                                        gameState.lastBossEndFrame = -99999;      // é‡ç½®ä¸Šæ¬¡Bossç»“æŸæ—¶é—´
                                        setTimeout(() => showStage(), 1000);
                                    }
                                } else {
                                    // æ— å°½æ¨¡å¼ - æ— é™ç»§ç»­
                                    gameState.endlessBossCount++;
                                    gameState.nextBossScore += CONFIG.ENDLESS_NEXT_BOSS_ADD; // æé«˜ä¸‹ä¸€æ¬¡Bossåˆ†æ•°é˜ˆå€¼
                                    gameState.lastBossEndFrame = gameState.elapsedFrames;     // è®°å½•Bossç»“æŸæ—¶é—´
                                }
                            } else {
                                spawnPowerUp(enemy.x, enemy.y);
                                // é—¯å…³æ¨¡å¼è®¡æ•°
                                if (gameState.gameMode === 'stage') {
                                    gameState.stageEnemyCount++;
                                }
                            }
                            enemies.splice(eIndex, 1);
                            
                            // è®¡åˆ†ï¼ˆé™åˆ† + è¿å‡»å°é¡¶ï¼‰
                            let points;
                            switch(enemy.type) {
                                case 'boss': points = 400; break;
                                case 'tank': points = 60; break;
                                case 'sniper': points = 50; break;
                                case 'splitter': points = 40; break;
                                case 'fast': points = 30; break;
                                case 'mini': points = 15; break;
                                default: points = 20;
                            }
                            gameState.combo++;
                            if (gameState.combo > gameState.maxCombo) {
                                gameState.maxCombo = gameState.combo;
                            }
                            const comboMult = 1 + Math.min(gameState.combo, 10) * 0.05; // æœ€é«˜1.5x
                            gameState.score += Math.floor(points * comboMult);
                        }
                    }
                });
            });

            // ç¢°æ’æ£€æµ‹ï¼šæ•Œäººå­å¼¹ vs ç©å®¶ï¼ˆæ— æ•Œæ—¶å…ç–«ï¼‰
            if (!gameState.isInvincible) {
                bullets.forEach((bullet, bIndex) => {
                    if (bullet.type !== 'enemy') return;
                    
                    if (Math.abs(bullet.x - player.x) < 20 &&
                        Math.abs(bullet.y - player.y) < 20) {
                        bullets.splice(bIndex, 1);
                        playerHit();
                    }
                });
                
                // ç¢°æ’æ£€æµ‹ï¼šæ•Œäºº vs ç©å®¶
                enemies.forEach((enemy, eIndex) => {
                    if (checkCollision(
                        { x: player.x, y: player.y, width: 30, height: 30 },
                        { x: enemy.x, y: enemy.y, width: (enemy.hitW || enemy.width), height: (enemy.hitH || enemy.height) }
                    )) {
                        createExplosion(enemy.x, enemy.y);
                        enemies.splice(eIndex, 1);
                        playerHit();
                    }
                });
            }

            // ç¢°æ’æ£€æµ‹ï¼šé“å…· vs ç©å®¶
            powerUps.forEach((p, index) => {
                if (Math.abs(p.x - player.x) < 25 && Math.abs(p.y - player.y) < 25) {
                    if (p.powerType === 'shield') {
                        // æ— æ•ŒæŠ¤ç›¾
                        gameState.isInvincible = true;
                        gameState.invincibleTime = CONFIG.SHIELD_DURATION;
                    } else if (p.powerType === 'drone') {
                        // èªä»”æœº
                        gameState.droneActive = true;
                        gameState.droneTime = CONFIG.DRONE_DURATION;
                        summonDrones();
                    } else {
                        // æ­¦å™¨é“å…· - åŒç±»å åŠ å‡çº§ï¼ˆæœ€å¤š3çº§ï¼‰ï¼Œä¸åŒåˆ™åˆ‡æ¢ä¸º1çº§
                        if (gameState.powerUpType === p.powerType) {
                            gameState.powerUpLevel = Math.min(3, (gameState.powerUpLevel || 0) + 1);
                        } else {
                            gameState.powerUpType = p.powerType;
                            gameState.powerUpLevel = 1;
                        }
                        gameState.powerUpTime = CONFIG.POWERUP_DURATION;
                    }
                    powerUps.splice(index, 1);
                }
            });

            // æ ¹æ®æ¸¸æˆæ¨¡å¼å¤„ç†è¿›åº¦
            if (gameState.gameMode === 'stage') {
            // é—¯å…³æ¨¡å¼ï¼šå‡»è´¥è¶³å¤Ÿæ•Œäººåå‡ºç°Bossï¼ˆä¸”è¾¾åˆ°æœ€çŸ­æ—¶é—´ï¼‰
                const enemiesNeeded = CONFIG.STAGE_BOSS_BASE + gameState.currentStage * CONFIG.STAGE_BOSS_PER_STAGE;
                if (
                    gameState.stageEnemyCount >= enemiesNeeded &&
                    !gameState.bossActive &&
                    !gameState.stageBossSpawned &&
                    gameState.elapsedFrames >= CONFIG.BOSS_MIN_TIME_STAGE
                ) {
                    gameState.stageBossSpawned = true;
                    spawnBoss();
                }
            } else {
                // æ— å°½æ¨¡å¼ï¼šæ³¢æ¬¡å‡çº§
                if (gameState.score > gameState.wave * 1000) {
                    gameState.wave++;
                    showWave();
                }
                
                // æ£€æŸ¥æ˜¯å¦è¦ç”ŸæˆBossï¼ˆè¾¾åˆ°åˆ†æ•°ä¸”ä¸ä¸Šæ¬¡Bossé—´éš”è¶³å¤Ÿé•¿ï¼‰
                if (
                    gameState.score >= gameState.nextBossScore &&
                    !gameState.bossActive &&
                    gameState.elapsedFrames >= (gameState.lastBossEndFrame + CONFIG.BOSS_MIN_TIME_ENDLESS)
                ) {
                    spawnBoss();
                }
            }

            // ç”Ÿæˆæ•Œäºº
            let spawnRate, maxEnemies;
            if (gameState.bossActive) {
                spawnRate = 0.008;
                maxEnemies = 3;
            } else if (gameState.gameMode === 'stage') {
                // ç¬¬1å…³: spawnRate=0.012, maxEnemies=4; ç¬¬20å…³: spawnRate=0.05, maxEnemies=10
                spawnRate = 0.01 + gameState.currentStage * 0.002;
                maxEnemies = 3 + Math.floor(gameState.currentStage * 0.35);
            } else {
                spawnRate = 0.025 + gameState.wave * 0.005;
                maxEnemies = 12 + gameState.wave;
            }
            
            if (Math.random() < spawnRate && enemies.length < maxEnemies) {
                spawnEnemy();
            }

            updateUI();
        }

        // ç©å®¶å—å‡» - ç›´æ¥æ­»äº¡
        function playerHit() {
            createExplosion(player.x, player.y, 1.5);
            gameOver();
        }

        // æ¸¸æˆç»“æŸ
        function gameOver() {
            gameState.isRunning = false;
            document.getElementById('finalScore').textContent = gameState.score;
            
            // è®°å½•å¤±è´¥å…³å¡ç”¨äº"å†æ¬¡å®ˆæŠ¤"
            if (gameState.gameMode === 'stage') {
                localStorage.setItem('resumeStage', String(gameState.currentStage));
            }
            
            // æ˜¾ç¤ºå…³å¡ä¿¡æ¯å’Œæœ€é«˜åˆ†
            const stageInfo = document.getElementById('stageInfo');
            if (gameState.gameMode === 'stage') {
                const highScore = getStageHighScore(gameState.currentStage);
                stageInfo.innerHTML = `ç¬¬ ${gameState.currentStage} å…³ | æœ€é«˜åˆ†: <span style="color:#ffd700">${highScore}</span>`;
            } else {
                const isNewRecord = saveEndlessScore(gameState.score);
                const highScore = getEndlessHighScore();
                stageInfo.innerHTML = isNewRecord 
                    ? `ğŸ‰ æ–°çºªå½•! æœ€é«˜åˆ†: <span style="color:#ffd700">${highScore}</span>`
                    : `æœ€é«˜åˆ†: <span style="color:#ffd700">${highScore}</span>`;
            }
            
            document.getElementById('gameOverScreen').classList.remove('hidden');
        }
        
        // æ¸¸æˆé€šå…³
        function gameWin() {
            gameState.isRunning = false;
            // ä¿å­˜æœ€åä¸€å…³åˆ†æ•°
            saveStageScore(gameState.currentStage, gameState.score);
            document.getElementById('winScore').textContent = gameState.score;
            document.getElementById('winScreen').classList.remove('hidden');
        }

        // ç»˜åˆ¶
        function draw() {
            // ç»˜åˆ¶èƒŒæ™¯
            if (bgImageReady) {
                // ä½¿ç”¨èƒŒæ™¯å›¾ï¼ŒæŒ‰æ¯”ä¾‹ç¼©æ”¾è¦†ç›–æ•´ä¸ªç”»å¸ƒ
                const imgRatio = bgImage.width / bgImage.height;
                const canvasRatio = CONFIG.CANVAS_WIDTH / CONFIG.CANVAS_HEIGHT;
                let drawWidth, drawHeight, offsetX, offsetY;
                
                if (canvasRatio > imgRatio) {
                    // ç”»å¸ƒæ›´å®½ï¼Œä»¥å®½åº¦ä¸ºå‡†
                    drawWidth = CONFIG.CANVAS_WIDTH;
                    drawHeight = CONFIG.CANVAS_WIDTH / imgRatio;
                    offsetX = 0;
                    offsetY = (CONFIG.CANVAS_HEIGHT - drawHeight) / 2;
                } else {
                    // ç”»å¸ƒæ›´é«˜ï¼Œä»¥é«˜åº¦ä¸ºå‡†
                    drawHeight = CONFIG.CANVAS_HEIGHT;
                    drawWidth = CONFIG.CANVAS_HEIGHT * imgRatio;
                    offsetX = (CONFIG.CANVAS_WIDTH - drawWidth) / 2;
                    offsetY = 0;
                }
                
                ctx.drawImage(bgImage, offsetX, offsetY, drawWidth, drawHeight);
            } else {
                // å¤‡ç”¨ï¼šæµ·åº•æ¸å˜èƒŒæ™¯
                const gradient = ctx.createLinearGradient(0, 0, 0, CONFIG.CANVAS_HEIGHT);
                gradient.addColorStop(0, '#001a33');
                gradient.addColorStop(0.3, '#003366');
                gradient.addColorStop(0.6, '#004080');
                gradient.addColorStop(1, '#001a4d');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
            }
            
            // ç»˜åˆ¶å„å…ƒç´ 
            drawStars();
            drawPowerUps();
            drawDrones();
            drawBullets();
            drawEnemies();
            drawPlayer();
            drawExplosions();
        }

        // å¬å”¤èªä»”æœº
        function summonDrones() {
            if (!drones || drones.length === 0) {
                drones = [
                    { offsetX: -45, offsetY: -10, shootCooldown: 0 },
                    { offsetX: 45, offsetY: -10, shootCooldown: 0 }
                ];
            } else {
                // åˆ·æ–°æ—¶é—´å³å¯
            }
        }

        // æ¸¸æˆä¸»å¾ªç¯
        function gameLoop() {
            update();
            draw();
            
            if (gameState.isRunning) {
                requestAnimationFrame(gameLoop);
            }
        }

        // é”®ç›˜äº‹ä»¶
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.code === 'Space') e.preventDefault();
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // ============ ç§»åŠ¨ç«¯è§¦æ‘¸æ§åˆ¶ ============
        let touchTarget = { x: 0, y: 0 };
        let isTouching = false;
        
        // è·å–canvasç›¸å¯¹ä½ç½®
        function getTouchPos(touch) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = CONFIG.CANVAS_WIDTH / rect.width;
            const scaleY = CONFIG.CANVAS_HEIGHT / rect.height;
            return {
                x: (touch.clientX - rect.left) * scaleX,
                y: (touch.clientY - rect.top) * scaleY
            };
        }
        
        // è§¦æ‘¸å¼€å§‹
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const pos = getTouchPos(touch);
            touchTarget.x = pos.x;
            touchTarget.y = pos.y;
            isTouching = true;
        }, { passive: false });
        
        // è§¦æ‘¸ç§»åŠ¨ - é±¼è·Ÿéšæ‰‹æŒ‡
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!isTouching) return;
            const touch = e.touches[0];
            const pos = getTouchPos(touch);
            touchTarget.x = pos.x;
            touchTarget.y = pos.y;
        }, { passive: false });
        
        // è§¦æ‘¸ç»“æŸ
        canvas.addEventListener('touchend', (e) => {
            isTouching = false;
        });
        
        canvas.addEventListener('touchcancel', (e) => {
            isTouching = false;
        });
        
        // é˜²æ­¢é¡µé¢æ»šåŠ¨
        document.addEventListener('touchmove', (e) => {
            if (gameState.isRunning) {
                e.preventDefault();
            }
        }, { passive: false });

        // åˆå§‹åŒ–
        initGame();
        draw();
        
        // ============ é¦–é¡µ Canvas åŠ¨ç”»ç³»ç»Ÿ ============
        const hpCanvas = document.getElementById('homepageCanvas');
        const hpCtx = hpCanvas.getContext('2d');
        let hpFrame = 0;
        let homepageBubbles = [];
        let homepageFish = [];
        let lightRays = [];
        let hpAnimationId = null;
        
        // æ°”æ³¡ç±»
        class HomepageBubble {
            constructor(w, h) {
                this.w = w;
                this.h = h;
                this.reset();
            }
            reset() {
                this.x = Math.random() * this.w;
                this.y = this.h + Math.random() * 50;
                this.r = Math.random() * 10 + 4;
                this.speed = Math.random() * 1.5 + 0.8;
                this.opacity = Math.random() * 0.5 + 0.3;
                this.drift = (Math.random() - 0.5) * 0.8;
            }
            update() {
                this.y -= this.speed;
                this.x += this.drift + Math.sin(hpFrame * 0.03 + this.x * 0.01) * 0.3;
                this.r += 0.01;
                this.opacity = Math.max(0.1, this.opacity - 0.001);
                if (this.y < -30 || this.opacity <= 0.1) this.reset();
            }
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                // æ°”æ³¡å¤–åœˆ
                ctx.beginPath();
                ctx.fillStyle = 'rgba(72, 202, 228, 0.2)';
                ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                ctx.fill();
                // æ°”æ³¡é«˜å…‰
                ctx.beginPath();
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.arc(this.x - this.r * 0.3, this.y - this.r * 0.3, this.r * 0.4, 0, Math.PI * 2);
                ctx.fill();
                // æ°”æ³¡è¾¹æ¡†
                ctx.strokeStyle = 'rgba(72, 202, 228, 0.4)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }
        }
        
        // å…‰æ–‘ç±»
        class LightRay {
            constructor(w, h) {
                this.w = w;
                this.h = h;
                this.reset();
            }
            reset() {
                this.x = Math.random() * this.w;
                this.y = Math.random() * this.h;
                this.size = Math.random() * 120 + 60;
                this.opacity = Math.random() * 0.25 + 0.08;
                this.speed = Math.random() * 0.4 + 0.15;
                this.angle = Math.random() * Math.PI * 2;
            }
            update() {
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                this.opacity += Math.sin(hpFrame * 0.03 + this.x * 0.01) * 0.03;
                this.opacity = Math.max(0.05, Math.min(0.35, this.opacity));
                if (this.x < -this.size || this.x > this.w + this.size ||
                    this.y < -this.size || this.y > this.h + this.size) {
                    this.reset();
                }
            }
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                const grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
                grad.addColorStop(0, 'rgba(72, 202, 228, 0.5)');
                grad.addColorStop(0.5, 'rgba(0, 119, 182, 0.2)');
                grad.addColorStop(1, 'rgba(0, 119, 182, 0)');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        
        // é¦–é¡µé±¼ç±»
        class HomepageFish {
            constructor(w, h) {
                this.w = w;
                this.h = h;
                this.reset();
            }
            reset() {
                this.direction = Math.random() > 0.5 ? 1 : -1;
                this.x = this.direction > 0 ? -50 : this.w + 50;
                this.y = Math.random() * this.h * 0.8 + this.h * 0.1;
                this.r = Math.random() * 15 + 10;
                this.speed = (Math.random() * 1.5 + 0.8) * this.direction;
                this.opacity = Math.random() * 0.4 + 0.4;
                // éšæœºé±¼ç±»å‹ï¼šçƒ­å¸¦é±¼ã€å°ä¸‘é±¼ã€é‡‘é±¼ã€æµ·è±šã€æµ·é¾Ÿã€æ°´æ¯ã€ç« é±¼ã€é²¸é±¼
                const types = ['tropical', 'clownfish', 'goldfish', 'dolphin', 'turtle', 'jellyfish', 'octopus', 'whale'];
                this.type = types[Math.floor(Math.random() * types.length)];
                this.yOffset = 0;
                // åœ¨resetæ—¶å›ºå®šé¢œè‰²ï¼Œé¿å…æ¯å¸§é—ªçƒ
                this.assignColors();
            }
            assignColors() {
                switch(this.type) {
                    case 'tropical':
                        this.bodyColor = `hsl(${180 + Math.random() * 60}, 70%, 60%)`;
                        this.finColor = `hsl(${200 + Math.random() * 40}, 80%, 70%)`;
                        break;
                    case 'clownfish':
                        this.bodyColor = '#ff7f50';
                        this.finColor = '#fff';
                        break;
                    case 'goldfish':
                        this.bodyColor = '#ffd700';
                        this.finColor = '#ffb347';
                        break;
                    case 'dolphin':
                        this.bodyColor = '#4a90d9';
                        this.finColor = '#6bb3e0';
                        break;
                    case 'turtle':
                        this.bodyColor = '#228b22';
                        this.finColor = '#32cd32';
                        break;
                    case 'jellyfish':
                        this.bodyColor = `hsla(${280 + Math.random() * 40}, 60%, 75%, 0.7)`;
                        this.finColor = `hsla(${300 + Math.random() * 30}, 50%, 80%, 0.5)`;
                        break;
                    case 'octopus':
                        this.bodyColor = `hsl(${340 + Math.random() * 30}, 50%, 55%)`;
                        this.finColor = `hsl(${350 + Math.random() * 20}, 60%, 65%)`;
                        break;
                    case 'whale':
                        this.bodyColor = '#36648b';
                        this.finColor = '#5cacee';
                        break;
                    default:
                        this.bodyColor = '#48cae4';
                        this.finColor = '#90e0ef';
                }
            }
            update() {
                this.x += this.speed;
                this.yOffset = Math.sin(hpFrame * 0.04 + this.x * 0.02) * 3;
                if ((this.direction > 0 && this.x > this.w + 60) ||
                    (this.direction < 0 && this.x < -60)) {
                    this.reset();
                }
            }
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.translate(this.x, this.y + this.yOffset);
                if (this.direction < 0) ctx.scale(-1, 1);
                this.drawFishShape(ctx);
                ctx.restore();
            }
            drawFishShape(ctx) {
                const r = this.r;
                const bodyColor = this.bodyColor;
                const finColor = this.finColor;
                const eyeColor = '#fff';
                
                // æ ¹æ®é±¼ç±»å‹ç»˜åˆ¶ä¸åŒå½¢çŠ¶
                if (this.type === 'jellyfish') {
                    this.drawJellyfish(ctx, r, bodyColor, finColor);
                    return;
                }
                if (this.type === 'octopus') {
                    this.drawOctopus(ctx, r, bodyColor, finColor);
                    return;
                }
                if (this.type === 'whale') {
                    this.drawWhale(ctx, r, bodyColor, finColor);
                    return;
                }
                
                // å°¾å·´
                ctx.beginPath();
                ctx.fillStyle = finColor;
                ctx.moveTo(-r * 1.2, 0);
                ctx.lineTo(-r * 2, -r * 0.6);
                ctx.lineTo(-r * 2, r * 0.6);
                ctx.closePath();
                ctx.fill();
                
                // èº«ä½“
                ctx.beginPath();
                ctx.fillStyle = bodyColor;
                ctx.ellipse(0, 0, r * 1.2, r * 0.8, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // èƒŒé³
                ctx.beginPath();
                ctx.fillStyle = finColor;
                ctx.moveTo(-r * 0.3, -r * 0.7);
                ctx.quadraticCurveTo(0, -r * 1.3, r * 0.5, -r * 0.7);
                ctx.lineTo(r * 0.3, -r * 0.7);
                ctx.closePath();
                ctx.fill();
                
                // çœ¼ç›
                ctx.beginPath();
                ctx.fillStyle = eyeColor;
                ctx.arc(r * 0.5, -r * 0.1, r * 0.25, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.fillStyle = '#000';
                ctx.arc(r * 0.55, -r * 0.1, r * 0.12, 0, Math.PI * 2);
                ctx.fill();
                
                // å°ä¸‘é±¼ç‰¹æœ‰æ¡çº¹
                if (this.type === 'clownfish') {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = r * 0.15;
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.3, -r * 0.7);
                    ctx.lineTo(-r * 0.3, r * 0.7);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(r * 0.3, -r * 0.6);
                    ctx.lineTo(r * 0.3, r * 0.6);
                    ctx.stroke();
                }
            }
            // ç»˜åˆ¶æ°´æ¯
            drawJellyfish(ctx, r, bodyColor, finColor) {
                // ä¼ç›–
                ctx.beginPath();
                ctx.fillStyle = bodyColor;
                ctx.arc(0, 0, r, Math.PI, 0, false);
                ctx.closePath();
                ctx.fill();
                // è§¦é¡»ï¼ˆé£˜åŠ¨ï¼‰
                ctx.strokeStyle = finColor;
                ctx.lineWidth = r * 0.1;
                for (let i = 0; i < 5; i++) {
                    const x = (i - 2) * r * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    const wave = Math.sin(hpFrame * 0.08 + i) * r * 0.3;
                    ctx.quadraticCurveTo(x + wave, r * 0.8, x, r * 1.5);
                    ctx.stroke();
                }
            }
            // ç»˜åˆ¶ç« é±¼
            drawOctopus(ctx, r, bodyColor, finColor) {
                // å¤´éƒ¨
                ctx.beginPath();
                ctx.fillStyle = bodyColor;
                ctx.ellipse(0, -r * 0.3, r * 0.9, r * 0.7, 0, 0, Math.PI * 2);
                ctx.fill();
                // è§¦æ‰‹
                ctx.fillStyle = finColor;
                for (let i = 0; i < 6; i++) {
                    const angle = (i - 2.5) * 0.4;
                    const baseX = Math.sin(angle) * r * 0.6;
                    ctx.beginPath();
                    ctx.moveTo(baseX, r * 0.2);
                    const wave = Math.sin(hpFrame * 0.06 + i) * r * 0.2;
                    ctx.quadraticCurveTo(baseX + wave, r * 0.8, baseX * 0.5, r * 1.3);
                    ctx.lineWidth = r * 0.2;
                    ctx.strokeStyle = finColor;
                    ctx.stroke();
                }
                // çœ¼ç›
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(-r * 0.3, -r * 0.4, r * 0.2, 0, Math.PI * 2);
                ctx.arc(r * 0.3, -r * 0.4, r * 0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(-r * 0.25, -r * 0.4, r * 0.1, 0, Math.PI * 2);
                ctx.arc(r * 0.35, -r * 0.4, r * 0.1, 0, Math.PI * 2);
                ctx.fill();
            }
            // ç»˜åˆ¶é²¸é±¼
            drawWhale(ctx, r, bodyColor, finColor) {
                // èº«ä½“
                ctx.beginPath();
                ctx.fillStyle = bodyColor;
                ctx.ellipse(0, 0, r * 1.5, r * 0.9, 0, 0, Math.PI * 2);
                ctx.fill();
                // å°¾å·´
                ctx.beginPath();
                ctx.fillStyle = finColor;
                ctx.moveTo(-r * 1.4, 0);
                ctx.lineTo(-r * 2.2, -r * 0.7);
                ctx.quadraticCurveTo(-r * 1.8, 0, -r * 2.2, r * 0.7);
                ctx.closePath();
                ctx.fill();
                // èƒŒé³
                ctx.beginPath();
                ctx.fillStyle = finColor;
                ctx.moveTo(-r * 0.2, -r * 0.85);
                ctx.quadraticCurveTo(r * 0.3, -r * 1.4, r * 0.8, -r * 0.85);
                ctx.closePath();
                ctx.fill();
                // çœ¼ç›
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(r * 0.8, -r * 0.2, r * 0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(r * 0.85, -r * 0.2, r * 0.1, 0, Math.PI * 2);
                ctx.fill();
                // è‚Œè…¹
                ctx.beginPath();
                ctx.fillStyle = '#b0d4e8';
                ctx.ellipse(r * 0.2, r * 0.3, r * 0.9, r * 0.4, 0, 0, Math.PI);
                ctx.fill();
            }
        }
        
        // åˆå§‹åŒ–é¦–é¡µåŠ¨ç”»
        function initHomepageAnimation() {
            hpCanvas.width = window.innerWidth;
            hpCanvas.height = window.innerHeight;
            const w = hpCanvas.width;
            const h = hpCanvas.height;
            
            homepageBubbles = [];
            for (let i = 0; i < 35; i++) {
                homepageBubbles.push(new HomepageBubble(w, h));
            }
            
            lightRays = [];
            for (let i = 0; i < 6; i++) {
                lightRays.push(new LightRay(w, h));
            }
            
            homepageFish = [];
            for (let i = 0; i < 12; i++) {
                homepageFish.push(new HomepageFish(w, h));
            }
            
            startHomepageAnimation();
        }
        
        // é¦–é¡µåŠ¨ç”»å¾ªç¯
        function homepageAnimationLoop() {
            hpFrame++;
            hpCtx.clearRect(0, 0, hpCanvas.width, hpCanvas.height);
            
            // ç»˜åˆ¶å…‰æ–‘
            for (let ray of lightRays) {
                ray.update();
                ray.draw(hpCtx);
            }
            
            // ç»˜åˆ¶æ°”æ³¡
            for (let bubble of homepageBubbles) {
                bubble.update();
                bubble.draw(hpCtx);
            }
            
            // ç»˜åˆ¶é±¼
            for (let fish of homepageFish) {
                fish.update();
                fish.draw(hpCtx);
            }
            
            hpAnimationId = requestAnimationFrame(homepageAnimationLoop);
        }
        
        function startHomepageAnimation() {
            if (!hpAnimationId) {
                homepageAnimationLoop();
            }
        }
        
        function stopHomepageAnimation() {
            if (hpAnimationId) {
                cancelAnimationFrame(hpAnimationId);
                hpAnimationId = null;
            }
        }
        
        // ç›‘å¬çª—å£å¤§å°å˜åŒ–
        window.addEventListener('resize', () => {
            if (!gameState.isRunning) {
                hpCanvas.width = window.innerWidth;
                hpCanvas.height = window.innerHeight;
                const w = hpCanvas.width;
                const h = hpCanvas.height;
                // é‡ç½®æ‰€æœ‰å…ƒç´ çš„å°ºå¯¸å¼•ç”¨
                homepageBubbles.forEach(b => { b.w = w; b.h = h; });
                lightRays.forEach(r => { r.w = w; r.h = h; });
                homepageFish.forEach(f => { f.w = w; f.h = h; });
            }
        });
        
        // å¯åŠ¨é¦–é¡µåŠ¨ç”»
        initHomepageAnimation();
    </script>
</body>
</html>
